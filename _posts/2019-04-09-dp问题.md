---
title:dp问题
date: 2019-04-09 19:00:00
tags: 算法
---



## DP问题的特征

### 一、背包类型问题

#### 1.特征

- 有一个**类似于容积的东西A，要让你装**【类比一个背包】。

- 有**一系列具备某些属性的物品**【一般至少有两个属性，一个是和占用A容积有关的属性C，还有一个其他属性D】，用于装A

- 在A的容积范围内，**装入物品使得【sum(C)<A】D的值最大或者D为某个固定值x**。或者别的目标

  ```python
          sum[][]=0//边界条件
      	for i in range(1,num+1):
              for j in range(1,capacity+1):
                  if j >=w[i]:
                      sum_v[i][j] = max(sum_v[i-1][j-w[i]] + v[i], sum_v[i-1][j])
                  else:
                      sum_v[i][j] = sum_v[i-1][j]
  ```

#### 2.形式

对于dp数组`dp[i][j]`

- i：一般考虑为前i个物品
- j：一般和当前已放容量有关

#### 3.例题

##### ①poj1837

- 砝码->物品。
  - 包含属性：重量
- 天平的平衡值为0->容量
  - 放入重量，使得天平平衡值保持0

```c++
//poise 使平衡、姿态、体态
//droop 下垂; 消沉
//balance 天平
//negligible 微不足道的; 可以忽略的
//题意：天平有很多钩子，还有很多砝码，要使用上所有砝码，使得天平平衡，问有几种挂砝码的方式使得天平平衡
//求得是放法数量

//0,1背包问题,放物品【只有放与不放,完整放】：dp[i][j]，考虑前i个物品后，占用j容量的最大背包价值【求得是最大背包价值】
//类比本题，放砝码【只有在这个位子放与不放,完整放】：dp[i][j]，考虑前i个砝码，当前平衡情况j【平衡值】的方法数【求得是放法数量】
//物品放入背包，改变容量。砝码放入天平，改变平衡值。
//本题的状态由(前i个物品+平衡值)决定，考虑每个物品的时候都要遍历放置位置，因此位置没有递推性，在考虑每个物品的时候遍历所有位置
//本题和0，1背包的问题在于，01背包是放与不放【取max】，但是本题是必须都放。因此是sum求和的情况【考虑前i个放完】 
#include<iostream>
#include<string.h>
using namespace std;
//最大负/正数平衡值：20*(25)*(15)=7500
int dp[25][7500*2];//由于数组中不能由负数下标，因此将7500映射为平衡值【波动范围为0~15000】
int wnum,posnum;
int w[25];
int p[25];
int main(){
    cin>>posnum>>wnum;
    for(int i=0;i<posnum;i++)
        cin>>p[i];
    for(int i=1;i<=wnum;i++)
        cin>>w[i];
    memset(dp,0,sizeof(dp));
    //起始
    dp[0][7500]=1;//不挂任何砝码时天平平衡，算一种挂法
    for(int i=1;i<=wnum;i++){//因为有i-1，因此从记录w[i]的时候，就从i=1开始
        for(int j=0;j<=15000;j++){
            for(int k=0;k<posnum;k++)
                dp[i][j]+=dp[i-1][j-w[i]*p[k]];//sum
        }
    }
    cout<<dp[wnum][7500]<<endl;

    return 0;
}
```

## 各背包问题

#### 1.部分背包问题

部分背包问题就是一个物品可以只放入一部分【价值和重量按比例】，那么最终这个背包肯定可以装满，**直接贪心，一直加入单位重量价值的最高的物品**，直到放满

#### 2.完全背包问题

每种物品不是只有一个，而是任意个。从这些物品中挑选总重量不超过W的物品，求出挑选物品价值总和的最大值。

- `dp[0][j]=0`
- `dp[i+1][j]=max{dp[i][j-k*w[i]]+k*v[i]|0<=k}`

但直接这样去写程序是三重循环，时间复杂度为O(mW^2).

在这个算法中有多余的计算：

在`dp[i+1][j]`的计算中选择k(k>=1)个 i 物品的情况，与在`dp[i+1][j-w[i]]`的计算中选择k-1的情况是相同的【见如下递推】，所以`dp[i+1][j]`的递推中k>=1部分的计算已经在`dp[i+1][j-w[i]]`的计算中完成了。那么可以按照如下方式进行变形：

```c++
dp[i+1][j]

=max{dp[i][j-k*w[i]]+k*v[i]|0<=k}//k=0表示不放入i物品，k>0表示放入k个i物品

=max(dp[i][j],max{dp[i][j-k*w[i]]+k*v[i]|1<=k})//隔离出k=0，k>=1

=max(dp[i][j],max{dp[i][(j-w[i])-k*w[i]]+k*v[i]|0<=k}+v[i])
    //max(不放入物品，k个物品)=max(不放，放入1个+放入k-1个）
    //=max(不放，放入1个+放入h个）,h=k-1>=0
=max(dp[i][j],dp[i+1][j-w[i]]+v[i])
即：dp[i+1][j]=max(dp[i][j],dp[i+1][j-w[i]]+v[i]) i>=0
```

这样一来就可以用`O(nW)`时间解决问题。

![img](http://hi.csdn.net/attachment/201111/26/1828304_1322294848QzY3.gif)

```c++
for (int i = 1; i <= n; i++) {
    //这里是容量正向，因为是统一层级更新的
        for (int j = weight[i]; j <= m; j++) {
            f[j] = max(f[j], f[j - weight[i]] + value[i]);
        }
    }
```

#### 3.多重背包问题

多重背包问题处于01背包和完全背包之间，每个物品的数量是k个【有限个】

```c++
//dp[i][j]表示前i种物品，背包大小为j的最大总价值
m[i] = min(n[i], j / we[i]) //n[i]表示第i种物品的数量
dp[i][j] = max{f[i - 1][j - k * we[i]] + k * va[i]} {0 <= k <= m[i]}
```

对于这种方法，几乎所有的多重背包的题目，都会超时。时间复杂度为`O（V*n*k）`

##### ①转化为01背包

k个第i种物品===>k种物品，各一个

时间复杂度为`O(V*Σn[i])`

##### ②二进制优化

对于第二种方法，时间复杂度为 `O(n*w*log(m))` (n为物品种数，w为背包大小，m为此物品数量)，是一种比较高效的方法。利用的是二进制优化，所以是log(m)的。

二进制优化的思想是很巧妙的，根据c【i】得到一组这样的数 2^0,2^1,2^2,2^3.....2^(k-1) , c[i]-2^k+1，其中k是满足2^k<c的最大值【注意是2^k，而不是2^(k-1)】

**1到c之间的所有数都可以由这组数组合得到（选取相加）**，<u>而从这组数里任意选任意个（每个数最多只能选一次）加在一起得到的数也必定是1~c这个闭区间内的</u>

- 2^i是10……0的形式，那么2^0,2^1,2^2,2^3.....2^(k-1) 就可以设置任何<=k-1的二进制位为1。因此这些数的和可以表示0~（2^0+2^1+2^2+2^3+.....+2^(k-1) ）=（0，(2^k-1)]之间的任何数【连续的】
- 再加上c[i]-2^k+1，则可以表示（0，(2^k-1)+c[i]-2^k+1]=（0，c[i]]之间的任何数之间的任何数
- 因此简单的遍历[0，c[i]]【O(c[i])】，可以通过遍历 2^0,2^1,2^2,2^3.....2^(k-1) , c[i]-2^k+1得到【O(k+1个数)=O(logc[i])】

例如12=1100 他对应的这组数为：<u>1，2，4</u>，<u>5</u> ，**通过前三个组合可以得到1~7之间的所有数，而加上5就可以得到6~12之间的所有数**，因此可以得到1~12之间的任何数，所以我们可以只对这组数逐一进行01背包，而不用从1到c都要01背包一次，算是把O（c）的部分优化成了O（logc）

- 2^k<14，有2^k=1000B<14=1110B，得到k=3，因此2^0,2^1,2^2,2^3.....2^(k-1) 为1,2,4
- c[i]-2^k+1=c[i]-(2^k-1)=c[i]-(1+2+4)=12-7=5
- 其实这里的2^k-1就是2^0,2^1,2^2,2^3.....2^(k-1)的和【可以表示数中的最大值】，因此通过c[i]-(2^k-1)补足2^(k-1)~c[i]不可以表示数的空白

因此只需要遍历4个数，而不是12个数，从而达到复杂度 `O(n*w*log(m))` (n为物品种数，w为背包大小，m为此物品数量)

```c++
void multi_dp()
{
	int i,j,k,m;
	memset(dp,0,sizeof(dp));
    //一维dp时，注意容量要反过来，以便用i-1更新i
	for(i=0;i<n;i++)
	{
		for(k=1;k<<1<c[i];k<<=1)//依次求出2^i,直到2^(k-1)【k<<=1，且k<<1<c[i]】
		{
			for(j=V;j>=k*v[i];j--)//得到的2^i个物品，要不要加入背包
			{
				dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);//对当前物品，max(不加入，加入)
                //一直都不加入就是0，加入2^1又加入2^2,就是加入5
			}
		}
        //对最后一个数量的物品，判断加入与否
		m=c[i]-k+1;
		for(j=V;j>=m*v[i];j--)
		{
			dp[j]=max(dp[j],dp[j-m*v[i]]+m*w[i]);
		}
	} 
}
```

POJ1276例题优化解析：<https://blog.csdn.net/brazy/article/details/80959170>

##### ③单调队列优化

- [算法思想](https://blog.csdn.net/flyinghearts/article/details/5898183)
  - 原始：
  - m[i] = min(n[i], j / v[i])
  - `F[i][j] `= max { F[i - 1] [j – k \* v[i] ] + k \* w[i] }  (0 <= k <= m[i])
  - 优化：
  - d = v[i]，a = j / d，b = j % d，即 *j = a \* d + b*，代入上述动态转移方程得到：
  - 令k'=a-k，a – m[i] <= k‘ <= a
  - `F[i][j]`=max(`F[i-1][a*d+b - k*d]+k*w[i]`)=max（`F[i-1][b+k'*d]+(a-k')*w[i]`）
  - =max{F[i - 1] [b + k‘ \* d] - k’ \* w[i] } + a \* w[i]   且(a – m[i] <= k‘ <= a)
  - `F[i][j]`就是求j的前面m[i] + 1个数对应的F[i - 1] [b + k * d] - k * w[i]的最大值，加上a * w[i]，如果将F[i][j]前面所有的`F[i - 1][b + k * d] – k * w`放入到一个队列，那么，`F[i][j]`就是求这个队列最大长度为m[i] + 1时，队列中元素的最大值，加上a * w[i]。因而**原问题可以转化为：O(1)时间内求一个队列的最大值**。
- 参考：http://www.alwa.info/2014/05/27/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/
- 

#### 4.01背包

```c++
if (背包体积j小于物品i的体积)
    f[i][j] = f[i-1][j] //背包装不下第i个物体，目前只能靠前i-1个物体装包
else
    f[i][j] = max(f[i-1][j], f[i-1][j-Vi] + Wi)
```

背包问题集合：[背包九讲](https://www.kancloud.cn/kancloud/pack/70124)

## 贪心和dp的区别

#### 一、贪心算法

- 可以由局部最优解推出整体最优解
- 贪心算法中，作出的每步贪心决策都无法改变。因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。
- 贪心法正确的条件是：**每一步的最优解一定包含<u>上一步</u>的最优解。**

#### 二、动态规划算法：

- **全局最优解中一定包含<u>某个局部最优解</u>**，**但<u>不一定包含前一个局部最优解</u>**，因此需要记录之前的所有最优解
  动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解
- 边界条件：即最简单的，可以直接得出的局部最优解【初始化`dp[][]`】

## DP题目设元方式

- 根据物品/对象属性确定状态，确定dp为几维
- 一般有对于递推过程有几种限制->几种状态就有几维dp，每一种限制/状态在一个dp维数中
- 求什么，就将`dp[][]`表示为什么或有相关的运算式
  - 求最少出队人数，`dp[][]`就表示出队人数
  - 求最少花费，`dp[][]`就表示最少花费值
  - 求不符合升序的元素个数，`dp[][]`表示最长上升子序列的元素个数，不符合升序的元素个数=n-`dp[][]`
- 

## POJ dp问题

### 一、最长公共子序列

最长公共子串：子串是一种特殊的子序列，要求连续性

![img](https://img-blog.csdn.net/20161116111138893)

最长公共子序列（Longest Common Subsequence,LCS）:求在所有的子序列中最长的那一个。【不要求连续】

![img](https://img-blog.csdn.net/20161116110820862)

`dp[i][j]`：表示字串a的前i个字符和字串b的前j个字符完成匹配【不代表ind=i-1和ind=j-1的字符匹配了】

#### 1.变式：poj1080 - Human Gene Functions

```c++
//变形的最长公共子序列【带权最长公共子序列】——参考
//要使得匹配度/相似度较好，肯定是两个子串的公共子序列最长最好【对应matrix的相似值为正】
//原来是if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1
//认为子串中字符相等，作为一次匹配
//现在是每一种情况可以匹配出三种：a[i]和b[j]匹配，a[i]和‘-’匹配，b[j]和‘-’匹配【匹配值由matrix计算】
//简单说就是最长公共子序列的变种。
//dp[i][j]表示串s1[0..i]和串s2[0...j]的最长公共子序列
//这里的i和j表示前i个【不包括i】，前j个不包括j
//故dp[i][j] = max(
//dp[i-1][j-1] + matrix[s1[i-1]][s2[j-1]] 表示串s1的第i个字符和串s2的第j个字符匹配
//dp[i-1][j]+matrix[s1[i-1]]['-'] 表示串s1的第i个字符和'-'匹配
//dp[i][j-1]+matrix['-'][s2[j-1]] 表示串s2的第j个字符和'-'匹配
//)
//
//边界值dp[0][0] = 0;
//dp[i][0] = dp[i-1][0] +matrix[s1[i-1]]['-']
//dp[0][i] = dp[0][i-1]+matrix['-'][s2[j-1]]
#include<iostream>
#include<string.h>
#define N 105
using namespace std;
int n;
int dp[N][N];
string str1,str2;
int matrix[5][5]={{5,-1,-2,-1,-3},{-1,5,-3,-2,-4},{-2,-3,5,-2,-2},{-1,-2,-2,5,-1},{-3,-4,-2,-1,-100}};
int GetIndex(char a){
    switch(a){
    case 'A':
        return 0;
    case 'C':
        return 1;
    case 'G':
        return 2;
    case 'T':
        return 3;
    case '-':
        return 4;
    }
}
int Getsimilarity(char a,char b){
    int ain=GetIndex(a);
    int bin=GetIndex(b);
    return matrix[ain][bin];
}
int myMax(int x,int y,int z){
    if(x>=y&&x>=z)
        return x;
    if(y>=x&&y>=z)
        return y;
    return z;
}
int main(){
    cin>>n;
    while(n--){
        int len1;
        int len2;
        cin>>len1>>str1;
        cin>>len2>>str2;
        memset(dp,0,sizeof(dp));
        dp[0][0]=0;//dp[i][j]表示考虑前i个字符，不包括i。前j个字符不包括j，匹配到一样长的相似度
        for(int i=1;i<=len1;i++){
            dp[i][0]=dp[i-1][0]+Getsimilarity(str1[i-1],'-');//匹配时要补充到一样长，由于只考虑str2的前0个字符参与匹配，因此匹配到一样长只能加入-【str2=前0个字符+i个“-”】
            //'-'与str1中的各个字符相匹配，求相似度
        }
        for(int j=1;j<=len2;j++){
            dp[0][j]=dp[0][j-1]+Getsimilarity('-',str2[j-1]);
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                //dp[i-1][j]已经是长度匹配好的了，现在要变成dp[i][j]
                //在str1上是增加了str1[i-1]字符
                //str2上还要保持前j个字符，所以只能加入‘-’，以达到两个子串匹配一样长
                int temp1=dp[i-1][j]+Getsimilarity(str1[i-1],'-');
                int temp2=dp[i][j-1]+Getsimilarity('-',str2[j-1]);
                int temp3=dp[i-1][j-1]+Getsimilarity(str1[i-1],str2[j-1]);
                dp[i][j]=myMax(temp1,temp2,temp3);
            }
        }
        cout<<dp[len1][len2]<<endl;

    }
    return 0;
}
```

#### 2.变式：POJ1159——Palindrome

#####  ①正向思路

```c++
//现在你有一个字符串，问最少插入多少个字符，使得其成为一个回文串【palindrome】
#include<iostream>
#define NMAX 5005
using namespace std;
short dp[NMAX][NMAX];//这个数组是太大了，一开始定义int [5005][5005]，memory error，因此只能改成short
//short类型的范围是-32768~+32767，最多插入的字符也就是5000，因此肯定够用了，还减少了比int小一半的空间
string str;
int main(){
    int n;
    cin>>n;
    cin>>str;
    dp[0][0]=0;
    for(int i=0;i<=n;i++){
        dp[0][i]=i;
    }
    for(int i=0;i<=n;i++){
        dp[i][0]=i;
    }
    //求插入字符数，因此dp就表示插入字符数
    //dp[i][j]表示前i个字符和后j个字符进行匹配【不包括ind=i和ind=n-j-1】【匹配好了的】
    //如果ind=i-1的字符和ind=n-j的字符相同，那么dp[i][j]=dp[i-1][j-1]，即不需要插入字符
    //如果不相同，那么dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1)
    //dp[i-1][j]+1：表示前i-1个字符和后j个字符匹配好了，现在加入ind=i-1【组成前i个字符】
    //我知道str[i-1]!=str[n-j]
    //因此我插入一个字符【放在后j个字符之前的位置】和ind=i-1进行匹配【这样就匹配好了前i个字符和后j个字符】
    //对于原串而言，我加入了ind=i-1进行匹配【组成前i个字符】，并且仍然只取了原串中的j个字符
    //因此得到dp[i][j]
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(str[i-1]==str[n-j]){
                dp[i][j]=dp[i-1][j-1];
            }
            else{
                dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);
            }
        }
    }
    short ans=10000;
    for(int i=0;i<=n;i++){//所有字符都参与匹配，最终填充成偶数的情况
        ans=min(ans,dp[i][n-i]);
    }
    for(int i=0;i<n;i++){//可以有一个字符不参与匹配，也就是最终填充成奇数的情况
        ans=min(ans,dp[i][n-i-1]);
    }
    cout<<ans<<endl;

    return 0;
}
```

##### ②逆向思路

- **回文串，其实就是完全翻转过来求最长公共子序列**

- <u>最少添加字符个数 =  字符串长度  -  原串与逆序串的最大公共子序列长度</u>(注意是公共子序列，不是公共子串

- 将字符串翻转和原串，作为两个子串，求最长公共子序列并用串长，再减去序列长度则可得到结果

- **滚动数组优化内存空间**：滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，**每次都使用固定的几个存储空间【轮换着来使用】**，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中（如01背包问题）。

  - 因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。
  - 在背包问题就求`dp[i][w]`用到`dp[i-1][w]`,因此只需要一份空间就可以复用了。每次dp[w]=dp[w]，后者dp[w]就是i-1轮时候的值，前者dp[w]就是第i个时候的值，下一轮的时候后者的dp[w]就可以舍去了。

- 对于本题而言，求原序列S和逆序列S'的最长公共子序列。求`dp[i][j]`只需要用到dp[i]和dp[i-1]所在的行，之前的结果都不再需要用了。因此行数以0--1--0—1的滚动方式，滚动表达式为i%2和(i-1)%2 【求余滚动】，来回存放上一轮的结果，即可。

- 那么空间开销就能够从5001\*5001压缩到 2\*5001

- 总之，<u>滚动数组，就是根据当前轮的值需要前几轮的值来获得，就定义几个一维即可。用滚动的方式实现空间复用</u>

  ```c++
  if(a[i-1] == a[j-1]){
      dp[e][j] = dp[!e][j-1]+1;
  } 
  else {
      dp[e][j] = (dp[!e][j] > dp[e][j-1])?dp[!e][j]:dp[e][j-1];
  }
  //可以用!e来滚动
  ```

  ```c++
  #include<iostream>
  using namespace std;
  int max(int a,int b)
  {return a>b?a:b;}
  int main(int i,int j)
  {
  	int n;
  	while(cin>>n)
  	{
  		/*Input*/
  		char* s1=new char[n+1];
  		char* s2=new char[n+1];   //s1的逆序列
   
  		int **dp=new int*[n+1];   //定义二维动态滚动数组（本题以01行滚动）
  		dp[0]=new int[n+1];
  		dp[1]=new int[n+1];
  		dp[0][0]=dp[1][0]=0; //动态数组初始化 行开头为全0
  		//也就是只需要定义int dp[2][5001];甚至是short dp[2][5001];
  		for(i=1,j=n;i<=n;i++,j--)//i正序存储，j逆序存储
  		{
  			dp[0][i]=dp[1][i]=0;  //动态数组初始化 列开头为全0
  			char temp;
  			cin>>temp;
  			s1[i]=s2[j]=temp;
  		}
   
  		/*Dp-LCS*/
  		int max_len=0;
  		for(i=1;i<=n;i++)
  			for(j=1;j<=n;j++)
  			{
  				if(s1[i]==s2[j])
  					dp[i%2][j]=dp[(i-1)%2][j-1]+1;//如果字符相等，则dp[i-1][j-1]+1
  				else
  					dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
                      //否则，取dp[i-1][j]或dp[i][j-1]中的最大值
  				if(max_len<dp[i%2][j])
  					max_len=dp[i%2][j];
  			}
  		cout<<n-max_len<<endl;//n-最长公共子序列数
  		delete s1;
  		delete s2;
  		delete[] dp;
  	}
  	return 0;
  }
  ```

  