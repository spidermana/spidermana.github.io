

## Car旅行

#### 已知矩形三个顶点求第四个

- 确定直角点：可以判断(x2-x1)\*(x3-x1)+(y2-y1)\*(y3-y1)是否为0，如果为0，则证明点(x1,y1)即为直角点，如果不是，我们继续判断(x2,y2)，(x3,y3)，这三个点肯定有一个是直角点。

- 利用对角线上的点横坐标之和等于中点横坐标的二倍这个方法求出

- 若已知直角点为x3，y3，那么通过x1，y1和x4，y4可以得到x0，y0，从而延长一倍得到x2，y2

  ![img](https://img-blog.csdnimg.cn/20181214185341538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eXdzNzM5MzA3NDUz,size_16,color_FFFFFF,t_70)

#### 存图

每个机场之间都有航线，这使得用邻接表存图没有意义，因为这个题相当于是个完全图，因此使用邻接矩阵存图

#### 最短路径算法解决

基本最短路算法，但是是多源的。不能只使用一个dijkstra

- floyd

- 4次Dijkstra

  ![](C:\Users\asus\spidermana.github.io\assets\img\dij.jpg)

注意：double的极大值可以赋值为1e100

## 神经网络

这一题就是激活输入层，看看输出层的值是多少。

拓扑排序的变式就可以【+模拟】，一层层传达到输出

- 确定输出层和输入层？
  - 给出了边的信息，只要记录出度就知道了，出度为0的肯定是输出层。
  - 记录入度就能确定哪个是输入层
- 阈值怎么处理？
  - 直接在输入时提前减去就好【c[i]=c[i]-u[i]】，接着只要判断c[i]经过边更新是否大于0就好了。
- 本题坑点：第一层不适用公式，保证会激活，不在意阈值

#### 为什么要用拓扑排序

简单一句话：**【从公式知】所有的节点的权值是从他的上一个节点推过来的，所以这是<u>DAG上的递推关系</u>，我们一般用拓扑排序做。**
$$
先看题目公式：C[i]=\sum\limits_{(j,i)\in E}{W_{(j,i)}}*C[j]-U[i]
$$

$$
发现要想求出 C[i] 就要求出所有C[j] (i,j\in E)的值。
$$

- 举个栗子:

![QQ浏览器截屏未命名.png](https://i.loli.net/2017/08/21/599a8bd4bf68c.png)

- 对于上面这个图，想要算出 F的 C值，就要先算出D和 E的 C 值，也就是要算所有入边的情况【**得到某一个点的值必须要计算所有入边的值——拓扑排序**】
- 这不就是赤裸裸的拓扑排序吗？
- 从上面那个图还可以看出，输入层是入度为0的点（A、B、C），输出层是出度为 0 的点（F），如果你用的是邻接表存图你可以只记录入度不记录出度，因为一个点 u出度为 0相当于 head[u]==0，所以输出的时候判断每个点的 head和 C就好了。

注意：本题没有说正整数，因此要格外小心，阈值和边权都可能为负数