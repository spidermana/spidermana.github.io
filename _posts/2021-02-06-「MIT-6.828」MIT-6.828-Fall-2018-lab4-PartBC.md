---
layout: post
title: "「MIT 6.828」MIT 6.828 Fall 2018 lab4 PartBC"
subtitle: "快呀快呀！！！"
date:        2021-02-06 14:53:00
author:  "许大仙"
catalog: true
tags:
    - 系统
---

## Lab4 Part B: Copy-on-Write Fork

As mentioned earlier, Unix provides the `fork()` system call as its primary process creation primitive. Fork ()系统调用复制调用进程(父进程)的地址空间，以创建新进程(子进程)。

xv6 kernel对fork的实现方式是：xv6 Unix implements `fork()` by **copying all data from the parent's pages into new pages allocated for the child**. 这种方式和dumbfork()实现的方式是类似的。

```c
void
duppage(envid_t dstenv, void *addr)
{
	int r;

	// This is NOT what you should do in your fork.
	if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) < 0)
		panic("sys_page_alloc: %e", r);
	if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
		panic("sys_page_map: %e", r);
	memmove(UTEMP, addr, PGSIZE);
	if ((r = sys_page_unmap(0, UTEMP)) < 0)
		panic("sys_page_unmap: %e", r);
}

envid_t
dumbfork(void)
{
	envid_t envid;
	uint8_t *addr;
	int r;
	extern unsigned char end[];

	// Allocate a new child environment.
	// The kernel will initialize it with a copy of our register state,
	// so that the child will appear to have called sys_exofork() too -
	// except that in the child, this "fake" call to sys_exofork()
	// will return 0 instead of the envid of the child.
	envid = sys_exofork();
	if (envid < 0)
		panic("sys_exofork: %e", envid);
	if (envid == 0) {
		// We're the child.
		// The copied value of the global variable 'thisenv'
		// is no longer valid (it refers to the parent!).
		// Fix it and return 0.
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// We're the parent.
	// Eagerly copy our entire address space into the child.
	// This is NOT what you should do in your fork implementation.
	for (addr = (uint8_t*) UTEXT; addr < end; addr += PGSIZE)
		duppage(envid, addr);

	// Also copy the stack we are currently running on.
	duppage(envid, ROUNDDOWN(&addr, PGSIZE));

	// Start the child environment running
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
		panic("sys_env_set_status: %e", r);

	return envid;
}
```

但是页面的copy操作是fork中最耗时耗力的工作。【The copying of the parent's address space into the child is the most expensive part of the `fork()` operation.】

但是很多时候在调用fork之后就会紧接着调用exec()来创建别的进程代码【和父进程的代码不同】。This is what the the shell typically does, for example。这样的话之前fork时进行父进程->子进程的页面copy就没有意义了，因为子进程在fork之后，调用 exec()之前只会用到很少的代码内存页。

因此，后来的 Unix 版本利用虚拟内存硬件【virtual memory hardware】，允许父进程和子进程共享（share）映射到各自地址空间的内存，直到其中一个进程实际修改它【 *share* the memory mapped into their respective address spaces until one of the processes actually modifies it.】这种技术被称为写时拷贝【*copy-on-write*】。为此，在 fork ()上，内核会将**地址空间映射**从父进程复制到子进程，而不是复制页面的内容【**copy the address space *mappings*** from the parent to the child **instead of the contents of the mapped pages**，and at the same time **mark the now-shared pages read-only**】，<u>同时将现在共享的页面标记为只读</u>。

当两个进程中的任意一个尝试写入其中一个共享页面时，该进程会出现Page Fault。此时，Unix 内核会意识到这个页面实际上是a "virtual" or "copy-on-write" copy，因此在页错误处理时，生成一个新的、私有的、可写的页面副本（copy）到这个导致页错误的进程空间中。通过这种方式，fork时页面内容实际上不会被复制，直到它们被写入，才会进行复制。这种优化使得子进程在 fork()后紧跟exec()的情况下，成本更低：在调用 exec()之前，子进程可能只需要复制一个页面(the current page of its stack，一个栈帧页。其他页面很可能只是读取，反正fork之前的读取到的内容，只要没写过，就和父进程的内容一样，通过share mappings就可以了)。

在这个实验的Part B部分中，您将实现a "proper" Unix-like `fork()` with copy-on-write，作为用户空间库例程（user space library routine）的一部分。在用户空间下，fork实现和copy-on-write支持有助于内核更加简便，更不容易出错。它还允许单个user-mode的程序为 fork()定义自己的语义，eg：一个程序想要一个稍微不同的实现(例如，昂贵的always-copy版本，比如dumbfork() ，或者一个父子进程实际共享内存的版本) ，那么它可以很容易地完成自己的实现。

### User-level page fault handling

user-level copy-on-write fork ()需要了解如何处理带有写保护（write-protected）的页面上触发的page fault，所以您首先要实现这一点。 **Copy-on-write is only one of many possible uses for user-level page fault handling.**

通常设置一个地址空间，以便页错误指示何时需要执行某些操作。例如，大多数 Unix 内核最初只映射新进程的栈区中的一个页面，随着进程的栈消耗增加，导致尚未映射的栈地址出现页面错误后，根据需要分配和映射额外的栈页面。典型的 Unix 内核必须跟踪进程空间的每个区域出现页面错误，即使采取相应操作。例如，栈区中的页错误通常会分配和映射新的物理内存页。程序BSS区域中的页错误通常会分配一个新页面，并用0填充，然后映射这个页。对于某些系统，按需分页的可执行程序中如果在text段发生页错误，会从磁盘中读取相应的页面，然后实时加载到内存进行映射【In systems with demand-paged executables, a fault in the text region will read the corresponding page of the binary off of disk and then map it】。

这对于内核来说是需要跟踪很多的信息。与采用传统的Unix approach不同，您将决定如何处理用户空间中的每个页错误，使得bugs are less damaging。这种设计的额外好处是允许程序在定义其内存区域时具有很大的灵活性。

you'll use user-level page fault handling later for mapping and accessing files on a disk-based file system.

#### Setting the Page Fault Handler

In order to handle its own page faults, a user environment will need to register a *page fault handler entrypoint* with the JOS kernel. 

用户进程通过系统调用`sys_env_set_pgfault_upcall`来注册自己的页错误处理函数入口（*page fault handler entrypoint*）。同时实验中也在`Env`结构体中增加了`env_pgfault_upcall`字段来存储页错误处理入口函数的信息。

##### Exercise 8

> Implement the `sys_env_set_pgfault_upcall` system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a "dangerous" system call.

实现`sys_env_set_pgfault_upcall` 系统调用，能够给指定Environment绑定一个页错误处理函数入口，存储到`Env`结构体的`env_pgfault_upcall`字段中。

```c
// Set the page fault upcall for 'envid' by modifying the corresponding struct Env's 'env_pgfault_upcall' field.  
// When 'envid' process causes a page fault, the kernel will push a fault record onto the exception stack, then branch to 'func' (parameter 2).
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist, or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
	// LAB 4: Your code here.
	struct Env *nowEnv;
	if(envid2env(envid,&nowEnv,1)<0){
		return -E_BAD_ENV;
	}
	nowEnv->env_pgfault_upcall = func;
	return 0;
	//panic("sys_env_set_pgfault_upcall not implemented");
}
```

#### Normal and Exception Stacks in User Environments

在正常执行期间，JOS 中的用户环境将在*normal* user stack上运行，ESP寄存器起始指向USTACKTOP。一开始push的数据驻留在USTACKTOP-PGSIZE~USTACKTOP-1的页面上。When a page fault occurs in user mode, however, the kernel will restart the user environment running a designated user-level page fault handler on a different stack, namely **the *user exception* stack.** In essence, we will make the JOS kernel implement automatic "stack switching" on behalf of the user environment, in much the same way that the x86 *processor* already implements stack switching on behalf of JOS when transferring from user mode to kernel mode!【然而，当用户模式下发生页错误时，内核将重新启动用户环境，在另一个栈，即用户异常栈（*user exception* stack）上运行指定的用户页错误处理程序。本质上，我们将使 JOS 内核代替用户环境实现自动的“栈帧切换”，就像 x86处理器已经代表JOS 实现从用户模式到内核模式的栈切换一样！】

到目前为止出现了三个栈：

```c
　　[KSTACKTOP-KSTKSIZE,  KSTACKTOP) 
　　内核态系统栈
　　[UXSTACKTOP - PGSIZE, UXSTACKTOP)
　　用户态错误处理栈【异常处理栈帧】
　　[UTEXT, USTACKTOP)
　　用户态运行栈
```

内核态系统栈是运行内核相关程序的栈，在有中断被触发之后，CPU会将栈自动切换到内核栈上来，而内核栈是在kern/trap.c的trap_init_percpu()中设置的。而这里的页错误，由JOS kernel将用户栈切换为异常栈。

JOS 用户异常栈（ the user exception stack）也只有一个页面大小，它的顶部被定义为虚拟地址UXSTACKTOP，因此用户异常栈的有效字节为UXSTACKTOP-PGSIZE~UXSTACKTOP-1。在此异常栈上运行时，the user-level page fault handler 可以使用 JOS 的常规系统调用来映射新页面或调整页映射，以便修复最初导致页错误的任何问题【While running on this exception stack, the user-level page fault handler can use JOS's regular system calls to map new pages or adjust mappings so as to fix whatever problem originally caused the page fault】。然后，the user-level page fault handler通过一小段汇编片段返回到导致页错Invoking the User Page Fault Handler误的代码所在的原始栈上（eg：*normal* user stack）。

此外，希望实现自己的user-level page fault handling的用户进程需要为自己的异常栈帧分配内存，可以直接使用part A的`sys_page_alloc()`函数。

#### Invoking the User Page Fault Handler

现在需要更改 kern/trap.c 中的页错误处理代码，以处理用户模式中的页错误，如下所示。我们将页错误发生时用户环境的状态称为*trap-time* state.

如果没有注册页错误处理程序，JOS 内核会像以前一样通过message机制销毁用户环境。否则，**内核会在异常栈帧上设置一个trap frame（looks like a `struct UTrapframe` from `inc/trap.h`**）

```c
struct UTrapframe {
	/* information about the fault */
	uint32_t utf_fault_va;	/* va for T_PGFLT, 0 otherwise */
	uint32_t utf_err;
	/* trap-time return state */
	struct PushRegs utf_regs;
	uintptr_t utf_eip;
	uint32_t utf_eflags;
	/* the trap-time stack to return to */
	uintptr_t utf_esp;
} __attribute__((packed));
```

相比于Trapframe，这里多了utf_fault_va，因为要记录触发错误的内存地址，同时还少了es,ds,ss等。**因为从用户态栈切换到异常栈，或者从异常栈再切换回去，实际上都是一个用户进程，所以不涉及到段的切换，不用记录。**在实际使用中，Trapframe是作为记录进程完整状态的结构体存在的，也作为函数参数进行传递；而UTrapframe只在处理用户定义错误的时候用。

- <u>当正常执行过程中发生了页错误，那么栈的切换是</u>
  - 用户运行栈—>内核栈【硬件trap捕获page fault】—>异常栈
- <u>而如果在异常处理程序中发生了也错误，那么栈的切换是</u>
  - 异常栈—>内核栈【硬件trap捕获page fault】—>异常栈

具体来说第一种情况，当用户模式出现页错误时，处理器将切换到内核栈，并push旧的SS，ESP，ESP，EFLAGS，CS和EIP【由硬件压入，是TrapFrame的一部分】。然后，它将CS:EIP设置为IDT表中设置的条目内所包含的处理程序【eg：page fault handler】。然后，kernel将其他寄存器的值【通用寄存器、ES、DS等】压入内核栈，最终形成Trapframe。此后，调用`kern/trap.c`中的`trap`，根据发生的陷阱类型进行分派`trap_dispatch`。然后我们发现它是一个`T_PGFLT`陷阱，因此我们转到`page_fault_handler`。

在函数中`page_fault_handler`，我们发现页错误发生在用户模式下。目前，发生故障时用户进程的状态即为trap-time state（存储在`page_fault_handler`的`TrapFrame tf`参数中）。然后在`page_fault_handler`中，我们需要设置inc / trap.h中`UTrapframe`结构体到异常栈上作为异常堆栈上的Trap frame。

具体的UTrap Frame布局如下：

```
+------------------+ <- UXSTACKTOP					---			高地址
| trap-time esp    |  	[挨着UENV，比用户栈帧更高]        |
+------------------+                                   |
| trap-time eflags |                                   |
+------------------+                                   |
| trap-time eip    |                                   |
+------------------+ <- Start of struct PushRegs.      |
| trap-time ecx    |                                   |
+------------------+                                   |
|     ……   ……      |                                   \
+------------------+                                    \ Last User-Trap-Frame
| trap-time esp    |                                    /  【trap-time state】
+------------------+                                   /
| trap-time ebp    |                                   |
+------------------+                                   |
| trap-time esi    |                                   |
+------------------+                                   |
| trap-time edi    |                                   |
+------------------+ <- End of struct PushRegs.        |
| tf_err:error code|                                   |
+------------------+                                   |
| fault_va         |                                   |
+------------------+ <- %esp(@) when handler is run. ---
|                  | <== 【在_pgfault_upcall中，会用于存储上一轮导致page fault的指令位置】
+------------------+  |After we have called _pgfault_handler specified by user 
| *trap-time esp   |  |environment, we have to store *trap-time eip to address %esp(@)-4.
+------------------+  |Up to this point, upon we have restored necessary status or 
| *trap-time eflags|  |registers of the User-Trap-Frame such as PushRegs and eflags 
+------------------+  |register,we could use instruction "ret" to pop the *trap-time eip
| *trap-time eip   | ===  we have stored before to register %eip. In other words, that is 
+~~~~~~~~~~~~~~~~~~+  also the reason why we need to store *trap-time eip to %esp(@) -4.
| ................ |
+~~~~~~~~~~~~~~~~~~+											低地址
```

之后内核会重新安排user environment恢复执行【通过页错误处理程序在这个exception stack上运行，解析stack frame】。注意虚拟地址`fault_va`就是导致页错误的位置【缺页的地址，而不是导致缺页的指令地址】。

**还有一些特殊情况**，<u>比如已经运行在exception stack的用户进程发生了异常怎么办？</u>【If the user environment is *already* running on the user exception stack when an exception occurs】也就是说页错误处理程序本身存在错误。在这种情况下，我们需要在当前tf->tf_esp下面启动新的Stack Frame【start the new stack frame just under the current `tf->tf_esp` rather than at `UXSTACKTOP`，You should first push an empty 32-bit word, then a `struct UTrapframe`】，还需要压入空4字节是为了递归page fault在一层层处理完之后可以回溯。

注意，实现时需要判断whether `tf->tf_esp` is already on the user exception stack。请检查它是否在UXSTACKTOP-PGSIZE~ UXSTACKTOP-1之间（inclusive）。

<u>在进入Exercise 9 之前我们来理顺一下思路：</u>

使用专门的User Exception Stack来处理page fault，为了能够在处理完page fault之后能够恢复现场(**这一次不是通过调用env\_run之后的env\_pop\_tf来恢复现场了，因为env\_run用来进入\_pgfault\_upcall(lib/pfentry.S)用户程序了！)**，我们需要在User Exception Stack上构造User Trap Frame。<u>由于page fault可能递归触发</u>，因此我们构造User Trap Frame时需要检测trap-time esp是否已经在User Exception Stack上了，并且针对这种情况，我们需要额外预留4字节的空间以便后续将trap-time eip保存到这预留的4字节空间中，只有这样才能在调用`ret`指令的时候，将trap-time eip从栈中弹出到%eip中【回到上次page fault的指令，才能递归处理一次次页错误】，才能实现从触发此次page fault的指令开始执行的效果！

你可能会有这样的疑问，**为什么第一次在User Exception Stack上构造User Trap Frame时不需要预留4字节的空间？因为User Exception Stack栈顶的UTrapFrame的trap-time esp的值实际上是属于User Normal Stack的！【trap-time esp -4 的位置是在用户栈上，而不是异常栈帧上】**而在调用`ret`指令之前，我们首先会把trap-time esp - 4恢复到寄存器%esp中，这样的话，当我们再调用`ret`指令时，栈指针实际上就指向了返回地址！

##### Exercise 9

>Implement the code in `page_fault_handler` in `kern/trap.c` required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. 
>
>(What happens if the user environment runs out of space on the exception stack?)【注意递归page fault的情况】

Exercise 9实际上就是要我们完成User trap frame的构造，以及把控制转移到用户程序`_pgfault_upcall`【之前的exercise 8在struct Env的env_pgfault_upcall字段中设置了用户自定义的page fault handler】，以及完成从User Normal Stack到User Exceptiob Stack的切换：

```c
void
page_fault_handler(struct Trapframe *tf)
{
	uint32_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();		//从处理器的CR2寄存器中读取到导致页错误的虚拟内存地址

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0){		//如果是kernel中的page fault，那么直接panic
		panic(":( Your kernel triger a page fault at va@0x%08x !Bad kernel", fault_va);
	}

	// 接下来，只能是page fault happened in user mode.
	// Call the environment's page fault upcall, if one exists.  Set up a
	// page fault stack frame on the user exception stack (below
	// UXSTACKTOP), then branch to curenv->env_pgfault_upcall.
	// 
	// The page fault upcall might cause another page fault, in which case
	// we branch to the page fault upcall recursively, pushing another
	// page fault stack frame on top of the user exception stack.
	//
	// Hints:
	//   user_mem_assert() and env_run() are useful here.
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').
	// tf指针就是指向curenv->env_tf
	if(curenv->env_pgfault_upcall){
		struct UTrapframe *utf;
        //判断是递归的page fault还是第一次page fault
        //从而为分配UTrapframe空间。
		if(tf->tf_esp >=UXSTACKTOP-PGSIZE && tf->tf_esp <= (UXSTACKTOP - 1)){
            // the user environment is already running on the exception stack when an exception occurs.
			// Thus,we should start the new stack frame just under the tf->tf_esp.We have to push a word at the top of the trap-time stack as a scratch space.
            // 如果是递归，多分配4字节的空位置。【之后用于恢复执行用】
			utf = (struct UTrapframe *)(tf->tf_esp - 4 - sizeof(struct UTrapframe));
		}
		else
		{
			utf = (struct UTrapframe *)UXSTACKTOP - sizeof(struct UTrapframe);
		}
        // 1.We have to check whether the environment allocate a page with permissions PTE_W for its exception stack and whether the exception stack overflows.
		// 2.Set size to 1 is enough here,because the user environment exception stack's size is only on page,
		// user_mem_assert function will definitely fail as long as the utf's virtual address is already lower than UXSTACKTOP-PGSIZE.Actually,any value between 1 and sizeof(struct UTrapFrame) is okay here.
		// 3.if user_mem_assert fail,this function will not return,just invoke env_destroy and sys_yield.
		user_mem_assert(curenv,(void *)utf,1,PTE_W);
        //通过trapframe来设置utrapframe【通过赋值完成了UTrapfram的布局】
        //结合UTrapframe结构体和布局图来看
		utf->utf_esp = tf->tf_esp;
		utf->utf_eflags = tf->tf_eflags;
		utf->utf_eip = tf->tf_eip;
		utf->utf_regs = tf->tf_regs;
		utf->utf_err = tf->tf_err;
		utf->utf_fault_va = fault_va;
		
        //设置eip为env_pgfault_upcall和栈帧esp位置，从而实现调用用户自定义的页错误处理程序。
        //branch to curenv->env_pgfault_upcall.
		curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
        // Don't forget set stack pointer.
		curenv->env_tf.tf_esp = (uintptr_t)utf;
        // ↓ never return. 
		env_run(curenv);	//转入env_pgfault_upcall执行【权限为用户态】，在异常栈帧上执行。
	}		
	// Destroy the environment that caused the fault.
    //如果没有设置页错误处理程序，则直接终止导致页错误的进程env_destroy(curenv)【注意不是panic kernel噢】
	cprintf("[%08x] user fault va %08x ip %08x\n",
		curenv->env_id, fault_va, tf->tf_eip);
	print_trapframe(tf);
	env_destroy(curenv);
}
```

#### User-mode Page Fault Entrypoint

接下来，需要实现assembly routine ，负责调用 C page fault handler并在原始的导致错误的指令处继续执行。This assembly routine is the handler that will be registered with the kernel using `sys_env_set_pgfault_upcall()`.

##### Exercise 10

> Implement the `_pgfault_upcall` routine in `lib/pfentry.S`. 
>
>The interesting part is returning to the original point in the user code that caused the page fault. 
>
>You'll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.
>
>【完成恢复现场的工作】

```c
//这段汇编的含义可以直接参考：https://blog.csdn.net/bysui/article/details/51842817中的几个图片。
.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
	movl _pgfault_handler, %eax
	call *%eax
	addl $4, %esp			// pop function argument
	
	// Now the C page fault handler has returned and you must return
	// to the trap time state.
	// Push trap-time %eip onto the trap-time stack.
	// 以下需要return到之前的状态【转回上层递归page fault或者转回非递归的page fault即回到用户程序】
    // 退栈或栈帧转移【转回上层递归page fault的栈帧或转回普通用户栈】
 	movl 48(%esp), %ebp
    subl $4, %ebp		// UTrapFrame.utf_esp - 4 and store back
    movl %ebp, 48(%esp)	// 如果是递归page fault，
        				// 那么现在的trap-time esp就是下一个utf的栈顶【跳过了空的4字节位置】
        				// 否则就是用户运行栈的栈顶【陷入内核的时候tf->tf_esp存储的是用户栈栈顶】。
        				// 之后只要pop %esp就可以完成退栈或者栈帧转移
    movl 40(%esp), %eax 
    movl %eax, (%ebp)   //将原来出错指令的eip(即trap-time eip)取出放入保留的4字节位置
        			    //以便后来ret执行时pop eip，来恢复原程序继续运行。
        				//注意这时候%ebp已经被设置为UTrapFrame.utf_esp - 4，也就是保留的4字节位置
        				//或者是用户态栈帧栈顶的空四字节位置

	addl $0x8, %esp         // Set %esp to the end of struct PushRegs
	popal                   // Restore the trap-time registers.(struct PushRegs)

	addl $0x4, %esp         // now we are located at trap-time eip,so we have to increment %esp with 4.【跳过eip】
	popfl                   // Restore eflags register.	【pop eflags】

	popl %esp               // Just restore the adjusted trap-time stack pointer.
							// 恢复esp
	ret                     // We are now on the trap-time stack,since we have saved trap-time eip above trap-time esp,ret instruction will pop this trap-time eip to register %eip which known as PC at this time.Thus,we can return to re-execute the instruction that faulted.
```

##### Exercise 11

最后，需要实现C user library side of the user-level page fault handling mechanism.

>Finish `set_pgfault_handler()` in `lib/pgfault.c`.
>
>【该函数属于库函数的导出函数，内部调用的sys_env_set_pgfault_upcall属于kernel系统调用，需要增加syscall的case】

```c
// Set the page fault handler function.
// If there isn't one yet, _pgfault_handler will be 0.
// The first time we register a handler, we need to
// allocate an exception stack (one page of memory with its top
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))	//注意用户自定义的page fault handler是有一个参数utf的。
{
	int r;
	if (_pgfault_handler == 0) {
		// First time through!	=> Allocate an exception stack[one page]
		// LAB 4: Your code here.
        // 分配异常栈【一个page】，参数0表示curenv
		if(sys_page_alloc(0,(void *)UXSTACKTOP-PGSIZE,PTE_W|PTE_U|PTE_P)<0)
			panic("set_pgfault_handler:sys_page_alloc failed");
	}
	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;	//设置全局变量_pgfault_handler为用户态自定义的page fault handler【只会会被_pgfault_upcall所在的汇编位置调用】
    //设置当前env的env_pgfault_upcall字段为_pgfault_upcall。
    if (sys_env_set_pgfault_upcall(thisenv->env_id,_pgfault_upcall)<0)	
        panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed");
}
```

现在我们大致了解了每个Exercise的函数的含义。然后我们需要把整个流程连贯起来。

来看一下页错误的触发过程以及自定义页错误函数的处理流程。

首先用户会通过`set_pgfault_handler`来分配异常栈帧，并且设置好自定义的page fault handler到全局变量`_pgfault_handler`中，且设置env_pgfault_upcall字段为`_pgfault_upcall`。

当JOS在用户地址空间环境下由于写时复制机制（eg：fork中的Copy on write）而产生的缺页异常，会由硬件捕获，通过trap的一系列过程，最终转入内核态的`page_fault_handler`(kern/trap.c)，然后在rc2寄存器中获取导致异常的指令地址，并且根据当前的esp位置来在异常栈上分配UTrapframe的空间【非递归的话，就直接从UXSTACKTOP位置分配，否则继续从当前异常栈的tf_esp往下分配；异常栈总共就一页，如果递归太多次，超出异常栈的空间会进入非法内存的区域，在user_mem_assert(curenv,(void *)utf,1,PTE_W)检查时会触发错误】

```c
        //通过trapframe来设置utrapframe【通过赋值完成了UTrapfram的布局】
        //结合UTrapframe结构体和布局图来看
		utf->utf_esp = tf->tf_esp;
		utf->utf_eflags = tf->tf_eflags;
		utf->utf_eip = tf->tf_eip;
		utf->utf_regs = tf->tf_regs;
		utf->utf_err = tf->tf_err;
		utf->utf_fault_va = fault_va;
```

<img src="/img/assets/img/image-20210207171634132.png" alt="image-20210207171634132" style="zoom:50%;" />

此后，会将trapframe中存储的有需要的寄存器状态放置到分配的UTrapframe空间中。然后设置当前进程的程序计数器和栈指针（curenv->eip和curenv->esp），然后通过`env_run()`重启这个进程。注意！这一次不是通过调用env\_run之后的env\_pop\_tf来恢复现场了，因为env\_run会用来来进入\_pgfault\_upcall(lib/pfentry.S)用户程序了！【env_run中的env_pop_tf(&(e->env_tf))会读取之前设置的curenv->eip和curenv->esp】

```c
	curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;	//即_pgfault_upcall
	curenv->env_tf.tf_esp = (uintptr_t)utf;	//异常栈帧的顶部。
	env_run(curenv);	//进入_pgfault_upcall
```

在运行\_pgfault\_upcall汇编代码时，是以用户级ring3来运行environment，且运行在异常栈帧上。

首先在会调用存储在全局变量\_pgfault\_handler中的用户态自定义page fault处理函数入口，根据用户自定义的处理方式来处理页错误。注意handler的要求是`void (*handler)(struct UTrapframe *utf)`，以utrapframe为参数，因此直接压入异常栈帧的栈顶，即为指向utf的指针。

```c
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
	movl _pgfault_handler, %eax
	call *%eax
	addl $4, %esp			// pop function argument【清理调用后的栈帧】
```

在调用完用户地址空间中的page fault handler之后，_pgfault_upcall中的后半段汇编需要把控制最终转移回触发这次page fault的用户程序指令。存在缺页的内存地址是由utf->fault_va记录的，而导致缺页的指令地址是utf->tf_eip，因此通过ret【pop utf->tf_eip到%eip】来转回用户空间，同时需要pop出utf->tf_esp到%esp，回到普通用户栈帧。

整个的Control Flow如下所示(省略了一些函数调用)：

![image-20210206155406905](/img/assets/img/image-20210206155406905.png)

最后，我们来理清一下递归page fault需要多分配空的4字节空间的意义。要讲明白这个，需要搞清楚_pgfault_upcall汇编的后半部分干了什么。

考虑第二次Page fault，首先是做一些退出前的准备操作，黑色为调用完_pgfault_handler的异常栈状态。相应颜色指令对应相应颜色的执行结果。

<img src="/img/assets/img/Untitled Diagram.png" alt="Untitled Diagram" style="zoom:23%;" />

接下里是退栈和恢复执行：

<img src="/img/assets/img/mit lab4 (2).png" alt="mit lab4 (2)" style="zoom: 23%;" />

考虑非递归的Page fault返回到用户程序继续执行的过程：

<img src="/img/assets/img/mit lab4 (3).png" alt="mit lab4 (3)" style="zoom:23%;" />

现在应该明确为什么说：

>It is **convenient** for our code which returns from a page fault (lib/pfentry.S) to have one word【4字节】 of scratch space at the top of the trap-time stack; it allows us to more easily restore the eip/esp. 
>
>In the non-recursive case, we don't have to worry about this because the top of the regular user stack is free.  【在非递归的情况下，本来user stack栈顶以下都是空的空间，可以直接存储eip。
>
>In the recursive case,  this means we have to leave an extra word between the current top of the exception stack and the new stack frame because the exception stack _is_ the trap-time stack.【但是如果是递归的情况下，需要留出空的4字节空间存储eip，不然下一层的utrapframe叠加上来以后就没地方存储了】

在完成以上部分后，make grade可以得到50/80。

### Implementing Copy-on-Write Fork

现在我们可以开始实现copy-on-write fork() 了。

Lab4已经在`lib/fork.c`的`fork()`给出了实现的大致框架。类似于`dumbfork()`，`fork()`需要创建一个新的environment，然后扫描整个父进程的地址空间，并在子进程中设置相应的页面映射。但两者差别在于，dumbfork复制所有pages的内容，而fork初始只复制页面映射，仅当父子进程其中一个尝试写某个页面时才会复制整个该页面的实际内容。

`fork()`的基本实现流程如下：

1. The parent installs `pgfault()` as the C-level page fault handler, using the `set_pgfault_handler()` function you implemented above.

   - 父进程通过C运行库中的`set_pgfault_handler()` 函数来设置页错误处理程序。

2. The parent calls `sys_exofork()` to create a child environment.

   - 之后调用`sys_exofork()`创新子进程。

3. For each writable or copy-on-write page in its address space below UTOP, the parent calls `duppage`, which should map the page copy-on-write into the address space of the child and then *remap* the page copy-on-write in its own address space.【对于每一个在UTOP之下的可写或写时拷贝的page，父进程都会调用`duppage`在父子进程的页表中进行设置】 

   - [ Note: The **ordering here** (i.e., <u>marking a page as COW in the child before marking it in the parent</u>) **actually matters**! Can you see why? Try to think of a specific case where reversing the order could cause trouble. ]
   -  `duppage` sets both PTEs so that the page is not writeable, and to contain `PTE_COW` in the "avail" field to distinguish copy-on-write pages from genuine read-only pages.【通过在avail字段设置`PTE_COW`来区别<u>不可写即只读页</u>和<u>写时拷贝页</u>】

   The exception stack is *not* remapped this way, however. Instead you need to <u>allocate a fresh page in the child for the exception stack.</u> Since the page fault handler will be doing the actual copying and the page fault handler runs on the exception stack, **the exception stack cannot be made copy-on-write**: who would copy it?

   `fork()` also needs to handle pages that are present, but not writable or copy-on-write.

4. The parent sets the user page fault entrypoint for the child to look like its own.【父进程为子进程设置子进程的页错误处理程序的入口】

5. The child is now ready to run, so the parent marks it runnable.

每当其中一个进程写了一个尚未写过的 copy-on-write page时，就会出现一个页错误。以下是用户页错误处理程序的control flow：

1. The kernel propagates the page fault to `_pgfault_upcall`, which calls `fork()`'s `pgfault()` handler.
2. <u>`pgfault()` checks that the fault is a write (check for `FEC_WR` in the error code) and that the PTE for the page is marked `PTE_COW`. </u>If not, panic.【panic说明是写了只读页，不合法】
3. `pgfault()` allocates a new page mapped at a temporary location and <u>copies the contents of the faulting page into it.</u> Then the fault handler maps the new page at the appropriate address <u>with read/write permissions, in place of the old read-only mapping.</u>

user-level的`lib/fork.c`代码必须参考进程的页表来执行上面的几个操作(例如，标记页面对应的PTE中的权限为PTE_COW)。The kernel maps the environment's page tables at `UVPT` exactly for this purpose。它使用了一种巧妙的[映射技巧](https://pdos.csail.mit.edu/6.828/2018/labs/lab4/uvpt.html)，使得用户级代码查找PTE变得更加容易。`lib/entry.S`已经定义了uvpt 和 uvpd，因此在 lib/fork.c中可以方便地查找页表信息。

##### Exercise 12

>Implement `fork`, `duppage` and `pgfault` in `lib/fork.c`.
>
>Test your code with the `forktree` program.







最后有很多需要分析和思考的点，可以参考[该链接](https://zhuanlan.zhihu.com/p/50169125)的最后Exercise12部分。

##### *challenge*！

参考：https://qinstaunch.github.io/2020/01/24/MIT-6-828-LAB4-Preemptive-Multitasking/#challenge-implement-shared-memory-sfork

至此Part B部分就完成了。



## Part C: Preemptive Multitasking and Inter-Process communication (IPC)

在实验4的最后一部分，我们将修改kernel以抢占某些”不配合“的进程【抢占式多任务】，并允许进程之间显式地进行传递消息。





## 参考

【1】 [Intel® 64 and IA-32 Architectures Software Developer’s Manual](https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf)
【2】 Liedtke, Jochen. Improving IPC by kernel design[J]. ACM SIGOPS Operating Systems Review, 1993, 27(5):175-188.[PDF](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.158.4191&rep=rep1&type=pdf)