---
layout: post
title: "「MIT 6.828」MIT 6.828 Fall 2018 lab6 PartB"
subtitle: " Lab6 终于到最后一个part了"
date:        2022-11-02 16:34:00
author:  "许大仙"
catalog: true
tags:
    - 系统
---

这是最后的lab 6的最后一个part了！准备完结撒花。

# Part B: Receiving packets and the web server

## Receiving Packets

就像我们之前处理packets传输一样，我们还必须配置E1000来接收数据包（receive packets）并提供接收传输符队列（a receive descriptor queue）和多个接收描述符（receive descriptors）。

Section 3.2描述了如何让packet reception工作，包括了接收队列结构和接收描述符等信息。关于初始化的细节可以参考14.4。

>**Exercise 9.** Read section 3.2. You can ignore anything about interrupts and checksum offloading (you can return to these sections if you decide to use these features later), and you don't have to be concerned with the details of thresholds and how the card's internal caches work.

这个练习的目的是熟悉Manual中Section 3.2和14.4。

### Reading -- Packet Reception

在一般情况下，数据包接收（Packet Reception）包括识别线路上是否存在数据包，执行地址过滤，将数据包存储在接收数据 FIFO 中，将数据传输到主机内存中的接收缓冲区，以及更新接收状态描述符。

-  Packet Address Filtering：硬件根据以下filter模式将传入的数据包存储在主机内存中。如果接收FIFO中没有足够的空间，硬件会丢弃它们并在适当的统计寄存器中指示丢失的数据包。E1000支持的过滤模式有：

  - Exact Unicast/Multicast：必须匹配 one of 16 stored addresses【可以是单播或广播地址】
  - Promiscuous Unicast：接收所有单播地址
  - Multicast：传入数据包的目标地址的高位索引一个位向量，指示是否接受该数据包； 如果向量中的位为 1，则接受该数据包，否则，拒绝它。 控制器提供4096位向量。 软件提供了四种可用于indexing的位的选择。它们是目标地址的内部存储表示的 [47:36]、[46:35]、[45:34] 或 [43:32]。
  - Promiscuous Multicast：接收所有广播地址
  - VLAN：接收所有VLAN的数据包，并具需要在VLAN过滤表中有适当的bit设置。详细解释在第9.3节中。
  - Normally, only good packets are received。 即那些被定义为no CRC error, symbol error, sequence error, length error, alignment error, or where carrier extension or receive errors are detected。但是，如果在设备控制寄存器（Device Control register）中设置了store-bad-packet位（RCTL.SBP），则通过过滤函数的坏包也将存储在主机内存中。 数据包错误由接收描述符中的错误位(RDESC.ERRORS)指示。 如果你想要接受所有的数据包，不论好坏，则需要设置混杂启用位 (RCTL.UPE/MPE) 和存储错误包位（RCTL.SBP）

-  Receive Data Storage：描述符指向的内存缓冲区存储数据包数据。 硬件支持七种接收缓冲区大小：

  - <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102212408383.png" alt="image-20221102212408383" style="zoom:50%;" />
  - 缓存区大小可以通过设置Receive Control register的RCTL.BSIZE & RCTL.BSEX来进行指示【See Section 13.4.22 for details.】
  - 以太网控制器对数据包缓冲区地址没有对齐限制（ alignment restrictions）。This is desirable in situations where the receive buffer was allocated by higher layers in the networking software stack，因为这些较高层可能不知道特定以太网控制器的缓冲区对齐要求。 尽管对齐完全不受限制，但强烈建议软件尽可能在至少高速缓存行的边界上分配接收缓冲区。

- Receive Descriptor Format：接收描述符是一种数据结构，其中包含接收数据缓冲区地址和用于硬件存储数据包信息的字段。表 3-1 列出的阴影区域表示在接收数据包时由硬件修改的字段。

  - <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102212733589.png" alt="image-20221102212733589" style="zoom:50%;" />
  - 收到以太网控制器的数据包后，硬件将数据包数据存储到指定的缓冲区中，并写入长度、数据包校验和、状态、错误和状态字段（the length, Packet Checksum, status, errors, and status fields）。长度涵盖写入接收缓冲区的数据，包括 CRC  bytes（if any）。软件必须读取多个描述符以确定跨越多个接收缓冲区的数据包的完整长度。
  - 对于标准 802.3 数据包（非 VLAN），默认情况下，数据包校验和是在整个数据包上计算的，from the first byte of the DA through the last byte of the CRC, including the Ethernet and IP headers. 软件可以通过接收控制寄存器（Receive Control Register）修改数据包校验和计算的起始偏移量。 该寄存器在Section 13.4.22中描述。 要使用Packet Checksum验证 TCP 校验和，软件必须调整Packet Checksum value以回退不属于真正 TCP 校验和的字节. 
  - 关于这里的Status Field中的详细信息参考Section 3.2.3.1:
    - <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102213413878.png" alt="image-20221102213413878" style="zoom:50%;" />

- Receive Descriptor Fetching：描述符获取策略旨在支持 PCI 总线上的large bursts。这可以通过使用 64 个片上接收描述符（64 on-chip receive descriptors）和优化的获取算法（an optimized fetching algorithm）来实现。 获取算法尝试通过在每次burst获取一个缓存行或更多的描述符来充分利用 PCI 带宽。 详见Section 3.2.4。

  - When the on-chip buffer is nearly empty (RXDCTL.PTHRESH), a prefetch is performed whenever enough valid descriptors (RXDCTL.HTHRESH) are available in host memory and no other PCI activity of greater priority is pending (descriptor fetches and write-backs or packet data transfers).
  - <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102213814760.png" alt="image-20221102213814760" style="zoom:70%;" />

- Receive Descriptor Write-Back：处理器的缓存行大小大于接收描述符大小（16 字节）。 因此，为每个接收到的数据包写回描述符信息将导致昂贵的部分高速缓存行（[cache line](http://www.nic.uoregon.edu/~khuck/ts/acumem-report/manual_html/ch03s02.html)）更新。 有两种机制可以最大限度地减少部分行回写的发生：

  - Receive descriptor packing（Section 3.2.5.1）：打包成cache line单位，在某些条件触发时（如timeout或set write fresh bit）一起写
  - Null descriptor padding（Section 3.2.5.2）：

- Receive Descriptor Queue Structure：图 3-2 显示了接收描述符环形队列的结构。 硬件维护一个环形的描述符，并在推进头指针之前写回使用过的描述符。 when “size” descriptors have been processed.，头和尾指针回绕到base。

  - <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102214635063.png" alt="image-20221102214635063" style="zoom:50%;" />

  - HARDWARE OWNS ALL DESCRIPTORS BETWEEN [HEAD AND TAIL]

  - 软件通过将尾部指针写入最后一个有效描述符之外的条目索引来添加接收描述符。 当数据包到达时，它们被存储在内存中，并且头指针由硬件递增。 当头指针等于尾指针时，环形队列为空。 硬件停止在系统内存中存储数据包，直到软件推进尾指针，使更多的接收缓冲区可用。

  - 接收描述符的头和尾指针引用 16-byte的内存块。图中的阴影框表示已存储传入数据包但尚未被软件识别的描述符。软件可以通过读取内存中的描述符而不是通过I/O来确定接收缓冲区是否有效。任何具有非零status字节的描述符都已由硬件处理，并准备好由软件处理。

  - 关于接收描述符环形队列的各个寄存器信息，可以参考Page. 27

    <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102215310023.png" alt="image-20221102215310023" style="zoom:60%;" />

    <img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102215342240.png" alt="image-20221102215342240" style="zoom:60%;" />

- 剩下是关于接收初始化（Receive Initialization）的问题：
  - Program the <u>Receive Address Register(s) (RAL/RAH) with the desired Ethernet addresses</u>. RAL[0]/RAH[0] should always be used to store the Individual Ethernet MAC address of the Ethernet controller.
  - Initialize the MTA (Multicast Table Array) to 0b
  - Set the Receive Descriptor Length (RDLEN) register to the size (in bytes) of the descriptor ring. This register must be 128-byte aligned.
  - The Receive Descriptor Head and Tail（RDH/RDT） registers are initialized (by hardware) to 0b after a power-on or a software-initiated Ethernet controller reset. 
  - Program the Receive Control (RCTL) register with appropriate values for desired operation。……【太多了，初始化的时候慢慢看就好，有对RCTL.EN，RCTL.LPE的设置等】

接收队列和传输队列非常相似，除了其一开始是被empty packet buffer填充的，然后等待着被incoming packets填充满。因此，如果网络是闲置的话，传输队列一般是空的（because all packets have been sent），但是此时接收队列是充满了empty packet buffers。

当E1000接收到数据包时，它首先检查它是否匹配该card已配置的过滤器（例如，to see if the packet is addressed to this E1000's MAC address，即查看当前到达数据包是否符合E1000的MAC地址），如果数据包不匹配任何过滤器，则忽略了该数据包。

否则，E1000试图从接收队列的头部检索下一个接收描述符。如果头部（RDH）赶上了尾部（RDT），则接收队列用完了所有free描述符，因此card会drop数据包。如果有一个free的接收描述符出现，它将数据包数据复制到描述符指向的缓冲区中，设置描述符的DD（Donecriptor Done）和EOP（End of Packet）状态位，并递增RDH。

如果E1000收到的数据包比一个接收描述符中的数据包缓冲区大，则它将根据需要从接收队列中检索尽可能多的描述符，以存储数据包的整个内容。为了表明这已经发生了，它将在所有这些描述符上设置DD状态位，但仅在这些描述符的最后一个中设置EOP状态位。您可以在driver中处理这种可能，也可以简单地配置card以不接受“长数据包”（也称为 `jumbo frames`），并确保您的接收缓冲区足够大，可以存储最大可能的标准以太网数据包（1518个字节）。

>**Exercise 10.** Set up the receive queue and configure the E1000 by following the process in section 14.4. You don't have to support "long packets" or multicast. For now, don't configure the card to use interrupts; you can change that later if you decide to use receive interrupts. Also, configure the E1000 to strip the Ethernet CRC, since the grade script expects it to be stripped.
>
>By default, the card will filter out *all* packets. You have to configure the Receive Address Registers (RAL and RAH) with the card's own MAC address in order to accept packets addressed to that card. **You can simply hard-code QEMU's default MAC address of 52:54:00:12:34:56 (we already hard-code this in lwIP, so doing it here too doesn't make things any worse)**. Be very careful with the byte order; MAC addresses are written from lowest-order byte to highest-order byte, so 52:54:00:12 are the low-order 32 bits of the MAC address and 34:56 are the high-order 16 bits.
>
>The E1000 only supports a specific set of receive buffer sizes (given in the description of RCTL.BSIZE in 13.4.22). If you make your receive packet buffers large enough and disable long packets, you won't have to worry about packets spanning multiple receive buffers. Also, remember that, just like for transmit, the receive queue and the packet buffers must be contiguous in physical memory.
>
>You should use at least 128 receive descriptors

现在开始Coding了，其实接收部分的Coding和发送部分也是基本上很相似的。

```c
//kern/e1000.h
//For receive
#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
#define E1000_RXDCTL   0x02828  /* RX Descriptor Control queue 0 - RW */
#define E1000_RCTL     0x00100  /* RX Control - RW */
/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
#define E1000_RCTL_SZ_2048        0x00000000    /* rx buffer size 2048 */
#define E1000_RCTL_SZ_1024        0x00010000    /* rx buffer size 1024 */
#define E1000_RCTL_SZ_512         0x00020000    /* rx buffer size 512 */
#define E1000_RCTL_SZ_256         0x00030000    /* rx buffer size 256 */
/* Receive Control */
#define E1000_RCTL_RST            0x00000001    /* Software reset */
#define E1000_RCTL_EN             0x00000002    /* enable */
#define E1000_RCTL_BAM            0x00008000    /* broadcast enable */
#define E1000_RCTL_SECRC          0x04000000    /* Strip Ethernet CRC */
/* Receive Address */
#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */


#define RTXDESC     128
#define TX_BUF_SIZE 1518
#define RX_BUF_SIZE 1518

struct e1000_rx_desc{
    uint64_t addr;  //buffer addr
    uint16_t length;
    uint8_t cso;

    uint8_t status;
    uint8_t err;
    uint16_t special;
}__attribute__((packed));


static struct e1000_rx_desc e1000_rx_queue[RTXDESC];
static char e1000_rx_buffer[RTXDESC][RX_BUF_SIZE];
static uint32_t E1000_MAC[6] = {0x52, 0x54, 0x00, 0x12, 0x34, 0x56};
```

然后我们实现e1000_receive_init函数，并在e1000_init函数中调用它进行接收初始化。

```c
//kern/e1000.c

int e1000_init(struct pci_func *pcif){
    pci_func_enable(pcif);
    bar_va = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);
    uint32_t * status_reg = (uint32_t *)E1000REG (E1000_STATUS);
    assert(*status_reg == 0x80080783);

    e1000_transmit_init();
    
    //char *data = "transmit test\0";
    //e1000_transmit(data, strlen(data));

    e1000_receive_init(); // 在原来的基础上增加了这一行
    return 0;
}

//MAC addresses are written from lowest-order byte to highest-order byte
//so 52:54:00:12 are the low-order 32 bits of the MAC address and 34:56 are the high-order 16 bits.
void e1000_set_mac_addr(uint32_t mac[]){
    uint32_t low = 0, high = 0;

    for(int i = 0; i < 4; i++){
        low |= mac[i] << (8 * i);
    }

    for(int i = 4; i < 6; i++){
        high |= mac[i] << (8 * i);
    }
    (*(uint32_t *)E1000REG(E1000_RA)) = low;
    (*((uint32_t *)E1000REG(E1000_RA) + 1)) = high | E1000_RAH_AV;
}

//for receive
static void e1000_receive_init(){
    memset(e1000_rx_queue, 0, sizeof(e1000_rx_queue));
    memset(e1000_rx_buffer, 0, sizeof(e1000_rx_buffer));

    for(size_t i = 0; i < RTXDESC; i++){
        e1000_rx_queue[i].addr = PADDR(e1000_rx_buffer[i]);
    }

    (*(uint32_t *)E1000REG(E1000_ICS)) = 0;
    (*(uint32_t *)E1000REG(E1000_IMS)) = 0;
    (*(uint32_t *)E1000REG(E1000_RDBAL)) = PADDR(e1000_rx_queue);
    (*(uint32_t *)E1000REG(E1000_RDBAH)) = 0;
    (*(uint32_t *)E1000REG(E1000_RDLEN)) = sizeof(struct e1000_rx_desc) * RTXDESC; //  or = sizeof(e1000_rx_queue)

    (*(uint32_t *)E1000REG(E1000_RDT)) = RTXDESC - 1;
    (*(uint32_t *)E1000REG(E1000_RDH)) = 0;

    (*(uint32_t *)E1000REG(E1000_RCTL)) = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SECRC; // | E1000_RCTL_SZ_2048

    e1000_set_mac_addr(E1000_MAC);
}
```

You can do a basic test of receive functionality now, even without writing the code to receive packets. 

Run `make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput`. `testinput` will transmit an ARP (Address Resolution Protocol) announcement packet (using your packet transmitting system call), which QEMU will automatically reply to. 

Even though your driver can't receive this reply yet, you should see a `e1000: unicast match[0]: 52:54:00:12:34:56` message, indicating that a packet was received by the E1000 and matched the configured receive filter. If you see a `e1000: unicast mismatch: 52:54:00:12:34:56` message instead, the E1000 filtered out the packet, which means you probably didn't configure RAL and RAH correctly. 

<u>Make sure you got the byte ordering right and didn't forget to set the "Address Valid" bit in RAH</u>. If you don't get any "e1000" messages, you probably didn't enable receive correctly.

<img src="E:\github_repository\spidermana.github.io\img\assets\img\image-20221102224704117.png" alt="image-20221102224704117" style="zoom:50%;" />

以上完成了接收初始化之后，现在准备处理接收数据包的逻辑。

## Receiving Packets: Network Server





## The Web Server





# Reference

- [【shishujuan】/mit6.828-2017/lab6-exercize.md](https://github.com/shishujuan/mit6.828-2017/blob/master/docs/lab6-exercize.md)
- [【MIT 6.828】JOS学习笔记 Lab6](https://billyotry.github.io/2021/09/01/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab6/)

推荐一个进阶版的part：[MIT6.S081 Operating System Engineering](https://blog.miigon.net/posts/s081-ending/)

数据链路层（Data Link Layer）是OSI参考模型第二层，位于物理层与网络层之间。在广播式多路访问链路中（局域网），由于可能存在介质争用，它还可以细分成介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，介质访问控制（MAC）子层专职处理介质访问的争用与冲突问题。

PHY: Port Physical Layer,即OSI模型中的物理层。PHY連接一個數據鏈路層的設備（MAC）到一個物理媒介，如光纖或銅纜線。典型的PHY包括PCS（Physical Coding Sublayer，物理編碼子層）和PMD（Physical Media Dependent，物理介質相關子層）。PCS對被傳送和接受的資訊加碼和解碼，目的是使接收器更容易恢復信號。