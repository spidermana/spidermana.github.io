---
title：网络流系列算法
date: 2019-06-29
tags: 算法

---

## 网络流问题

### 一、最大网络流问题

对于一个有向图G而言，存在唯一的源点【入度为0】和汇点【出度为0】，并且每一条有向边存在非负<u>容量</u>C。

则称该图G为网络流图。

计算从源点到汇点的最大<u>流量</u>则是最大网络流问题。【注意最大流可能不止一个】

- 其中源点的流出量=汇点的流入量，称为整个网络的流量。
- 而对于中间点而言只起到转发的作用，对于中间节点：总流入量=总流出量

### 二、最大流算法Ford-Fulkerson算法

FF方法的基础是增广路定理(Augmenting Path Theorem):当且仅当残留网络中没有增广路时，网络达到最大流

#### 1.算法思想：

- 如果存在增广路，就找出一条增广路径。否则已找到最大流
- 沿着这条增广路径对流量进行更新【增加流量】
- 不停找增广路直到没有增广路为止，则找到了最大流

#### 2.找到增广路

所谓增广路径，就是找到这样一条路径，其流量不满，未达到容量上限。

正向边：沿着有向边的指向

逆向边：沿着有向边的反向

f(u,v)表示u到v节点的流量、c(u,v)表示u到v节点的容量

![img](https://images0.cnblogs.com/i/300615/201405/271628351815463.jpg)

对于增广路径②，（1,3）、（2,4）、（4,5）为正向边，而（3,2）为逆向边

【注意这里的增广路径和二分图中的增广路定义不同】

<u>所有的增广路组成了残余网络</u>

#### 3.如何增广呢？

![img](https://images0.cnblogs.com/i/300615/201405/271632434167694.jpg)

第一步，找到一条增广路径【正向边流量未达到容量、逆向边流量大于0】。

第二步，沿着增广路的节点计算拟增加流量值d

- 如果（u,v）是正向边，则增加流量d = min{ c(ai,aj) - f(ai,aj) }，其中 j = i +1, i =1,2,3...,n-1
- 如果（u,v）是逆向边，则增加流量d = min{ f(ai, aj) }，其中j = i +1, i =1,2,3...,n-1

第三步，更新流量

- 如果（u,v）是正向边，则 f(u,v) = f(u,v) **+** d

- 如果（u,v）是逆向边，则f(u,v) = f(u,v) **-** d

第四步，记录整个算法总流量增加+d

理解：

1. 计算正向边容量和流量的差值很好理解，这个流量管道【这条有向边】还剩下多少空间可以增加流量，在这里剩余空间中取得最小值，就是可以增加的上限。
2. 因此也要求了增广路中的正向边必须满足有剩余可增长空间【f(u,v)<c(u,v)】
3. 而对于逆向边而言，如果最终要在这条增广路上流进d流量，那么由于和这条边本身的流量方向是相撞的。因此如果对这条增广路增加d流量，对于这条逆向边而言，抵消了d大小的原来方向的流量。因此对于逆向边而言，流量是减少的d的【f(u,v) = f(u,v) **-** d】
4. 在这些可供减少的流量中取最小可供减少的值，即为d
5. 因此也要求了增广路中的逆向边必须满足有可供减少的流量【f(u,v)>0】

#### 4.理解为什么逆向边减少了流量，最终却使得总流量上升

我们考虑下面这个例子，边上的黑色粗体字表示容量，边上紫框蓝色字表示当前流量【有多个流量值，累加计算即可】

1. 寻找增广路。
   - 找到增广路1->3->2->4->5
   - 由于正向边（1,3）、（2,4）、（4,5）的流量都还没有达到容量值，f(u,v)<c(u,v)【也就是说还存在可增长空间】，并且逆向边（3,2）的流量有可供减少的部分，即f（u,v）=2>0，因此1->3->2->4->5是增广路。
2. 计算d值【该增广路可增长的最大流量】
   - 正向边（1,3）、（2,4）、（4,5）可增值的流量分别为：6-0=6,3-2=1,5-2=3
   - 逆向边（3,2）可抵消的流量为f(u,v)=2
   - d=min(6,1,3,2)=1,该增广路可增长的最大流量为1
3. 更新流量
   - 正向边流量+d、逆向边流量-d
   - 正向边（1,3）、（2,4）、（4,5）边f(u,v) = f(u,v) **+** 1
   - 逆向边（3,2）边f(u,v) = f(u,v) **-** 1
4. 我们先看汇点或者源点，<u>整个网络的流量【=源点流出量=汇点流入量】确实增加了</u>，从4变成了4+1=5。
5. 但是这时候我们看到2->3的从原来的2变成了1，相对于此增广路下的这条逆向边确实对整个网络的总流量做了牺牲，流量减少了。
6. 但是因为2->3流量的减少，使得2->4号边可以走过值为3的流量。
   - 1->4一共有4流量，原来分给2->3为2，2->4为2，但是2->4的容量为3还可以再装下1个，从而可以使得4--->5也多装下一个，汇点流入量上升。
7. 但是如果让2->4走过3流量，1->2又只能供给最多4，因此2->3只能减少为1，那么会影响3->5边的汇点流入量。
8. 可观察到1->3可以补足3号节点的总流入量。
   - 2->3减少为1【使得2->4号边可以走过值为3的流量，使得4->5多装一个，汇点流入量上升】
   - 1->3增加1补足3号节点，因2->3流量减少，而缺失的流量
   - 因此保证了3->5边的汇点流入量不变
9. 从而，4->5增加1，3->5不变，整个网络的流量上升1
10. 综上所述，如果逆向边当前管道从中减去部分流量【f(u,v)-d】，那么伴随着这部分减去的流量，必有另一部分管道【增广路的其他正向边】的流量会增加，以弥补减少量。而且，最后的总流量增加了d
    - **与逆向边相邻的两个正向边，一条帮忙弥补了减少量，一条帮忙增加了汇入点的流量**
    - 因此**总的流量增加d**

![img](https://images0.cnblogs.com/i/300615/201405/271657521817956.jpg)

#### 5.算法实现

```c++

#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<algorithm>
using namespace std;
 
int map[300][300];
int used[300];
int n,m;
const int INF= 2147483647;
 
int DFS(int s, int t, int f)
{
    if(s==t)
        return f;//找到终点了，此时剩下的流量就是能获得的流量
    int i;
    for(i=1;i<=n;i++)
    {
        if(map[s][i] >0 && used[i] ==0)//s到i有边，并且可增长，并且i还没有访问过
        {
            used[i]=1;
            int d=DFS(i, t, min(f, map[s][i]));//继续dfs，往下走，看看能不能走到汇点
            //走的过程还顺带维护了最小可增长流量。
            if(d>0)
            {
                map[s][i] -=d;
                map[i][s] +=d;
                return d;
            }
        }
    }
    return 0;//如果没法找到增广路，会return 0，从而使得if(d>0）不成立
}
 
int maxflow(int s, int t)
{
    int flow=0;
    while(true)
    {
        memset(used, 0, sizeof(used));
        int f= DFS(s,t, INF);//不断找s到t的增广路
        if(f == 0)
            return flow; //找不到了就回去
        flow += f;//找到一个流量f的就赚了
    }
}
 
void init()
{
    memset(map, 0, sizeof(map));
    return ;
}
 
int main()
{
    while(scanf("%d %d", &m, &n) != EOF)
    {
        init();
        int k1,k2, cap;
        int i;
        for(i=1;i<=m;i++)
        {
            scanf("%d %d %d", &k1, &k2, &cap);
            map[k1][k2] += cap;
        }
         
        int ans=maxflow(1,n);
        printf("%d\n", ans);
    }
    //system("pause");
    return 0;
}
```

参考链接：https://www.cnblogs.com/ShaneZhang/p/3755479.html

-------

### 三、最大流算法Edmonds-Karp算法

#### 1.概述

Edmonds-Karp算法，即最短路径增广算法，简称EK算法

EK算法基于一个基本的方法——Ford-Fulkerson方法的优化，EK算法就是不断的找最短路，找的方法就是**每次找一条边数最少的增广，也就是最短路径增广**.

和FF算法的最大区别仅仅在于：<u>找增广路的时候采用广度优先的思想</u>，我们就叫它EdmondsKarp算法。

#### 2.算法实现：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=205;
const int inf=0x7fffffff;
int r[maxn][maxn]; //残留网络，初始化为原图
bool visit[maxn];
int pre[maxn];
int m,n;
bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true
{
    int p;
    queue<int > q;
    memset(pre,-1,sizeof(pre));//pre[]数组记录了增广路，一次每次bfs都重新要初始化
    memset(visit,false,sizeof(visit));
    pre[s]=s;//原点肯定在增广路上，且是起点
    visit[s]=true;
    q.push(s);
    while(!q.empty())
    {
        p=q.front();
        q.pop();
        for(int i=1;i<=n;i++)
        {
            //p->i边
            //如果原始是个正向边，则判断可增长空间r[p][i]>0
            //如果原始是个逆向边，则判断正向流量是否>0
            if(r[p][i]>0&&!visit[i])//从当前节点到i有边，并且i没有被访问过
            {
                pre[i]=p;//记录i的前驱节点为p，表示p到i有一条边
                visit[i]=true;
                if(i==t) return true;//能到达汇点，则说明有增广路
                q.push(i);
            }
        }
    }
    return false;
}
int EdmondsKarp(int s,int t)//源点s和汇点t
{
   int flow=0,d,i;//flow记录了整个网络的总流量
   while(bfs(s,t))//是否还有增广路
   {
       d=inf;
       //由于r的规整，使得d的计算简化了d=min(正向边的可增长空间，逆向边的正向流量)=min(r[pre[i]][i])
       for(i=t;i!=s;i=pre[i])
           d=d<r[pre[i]][i]? d:r[pre[i]][i]; //取最小值，得到拟增加流量d
       //注意这里的遍历方式
       for(i=t;i!=s;i=pre[i])//遍历增广路的所有边
       {   //pre[i]为i节点的前驱节点
           r[pre[i]][i]-=d;//注意这里是正向边，增长d后，可增长的空间减少
           r[i][pre[i]]+=d;//逆向边i->pre[i]的r[i][pre[i]]记录了正方向pre[i]->i的流量+d
       }
       flow+=d;//一条增广路更新后，总流量增加d
   }
   return flow;
}
int main()
{	//对于边i->j
    //r[i][j]：正向边，记录了该正向边的可增长空间
    //r[j][i]：逆向边，记录了该逆向边的i->j流量，如果逆向边的i->j有流量，则可以增广
    //这样减少空间复杂度，只定义了一个二维数组，记录可增广的空间
    //并且使得判断条件归一化
    //对于边i->j，正向走，判断该正向边的可增长空间>0【c[u][v]-f[u][v]>0】
    //对于边j->i，逆向走，判断该逆向边的正方向流量>0
    //因此统一判断r[i][j]>0即可只知：是否满足增广条件
    while(scanf("%d%d",&m,&n)!=EOF)
    {
        int u,v,w;
        memset(r,0,sizeof(r));//初始化为0，则初始时逆向走，没有经过流量
        for(int i=0;i<m;i++)
        {
            scanf("%d%d%d",&u,&v,&w);
            r[u][v]+=w; //容量为初始可增长空间，因此正向边r[u][v]记录了可增广的空间，初始为容量值
        }
        printf("%d\n",EdmondsKarp(1,n));
    }
    return 0;
}
```

### 四、多源点多汇点的网络流问题

以上两种算法是针对单源点-单汇点的网络流问题，**对于多源点-多汇点的网络流问题可以使用超级源点和超级汇点来演变成单源点-单汇点的网络流问题**，将所有源点集中到自定义的虚拟超级源点上。

<u>一般而言，多源点多汇点问题，不同于单源点-单汇点允许源点产生无限流量，汇点消耗无限流量。</u>

<u>而多源点多汇点问题的源点和汇点对流量的产生/消耗都有一定的限制，只能产生x or 只能消耗y</u>

因此，将所有汇点集中到自定义的虚拟超级汇点上，这个虚拟汇点可以消耗无限流量，但是各个汇点到虚拟汇点的管道容量则为该汇点的消耗上限。同理，将所有源点集中到自定义的虚拟超级源点上，这个虚拟源点可以产生无限流量，但是虚拟源点到各个源点的管道容量则为该源点的生产上限。从而保证了多源点多汇点问题的源点和汇点的上限限制，并且把多源点-多汇点的网络流问题来演成单源点-单汇点的网络流问题。

### 五、Dinic算法

#### 1.概述

最短增广路算法【EK算法】的优化版。

参考链接：[最短增广路算法和Dinic算法，详解](https://www.cnblogs.com/LUO77/p/6115057.html)

Dinic算法的思想也是分阶段地在层次网络【残余网络按照路径长分层】中增广。

它与最短增广路算法不同之处是：

- <u>最短增广路每个阶段执行完一次BFS增广后，要重新启动BFS从源点Vs开始寻找另一条增广路;</u>【可能在每个阶段[每个层次网络]可以找到多条增广路，因而多次BFS】
- 而在**Dinic算法中，只需一次DFS过程就可以实现多次增广**，这是Dinic算法的巧妙之处。

注：在残留网络中，把从源点到顶点u的最短路径长度，称为顶点u的层次。源点 Vs的层次为0。可分层的顶点组成的网络叫做层次网络。【参考链接中有详述】

层次网络中不存在从第i层顶点指向第i+k层顶点的弧(k>=2)。【不能有正向的跨层边】

#### 2.Dinic算法具体步骤

1. 初始化容量网络和网络流。
2. 构造残留网络和层次网络[BFS]，若汇点不再层次网络中，则算法结束。
3. 在层次网络中用一次DFS过程进行增广，<u>DFS执行完毕【回溯到源点】，该阶段的增广也执行完毕</u>。
   - 前进的过程中，可能会遇到没有边能够沿着继续前进的情况，这时将路径中的【回溯的】最后一个点【不是最深入的点】在层次图中删除。
   - 还可有边继续扩展的点，不删除，继续扩展
4. 转步骤（2）

第（2）、（3）步被循环执行，将执行（2）、（3）步的一次循环称为一个阶段。在每个阶段中，首先通过BFS根据残留网络建立层次网络【给每个在层次网络中的节点标记层次】，然后用DFS在层次网络中增广，直到在（2）步骤中BFS无法标记汇点的层数【即层次网络不再可以到达汇点】，算法结束

在Dinic的算法步骤中，只有第（3）步与最短增广路相同。在下面实例中，将会发现DFS过程将会使算法的效率有非常大的提高。



#### 3.算法步骤

```c++
//利用BFS构建层次网络[bfs有分层的特点，前面的EK算法，就是在BFS中间接分了层]
//用level数组来存储每个顶点的层数。
//利用dfs进行增广，默认M个节点，第M个节点就是汇点。
//然后当第M个节点[汇点]不在分层网络时，就结束。
const int INF = 0x3f3f3f3f, maxn = 157;
int N, NP, NC, M;
struct E {
    int u, v, flow;
    E(int u = 0, int v = 0, int flow = 0): u(u), v(v), flow(flow) {}
} edg[maxn * maxn];//存储图

int cnt_edg, S, T;
vector<int> edge[maxn]; // 边集
int dis[maxn];//距源点距离,分层图
int current[maxn];//当前弧

void addedg(int u, int v, int flow) {
    edge[u].push_back(cnt_edg);//u节点出边的下标【在edg中的下标】
    edg[cnt_edg++] = E(u, v, flow); // 正向边
    edge[v].push_back(cnt_edg);
    edg[cnt_edg++] = E(v, u, 0); // 反向边容量为0
    // 正向边下标通过异或就得到反向边下标, 2 ^ 1 == 3 ; 3 ^ 1 == 2
}

bool bfs() {//构建层次网络
    queue<int> q;
    q.push(S);
    memset(dis, -1, sizeof(dis));
    dis[S] = 0;
    while (!q.empty()) {
        int index = q.front();
        q.pop();
        int sz = int(edge[index].size());//当前节点的出边数
        for (int i = 0; i < sz; i++) {
            E &e = edg[edge[index][i]];
            if (e.flow > 0) {//可增广
                if (dis[e.v] < 0) {//还未访问过，即未标记，故记录层次
                    dis[e.v] = dis[index] + 1;
                    q.push(e.v);
                }
            }
        }
    }
    return bool(~dis[T]); //返回是否能够到达汇点
}

int dfs(int index, int maxflow) {
    if (index == T)
        return maxflow;
    // i = current[index] 当前弧优化
    int sz = int(edge[index].size());//index节点的出边数
    for (int i = current[index], number; number = edge[index][i], i < sz; i++) {
        current[index] = i;
        E &e = edg[number];//index的出边
        if (dis[e.v] == dis[index] + 1 && e.flow > 0) {//如果是层次网络中的相邻的层【有标记，有边且最短】
            int flow = dfs(e.v, min(maxflow, e.flow));
            if (flow != 0) {//dfs试探多条可到达汇点的边，实现多次增广
                e.flow -= flow; // 正向边流量降低
                edg[number ^ 1].flow += flow; // 反向边流量增加【正反向边相邻存储，就最低位差1】
                return flow;
            }
        }
    }
    return 0; // 找不到增广路 退出
}

int dinic() {
    int ans = 0;
    while (bfs()) {// 建立分层图
        int flow;
        memset(current, 0, sizeof(current)); // BFS后应当清空当前弧数组
        while (bool(flow = dfs(S, INF))) // 一次BFS可以进行多次增广
            ans += flow;
    }
    return ans;
}
//在主函数中存储图【addedg】后，调用dinic()，返回值即为最大网络流
```

注：当前弧优化就只是在增广的过程中添加一个current[]数组记录下一次该走的边以避免重复，虽然是个很细微的部分但是在实际遍历当中的优化是十分巨大的。然后就是在每次分层完之后记得对current[]进行初始化。