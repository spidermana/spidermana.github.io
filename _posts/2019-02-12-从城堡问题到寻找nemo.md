---
title: 城堡问题--> 寻找nemo
date: 2019-02-12 11:35:00
tags: 算法
---

## 城堡问题

#### 1.问题描述

```
     1   2   3   4   5   6   7  
   #############################
 1 #   |   #   |   #   |   |   #
   #####---#####---#---#####---#
 2 #   #   |   #   #   #   #   #
   #---#####---#####---#####---#
 3 #   |   |   #   #   #   #   #
   #---#########---#####---#---#
 4 #   #   |   |   |   |   #   #
   #############################
           (图 1)

   #  = Wall   
   |  = No wall
   -  = No wall
```

图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成mxn(m≤50，n≤50)个方块，每个方块可以有0~4面墙。

##### 输入

程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。**每个方块用代表其周围墙的数字之和表示**。<u>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙</u>。输入的数据保证城堡至少有两个房间。

##### 输出

城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。

##### 样例输入

```
4 
7 
11 6 11 6 3 10 6 
7 9 6 13 5 15 5 
1 10 12 7 13 7 5 
13 11 10 8 10 12 13 
```

##### 样例输出

```
5
9
```

#### 2.思路

城堡问题其实就是染/涂色问题。遍历图中所有可能的点【未访问/未染色的点】，从这个点起对图进行深度优先搜索dfs，每次搜索就是一次染色过程【赋予不同的染色值】

```c++
for(int i=1;i<=m;i++){
  for(int j=1;j<=n;j++){
      if(!vis[i][j]){ //i，j位置还未染色过
   		 area=0; //记录染色面积
   		 dfs(++color,i,j); //从i，j位置起用color对图进行dfs染色
         maxRoomArea = max(maxRoomArea, area);
  	  }
  }
}
```

此外，  **城堡问题的难点还在于如何存储图。**<u>一般需要三维数组</u>

就本题而言，数字1,2,4,8很显然是二进制数，每个城堡房间的数值a为墙值的和，显然如果有1西墙【则a&1==1】，2北墙【则a&2==1】，4东墙【则a&4==1】，8南墙【则a&8==1】

```c++
if(a&1)wall[i][j][0]=1; //i，j位置，有西墙
if(a&2)wall[i][j][1]=1; //i，j位置，有北墙
if(a&4)wall[i][j][2]=1; //i，j位置，有东墙
if(a&8)wall[i][j][3]=1; //i，j位置，有南墙
//或
//如果为0说明不存在该墙，则可以向该方向移动
if((rooms[i][j] & 1)==0)Dfs(i, j-1);   //向西走
if((rooms[i][j] & 2)==0)Dfs(i-1, j);   //向北走
if((rooms[i][j] & 4)==0)Dfs(i, j+1);   //向东走
if((rooms[i][j] & 8)==0)Dfs(i+1, j);   //向南走

```

结果输出：

- 城堡的房间数，即为color有多少种
- 最大房间的方块数，即为maxRoomArea

#### 3.代码解法

```c++
#include<cstdio>
#include<cstring>
bool cant[60][60][4]={0},vis[60][60]={0};
int row[4]={0,-1,0,1};
int col[4]={-1,0,1,0},cnt=0,Max=0,area,m,n,a;
void dfs(int color,int x,int y){
    vis[x][y]=true;
    area++;
    if(area>Max)Max=area;
    for(int i=0;i<4;i++){
      int r=x+row[i],c=y+col[i];
      if(r>=1&&r<=m&&c>=1&&c<=n&&!vis[r][c]&&!cant[x][y][i]){
        dfs(color,r,c);
      }
    }
}
int main(){
  scanf("%d%d",&m,&n);
  for(int i=1;i<=m;i++)
  for(int j=1;j<=n;j++){
    scanf("%d",&a);
    if(a&1)cant[i][j][0]=1;
    if(a&2)cant[i][j][1]=1;
    if(a&4)cant[i][j][2]=1;
    if(a&8)cant[i][j][3]=1;
  }
  for(int i=1;i<=m;i++)
  for(int j=1;j<=n;j++)if(!vis[i][j]){
    area=0;
    dfs(++cnt,i,j);
  }
  printf("%d\n%d\n",cnt,Max);
  return 0;
}

```

```java
public class Main{

    static int r,c;//行列数
    static int[][]rooms = new int[60][60];
    static int[][]color = new int[60][60];       //房间是否染过颜色
    static int maxRoomArea=0;  //最大房间面积
    static int roomNum=0;      //房间的数量
    static int roomArea;       //正在探索的房间的面积
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
        r = in.nextInt();
        c = in.nextInt();
        for(int i=0;i<r;i++)
            for(int j=0;j<c;j++)
                rooms[i][j] = in.nextInt();

        for(int i=0;i<r;i++) {
            for(int j=0;j<c;j++) {
                   //如果未被染色，说明该房间可走
                if(color[i][j]==0) {
                    roomNum++;roomArea=0;
                    Dfs(i,j);
                    maxRoomArea = Math.max(maxRoomArea, roomArea);
                }
            }
        }
        System.out.println(roomNum+"\n"+maxRoomArea);
        in.close();
    }
    private static void Dfs(int i, int j) {

        if(color[i][j]!=0)return;

        ++roomArea;
        color[i][j] = roomNum;
        //1西墙，2北墙，4东墙，8南墙
        //0001 0010 0100 1000
        //将rooms[i][j]与墙对应的数字相与，如果为0说明不存在该墙，则可以向该方向移动
        if((rooms[i][j] & 1)==0)Dfs(i, j-1);   //向西走
        if((rooms[i][j] & 2)==0)Dfs(i-1, j);   //向北走
        if((rooms[i][j] & 4)==0)Dfs(i, j+1);   //向东走
        if((rooms[i][j] & 8)==0)Dfs(i+1, j);   //向南走
    }

```





## 寻找Nemo

#### 1.问题描述

Nemo 是个顽皮的小孩. 一天他一个人跑到深海里去玩. 可是他迷路了. 于是他向父亲 Marlin 发送了求救信号.通过查找地图 Marlin 发现那片海像一个有着墙和门的迷宫.所有的墙都是平行于 X 轴或 Y 轴的. 墙的厚度可以忽略不计.<u>所有的门都开在墙上并且长度为1</u>. Marlin 只能穿过有门的墙. 因为穿过墙是有危险的 (门旁可能会藏有巨毒的水母), Marlin 想穿过尽量少的门找到 Nemo.
图-1 显示了一个迷宫的样例及 Marlin 找到 Nemo的路线.

![img](http://media.openjudge.cn/images/2997_1.jpg)

我们**假设 Marlin 的初始位置在 (0, 0).** 给定 Nemo 的位置和墙及门的位置情况,请你写一个程序计算 <u>Marlin 要找到 Nemo最少要穿过多少道门.</u>

##### 输入

输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始. M 表示迷宫中墙的数目, N 表示门的数目. 接下来有 M 行, 每行包含四个整数描述一堵墙,其格式如下: 
x y d t 
(x, y) 表示墙的左下角, d 是墙的方向 -- 0 表示它与 X-轴平行, 1 表示它与 Y-轴平行, t 表示墙的长度. **墙的两个顶点坐标在[1,199].** 
接下来有 N 行,用来描述门的情况: 
x y d 
x, y, d 与门的描述含义相同. 因为门的长度是 1, t 被省略了. 
每组测试数据的最后一行包含两个**正的浮点数**: 
f1 f2 
**(f1, f2) 给出了 Nemo 的位置. 它不在墙和门上**.

##### 输出

对于每组测试数据，输出一行，该行包含 **Marlin 找到 Nemo需要穿过的最少的门数**. 如果他不可能找到 Nemo, 输出 -1.

##### 样例

![](C:\Users\asus\spidermana.github.io\assets\img\nemo.png)



#### 2.思路

将本题看成城堡问题的变形就较好解决了。

问题的难点在于如何存图，以及对应这个图应该如何行走的问题。

##### （1）存图

依题意，每个迷宫格点都是都是整数型，只有可能nemo处在小数double类型的位置。

因此，我们可以把每个格子对应到左下角。用每个格子的左下角整数坐标（x,y）标识这个格子。对应的map(x,y,0)表示北墙/门，map(x,y,1)表示东墙/门，map(x,y,2)表示南墙/门，map(x,y,3)表示西墙/门。

![存储图的数据结构的使用思路](C:\Users\asus\spidermana.github.io\assets\img\nemo3.png)

**注意：**每个墙数据(x,y,d,t)表示两堵墙，每个门数据(x,y,d)表示两扇门。例如，格子X的北墙是格子A的南墙，格子X的东门是格子B的西门。因此一个门/墙数据要进行两种存储。

- map[x-1] [y] [1]=map[x] [y] [3]=门/墙
- map[x] [y-1] [0]=map[x] [y] [2]=门/墙



##### （2）处理起点和终点

由于墙的两个顶点坐标在[1,199]，并且门都开在墙上，因此**由墙和门组成的迷宫一定是正整数坐标构成的**。如果**Nemo的坐标在迷宫外【这是一个特殊情况，要特殊处理】**，即Nemo的坐标为负数或超过了迷宫的最大X和Y坐标【不过题中有说Nemo的坐标要求为两个正浮点数，因此肯定在第一象限了】，此时输出0，不用进入迷宫，Marlin就可以找到Nemo。

由于Nemo的坐标为两个浮点数，该如何处理Marlin和Nemo终点是否在一个格子的情况呢?

此前我们在建图时，将从格子X走到相邻格子A，简化成格子X的左下坐标走到格子A的左下坐标【判断格子X的北面情况】，因此Marlin的行走都在点上，而不会到浮点类型。**如果Marlin和Nemo现在处在一个格子里【即Marlin找到Nemo，走图成功】，则Nemo坐标(f1,f2)向下取整【即取了所在格子的左下角】应该等于Marlin坐标。**

因此，起初处理终点坐标时,应该

> int endx = int(f1)
>
> int endy = int(f2)

##### (3)行走问题

①行走范围

由于Marlin一开始位于(0,0)，因此可能没有马上走入迷宫。而在迷宫外面游荡。但是题目求取的是Marlin 找到 Nemo需要穿过的最少的门数。只记录门数，因此对应非门非墙的情况【在迷宫外面游荡】，可以走过，但是不用记录步数。因此map(x,y,dir)应该有三种取值，比如0表示非墙非门，1表示墙，2表示门。

- map(x,y,dir)=1，该面方向不可走
- map(x,y,dir)=2，该面方向可以走，并且记录数+1
- map(x,y,dir)=0，该面方向可以走，但是记录数不变

但是总不能老在外面游荡，不进入迷宫吧【由于Nemo在第一象限并且迷宫也在第一象限，因此在非第一象限找，虽然记录门数不会增加，但是无意义，耗时】，因此要限制行走坐标在整体迷宫的右上角坐标以内【迷宫外围一圈也可以走】。超过迷宫右上角坐标的移动无意义了。

![](C:\Users\asus\spidermana.github.io\assets\img\nemo4.png)

②行走方向

行走的方向无非是东西南北/上下左右，4种方向。

```
int indx[]={0,1,0,-1};
int indy[]={1,0,-1,0};
```

- for(i=0;i<4;i++)，进行方向遍历

- 对应i=0，向北走（indx=0，indy=1）要考虑北面情况，因此考虑map(x,y,0)

- 对应i=1，向东走（indx=0，indy=1）要考虑东面情况，因此考虑map(x,y,1)

- ###### ……

- 这样就把行走方向坐标偏移和墙面对上了。

##### (4)DFS处理

普通的广度优先搜索求最短路径

#### 3.解题代码

```c++
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int map[210][210][4];
//[0]北 [1]东 [2]南  [3]西
//0空 1墙 2门
inline int max(int a,int b){
  return a>b?a:b;
}
struct Node{
  int x,y,step;
  bool operator<(const Node &rhs)const{
    return step>rhs.step;//从小到大排序
  }
};
int col[]={0,1,0,-1};
int row[]={1,0,-1,0};
int main(){
  int m,n;
  while(~scanf("%d%d",&m,&n)){
    if(m==-1&&n==-1)break;
    memset(map,0,sizeof(map));
    int x,y,d,t,X=-1,Y=-1;
    for(int i=0;i<m;i++){
      scanf("%d%d%d%d",&x,&y,&d,&t);
      if(d){
        for(int j=0;j<t;j++)map[x-1][y+j][1]=map[x][y+j][3]=1;
        Y=max(Y,y+t);
      }else{
        for(int j=0;j<t;j++)map[x+j][y-1][0]=map[x+j][y][2]=1;
        X=max(X,x+t);
      }
    }
    for(int i=0;i<n;i++){
      scanf("%d%d%d",&x,&y,&d);
      if(d){
        map[x-1][y][1]=map[x][y][3]=2;
        X=max(X,x+1);
      }else{
        map[x][y][2]=map[x][y-1][0]=2;
        Y=max(Y,y+1);
      }
    }
    double f1,f2;
    scanf("%lf%lf",&f1,&f2);
    int ex=(int)f1,ey=(int)f2;
    if(ex<=0||ey<=0||ex>X||ey>Y){
      printf("0\n");
      continue;
    }
    int walk[300][300];
    memset(walk,0x3f,sizeof(walk));
    priority_queue<Node>Q;
    Q.push((Node){0,0,0});
    int ans=0x3f3f3f3f;
    while(!Q.empty()){
      Node now=Q.top();
      Q.pop();
      walk[now.x][now.y]=now.step;
      for(int i=0;i<4;i++){
        int newx=now.x+col[i],newy=now.y+row[i];
        if(newx>=0&&newx<=X&&newy>=0&&newy<=Y&&map[now.x][now.y][i]!=1){
          int t=now.step+(map[now.x][now.y][i]==2);
          if(t>=walk[newx][newy])continue;
          if(newx==ex&&newy==ey){
            walk[newx][newy]=t;
            ans=t;
            continue;
          }
          Q.push((Node){newx,newy,t});
        }
      }
    }
    if(ans==0x3f3f3f3f)printf("-1\n");
    else
    printf("%d\n",ans);
  }
  return 0;
}
```

我的AC代码：

```c++
#include<iostream>
#include<queue>
#include<string.h>
using namespace std;
int map[225][225][4];
//0北，1东，2南，3西 
int endx,endy;
int EdgeX,EdgeY;//边界
bool vis[225][225];
struct node{
	int x;
	int y;
	int steps;
	node(){};
	node(int xx,int yy,int ss):x(xx),y(yy),steps(ss){}
	bool operator < (const node &temp)const{
		return steps>temp.steps;//从小到大排序
	}
};
int indx[]={0,1,0,-1};
int indy[]={1,0,-1,0};
int bfs(){
	priority_queue<node> Q;//优先队列，门数最少的先进行扩展
	memset(vis,0,sizeof(vis));
	vis[0][0]=true;
	Q.push(node(0,0,0));
	while(!Q.empty()){
		node now = Q.top();
		Q.pop();
		for(int i=0;i<4;i++){
			int nowx=now.x+indx[i];
			int nowy=now.y+indy[i];
			int steps = now.steps;
			//到非第一象限找无意义 
			if(nowx<=EdgeX&&nowy<=EdgeY&&nowx>=0&&nowy>=0&&map[now.x][now.y][i]!=1){
				if(!vis[nowx][nowy]){//标准dfs，未访问过才走，已访问过不会更优【因为这里保证了，先扩展的当前门数最少，因此第一次到nowx和nowy位置时，一定是最优穿门数，此后vis的都可以跳过扩展】
					vis[nowx][nowy]=true;
					steps = steps+(map[now.x][now.y][i]==2);
					if(nowx==endx&&nowy==endy){//最短路径优先 
						return steps; 
					}
					Q.push(node(nowx,nowy,steps));
				}
			} 
		}
	}
	return -1;
}

int main(){
	int m,n;//墙数m，门数n
	while(cin>>m>>n){
		if(n==-1&&m==-1)
			break;
		memset(map,0,sizeof(map));
		int x,y,d,t;
		EdgeX=0;
		EdgeY=0;
		for(int i=0;i<m;i++){
			cin>>x>>y>>d>>t;
			if(d){
				EdgeX=max(EdgeX,x);
				EdgeY=max(EdgeY,y+t);//相当于向外拓宽了一个格子了，y+t,x+t 
			}
			else{
				EdgeX=max(EdgeX,x+t);
				EdgeY=max(EdgeY,y);
			}
			for(int j=0;j<t;j++){
				if(d==1){//1平行Y，0平行X
					map[x][y+j][3]=1;//1表示墙，2表示门，0表示空
					map[x-1][y+j][1]=1; 
				}
				else{
					map[x+j][y][2]=1;
					map[x+j][y-1][0]=1;
				}
			}
		}
		
		for(int i=0;i<n;i++){
			cin>>x>>y>>d;//门开在墙上，墙不能出去，但是门可以出去，因此门可以再拓宽 
			if(d==1){
				map[x][y][3]=2;
				map[x-1][y][1]=2;
				EdgeX=max(EdgeX,x+1);
			}
			else{
				map[x][y][2]=2;
				map[x][y-1][0]=2;
				EdgeY=max(EdgeY,y+1);
			}
		}
		double f1,f2;
		cin>>f1>>f2;
		endx=int(f1);//nemo位置 
		endy=int(f2);
		if(endx<=0||endy<=0||endx>EdgeX||endy>EdgeY){//nemo在迷宫右上角以外，那么肯定在外围就可以走到，不用穿过任何门
	      cout<<0<<endl;
	      continue;
	    }
		int ans=bfs();
		cout<<ans<<endl;
	}
	
	
	return 0;
} 
```

