---
title: spfa基础算法
date: 2017-09-11 10:58:00
tags:
- 图论
- 算法
categories:
- 图论
- 算法
---

# 简介
求单源最短路的SPFA算法的全称是：Shortest Path Faster Algorithm。 

从名字我们就可以看出，这种算法在效率上一定有过人之处。 
很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。有人称spfa算法是最短路的万能算法。

简洁起见，我们约定有向加权图G不存在负权回路，即最短路径一定存在。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路。
我们用数组dis记录每个结点的最短路径估计值，可以用邻接矩阵或邻接表来存储图G，推荐使用邻接表。

# spfa算法思想

设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作（更新到达u出度指向的节点的距离），如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 
    
**松弛操作的原理是著名的定理：**“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]>dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。 

**以下变量说明：**

- dis【i】表示源点到i的最短路径长.
- q[]+head(对头指针)+tail(队尾指针)或者queue q表示队列
- vis[i]=true表示i在队列中
- a[i] [j]表示i到j的边长


**下面举一个实例来说明SFFA算法是怎样进行的：**

![有向图G，从源点v0到各点的最短路](/assets/img/spfa1.jpg)

![有向图G，从源点v0到各点的最短路](/assets/img/spfa2.jpg)

**注意：**

1. 只要某个点被更新，那么这个点就必须入队。
2. vis不是标记是否访问过，而是标记是否在队列中
## 和广搜bfs的区别：
    SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是bfs中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进**(重新入队)**，于是再次用来改进其它的点，这样反复迭代下去。
# 算法实现

## 算法的描述：

	void  spfa(s);  //求单源点s到其它各顶点的最短距离
    	for i=1 to n do { dis[i]=∞; vis[i]=false; }   //初始化每点到s的距离，不在队列
    	dis[s]=0;  //将dis[源点]设为0
    	vis[s]=true; //源点s入队列
    	head=0; tail=1; q[tail]=s; //源点s入队, 头尾指针赋初值
    	while head<tail do {
       		head+1;  //队首出队
       		v=q[head];  //队首结点v
       		vis[v]=false;  //释放对v的标记，可以重新入队
       		for 每条边(v,i)  //对于与队首v相连的每一条边
  	  			if (dis[i]>dis[v]+a[v][i])  //如果不满足三角形性质
	 				dis[i] = dis[v] + a[v][i]   //松弛dis[i]
					if (vis[i]=false) {tail+1; q[tail]=i; vis[i]=true;} //不在队列，则加入队列
    } 

## 算法实现

spfa算法模板(邻接矩阵)：

    void spfa(int s){
    	for(int i=0; i<=n; i++) dis[i]=99999999; //初始化每点i到s的距离
    	dis[s]=0; vis[s]=1; q[1]=s;  //队列初始化,s为起点
    	int i, v, head=0, tail=1;//tail下标是最后一个有存的元素，head下标处没有元素，head+1是第一个元素
    	while (head<tail){   //队列非空
    		head++; 
    		v=q[head];  //取队首元素
    		vis[v]=0;   //释放队首结点，因为这节点可能下次用来松弛其它节点，重新入队
    		for(i=0; i<=n; i++)  //对所有顶点
    		   if (a[v][i]>0 && dis[i]>dis[v]+a[v][i]){  
    				dis[i] = dis[v]+a[v][i];   //修改最短路
    				if (vis[i]==0){  //如果更新过i，且扩展结点i不在队列中，入队
    					tail++;
    					q[tail]=i;
    					vis[i]=1;
    				}
    		   }
    		
    	}
      }

此处就可输出dis[目标节点],得到从源头到i的最短路

# 最短路径行走过程怎么记录并且输出？

如何在计算过程中记录下来最短路径是怎么走的，并在最后将它输出呢？

我们定义一个path[]数组，path[i]表示源点s到i的最短路程中，结点i之前的结点的编号(父结点)，我们在借助结点u对结点v松弛的同时，标记下path[v]=u，记录的工作就完成了。

如何输出呢？我们记录的是每个点前面的点是什么，输出却要从最前面到后面输出，这很好办，递归就可以了： 

c++ code:

    void printpath(int k){
    	if (path[k]!=0) printpath(path[k]);
    	cout << k << ' ';
    }

ps:其他内容可以参考[全国信息学奥林匹克竞赛](http://www.layz.net/LAOJ/suanfa/s9-4.html)