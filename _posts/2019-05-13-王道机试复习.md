---
title: 王道机试复习
date: 2019-05-13 14:00:00
---

3天刷完，不然斩！

## 经典入门

### 一、排序

#### while (scanf ("%d",&n) != EOF) 

scanf函数是有返回值的 （尽管大多时候都会被人忽略），它将返回被输入函数成功赋值的变量个数。在 此例中，若成功完成输入并对n赋值，scanf函数的返回值即为1

scanf函数无法再为变量n赋值，于是scanf函数返回EOF（end of file）。 、

若输入为字符串而程序采用gets（）的方法读入，则相同功 能的循环判断语句为while(gets(字符串变量))

#### for(int i……)

而vc6.0中则不同，在for循环退出以 后，指示变量i依然可见（就像在for循环循环体外定义的局部变量）。所以我们在 后续for循环循环条件中定义的新指示变量i会与该旧的指示变量i产生冲突，而无 法被成功的定义，于是编译器于此给出了编译错误。

#### 自定义排序规则

sort中的第三个参数：cmp【返回true，则不交换，x排在y前面】

```c++
bool cmp (int x,int y) { //定义排序规则 
 return x > y; }
```

重载<【返回true，则不交换】

```c++
bool operator < (const E &b) const { //利用C++算符重载直接定义小于运算符   
    if (score != b.score) 
        return score < b.score; //若分数不相同则分数低者在前
    int tmp = strcmp(name,b.name);   
    if (tmp != 0) 
        return tmp < 0;//若分数相同则名字字典序小者在前
    else 
        return age < b.age; //若名字也相同则年龄小者在前 
 }buf[1000]; 
```

strcmp：C/C++函数，比较两个字符串

设这两个字符串为str1，str2，

若str1=str2，则返回零；若str1<str2，则返回负数；若str1>str2，则返回正数。

- sort：#include\<algorithm\>
- greater\<int\>()：#include\<functional\>

#### scanf注意

给出<u>地址</u>做参数

```c++
struct E { 
 char name[101]; 
 int age; 
 int score; 
}buf[1000]; 
scanf ("%s%d%d",buf[i].name,&buf[i].age,&buf[i].score); 
```

%s：buf[i].name【已表示字符串地址】

%d：&buf[i].age

#### 练习题

- 特殊排序（九度教程第 3 题）
- EXCEL 排序（九度教程第 4 题）
  - 实现前导0输出：printf("%04d", i);【4是设置的字符宽度，如果不足则前补0】
- 字符串内排序（九度教程第5题）； 

#### 基本排序算法【堆、归并、快排】

https://www.cnblogs.com/zyb428/p/5673738.html

![Quick Sort](C:\Users\asus\spidermana.github.io\assets\img\wd1.png)

### 二、日期类

#### 区间差问题

两个日期的差：解决这类区间问题有一个统一的思想——把原区间问题统一到起点确定的区间问题上去。在该例中，我们不妨把问题统一到特定日期与一个原点时间（如 0000 年 1 月 1 日） 的天数差

#### 闰年

闰年2月有 29 天。

闰年的判断规则——当年数不能被100整除时若其能被4整除则为闰年，或者其能被 400整除时也是闰年。

用逻辑语言表达出来即为**Year%100 != 0 && Year%4 == 0 || Year%400 == 0，当逻辑表达式为true时，其为闰年；**

#### 大数组

开辟大量内存空间的情况：

1. 定义为全局变量。
2. 或者在函数中使用 malloc等函数动态申请变量空间。

#### 通过%nd分隔输入数据

用一个连续的八位数来代替日期，我们使用%4d来读取该八位数的前四位并赋值给代表年的变量，同理使用%2d%2d 来读取其它后四位并两两赋值给月日。

这种利用在%d 之间插入数字来读取特定位数的数字的技巧。

#### 不同年的天数存储

```c++
#define ISYEAP(x) x % 100 != 0 && x % 4 == 0 || x % 400 == 0 ? 1 : 0 
//dayOfMonth[Month][ISYEAP(Year)]获取月份天数
int dayOfMonth[13][2] = { 
 0,0, 
 31,31, 
 28,29, 
 31,31, 
 30,30, 
 31,31, 
 30,30, 
 31,31, 
 31,31, 
 30,30, 
 31,31, 
 30,30, 
 31,31 }; //预存每月的天数,注意二月配合宏定义作特殊处理 
```

#### 求星期

已知某日期是星期X

现在求的日期对应的星期=(星期X+abs(天数差)%7)%7+1

#### 练习题

- 今年的第几天？
- 打印日期

### 三、Hash应用

#### 输出前m大的数

##### 1.数组区间

由于待排序数字的数量为1000000， 快速排序O（nlogn）的时间复杂度也会达到千万数量级，而这在一秒时限内不可行。

该例题面限定了输入的数字一定是[-500000,500000]区间里的整数，且各不相同。若利用一个数组分别统计每一种数字是否出现，输出较大的 m 个数字，也仅需要从尾至头遍历这个数组，其时间复杂度只需要O（n）。

```c++
#define OFFSET 500000 //偏移量,用于补偿实际数字与数组下标之间偏移
bool Hash[1000001]; //Hash数组,记录每个数字是否出现,不出现为0,出现后被标记成1 
scanf ("%d",&x); 
Hash[x + OFFSET] = 1; //凡是出现过的数字,该数组元素均被设置成1 
```

假如去除输入数字做了“各不相同”的限定，使输入数字可能存在重复，该 Hash仍然可用。只需要将bool hash变成int hash，记录>0的hash[]输出，输出hash[x]个x数字。直到输出达到m个。

##### 2.堆排序

堆排序取出前m大的数，相对于其他排序的完整性，可以只需要O（m*logn）的时间。

- make_heap()生成堆，前两个参数是：开始和结束元素的迭代器。第三个参数可选，可以用less\<type\>()和greater\<type\>()来生成大顶堆和小顶堆。如果只传入前两个参数，默认是生成大顶堆。 
- push_heap()是在堆的基础上进行数据的插入操作。注意只有make_heap（）和push_heap（）同为大顶堆或小顶堆，才能插入。 
- pop_heap()是在堆的基础上，弹出堆顶元素。但删除元素，而是将堆顶元素和数组最后一个元素交换了。【通过vec.back()获取该元素】
- 如果要删除这个元素，还需要对数组进行pop_back()操作。 

#### 练习题

- 谁是你的潜在朋友
- 剩下的树

### 四、排版题

考察对于输出格式的把握。

输出图像的排版题：具有较强的规律性【直接输出】，且该规律顺序往往与输出顺序一致，即可以从上至下、从左至右应用规律。

另一个类排版题，所要求的图形不具有显著的规律性或者规律性较难直接应用到输出当中。则**先完成排版，再进行输出。**

#### while（cin>>）的使用

while(cin>>a>>b)在ctrl+z或者输入值不符合a和b的类型的，会导致while循环退出。

cin不是函数不返回任何东西，它是一个输入流【是一个对象】，应该说>>这个操作符返回什么，返回的是这个流本身，可以这么用cin>> str3 >> str4 >> str5;

因此cin>>a返回的是操作符istream& operator>>(istream&, T &);的返回值，即一个stream。

cin>> str3 返回的流继续用于str4的输入。

```c++
//basic_istream&类型的父类是basic_ios。打开头文件<IOS.H>，找到ios的定义，其中有这么一条语句，类型转换函数的定义：
operator void *() const { 
    if(state&(badbit|failbit) ) //ctrl+z或读入类型错误等。
        return 0;
    return (void this); 
}
```

因此如果读入时发生错误返回0，否则返回cin的地址【非0】。

故能够放入while中判断，是否输入完成。

#### 接收空格用getchar()

getchar()是用来接收一个字符的。 当程序停在*getchar()*时你可以敲击键盘上任何一个asicc码有效按键来发起一个事件进而传递一个字符给该函数。

char c=getchar();

#### 练习题

- repeater【可再练习】

```c++
//观察可知，本题具有递归性质
//关键点在于如何计算stax和stay
#include<iostream>
#include<string.h>
#include<math.h>
using namespace std;
bool pos[10][10];
char style[10][10];
char ans[3005][3005];
int len;
int x,y;
int n;
int stax,stay;
void LevelPrint(int level,bool print,bool bad){
	if(level==1){
		//打印最小单元 
		x=0;
		y=0;
		if(print&&!bad){
			for(int i=0;i<n;i++){
				for(int j=0;j<n;j++){
					ans[stax+x][stay+y]=style[i][j];
					y++;
					if(y==n){
						y=0;
						x++;
					}
				}
			}
		}
		else{
			for(int i=0;i<n;i++){
				for(int j=0;j<n;j++){
					ans[stax+x][stay+y]=' ';
					y++;
					if(y==n){
						y=0;
						x++;
					}
				}
			}
		}
		return;
	}
	int size=(int)pow(n,level-1);
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			stax=stax+i*size;//考虑好这里如何累加初始sta 
			stay=stay+j*size; 
			if(pos[i][j]){
				LevelPrint(level-1,true,bad);
			}
			else{
				LevelPrint(level-1,false,true);
			}
			stax=stax-i*size;
			stay=stay-j*size;
		}
	}
} 
int main(){
	while(cin>>n){
		getchar();
		x=0;
		y=0;
		stax=0;
		stay=0;
		memset(pos,0,sizeof(pos));
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				style[i][j]=getchar();
				if(style[i][j]==' '){
					pos[i][j]=false;
				}
				else
					pos[i][j]=true;
			}
			getchar();
		} 
		int level;
		cin>>level;
		LevelPrint(level,true,false);
		
		len = (int)pow(n,(double)level);
		for(int i=0;i<len;i++){
			for(int j=0;j<len;j++){
				cout<<ans[i][j];
			}
			cout<<endl;
		}
		
		
	} 	
	return 0;
} 
//https://www.cnblogs.com/liangrx06/p/5083866.html【参考】 
```

### 五、查找

#### 二分查找

线性查找O（n）->二分查找O（logn）【**必须在有序的基础上**】

```c++
//闭区间
int BinarySearch(int L[],int target,int left,int right)
	{	int left=0;int right=numsSize-1;
	    while(right>=left)
	    {
	        int mid = left + (right - left)/2;
	        if(L[mid]==target)
	            return mid;
	        else if (L[mid]<target) 
	        {
	            left = mid+1;
	        }
	        else
	        {
	            right = mid-1;
	        }
	        return TARGET_NOT_FOUND;
	        
	    }
	}
```

##### 注意的细节

(1) 数据范围:整数的范围为-2^31~2^31-1,二分查找在求中间位置时，如**果使用int mid = (left+right)/2的形式，则对于较大的left和right，有可能向加后超过整型的表示范围，得到错误的计算结果**，因此<u>应使用int mid = left + (right - left)/2的形式。</u>

(2) 边界条件:边界确定涉及二分查找算法中的判断和赋值，**边界必须遵循一致的区间规则**，序列及其子序列的mid和right都要表示统一的开闭区间。

在查找某特定元素是否存在以外，<u>二分查找还有另一类非常重要的运用，即**定界**。</u>思考如下问题，<u>在一个升序有序的数组中，确定一个下标点，使在这个下 标点之前（包括该下标点）的数字均小于等于目标数字（该目标数字一定大于等 于数组中最小的数字），而数组的其余部分均大于目标数字</u>

### 六、贪心

一种总是**选择“当前最好的选择”而不从整体上去把握**的思想。但往往这种“贪心”的策略能得到接近最优的结果。

#### 判断浮点数是否为0

float，double分别遵循R32-24,R64-53的标准，他们的位数分别是23,52；即误差在2^-23,2^-52；所以float的精度误差在1e-6；double精度误差在1e-15 
所以

- 要判断一个单精度浮点数：则是**if(fabs(f) <= 1e-6)；**
- 要判断一个双精度浮点数：则是**if(fabs(f) <= 1e-15 )；**

float小数点后面有效数字为6~7位和double小数点后面有效数字为15~16位。

#### 贪心证明

部分背包：

贪心思想：我们每次都尽可能的多买性价比高 的物品直到该物品被买完或者金钱耗尽。那么，这样朴素的贪心策略是否能真正 获得最优解呢？

我们需要自己动手证明一下： <u>按照我们的策略，最后所买的物品一定符合如下条件：在最优解中，如果存在性价比为a的物品，那么原物品中性价比高于a的物品一定全部被我们买下来</u>。

要证明该命题，我们不妨**假设**该解并不是最优解。**即存在，性价比为b（>a） 的物品，仍然剩余一部分没有被我们买入，但是我们却获得了最优解。**那么在该 解的基础上，我们退<u>掉部分性价比为 a 物品（哪怕一点点），而将这些钱都用来 买性价比为b的物品</u>。

但是因为性价比b > a， 我们用同样的金钱所买的性价比为b的物品的重量一定大于性价比为a的物品。 那么，完成该一卖一买后，总重量有所增加。<u>原解一定不是最优解，我们的假设不成立</u>。命题“最优解中，如果存在性价比为a的物品，那么原物品中性价比高于a的物品一定全部被我们买下来”成立。

这样我们就证明了，这种贪心的策略能够得到最优解。 

#### 练习题

- 迷瘴

  - 要让浓度不超过W，那么就是浓度越低越好
  - 保证解药的浓度最低，则需要从小的开始选择【所谓贪心，大多需要排序。】
  - 直到选择到混合浓度超过解药浓度时，截止【题目要求，只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）】
  - 注意：while(ndl/(100*(k+1))<=w&&**k<snum**)
  - 除法一定要注意除以0的情况，可能出现nan。因此要判断分母!=0。
  - 不同液体的混合密度就是各个液体密度和/不同液体数，eg:nd1+nd2+nd3/3\*v
    - 因此是 ndl/(100*k)<=w
    - 但是**除法损失精度【但是乘法不会】**，因此要移项，修改为 ndl<=w\*(100*k)
    - 还要注意输出k*v是中的药水体积，加了k罐水；但是总浓度不是ndl/(k\*v)，而是ndl/(100\*k)。浓度与体积无关，a浓度的药，倒了一半还是a浓度。
    - 总浓度就是浓度和/瓶数

  ```c++
  #include<iostream>
  #include<algorithm>
  using namespace std;
  int snum;
  int v;
  double w;
  //不同液体的混合密度就是各个液体密度和/不同液体数
  //eg:nd1+nd2+nd3/3*v
  //因此是 ndl/(100*k)<=w
  //但是除法损失精度，因此要一项 
  //对于给出体积为20，浓度为30。不是说20体积里面有30量的药物成分，而是100体积里面有30量的药物成分【因为是30%】
  //也就是20体积里面只有20*30%=20*0.3=6量的药 
  int main(){
  	int cases;
  	cin>>cases;
  	while(cases--){
  		cin>>snum>>v>>w;
  		int s[snum+2]; 
  		for(int i=0;i<snum;i++){
  			cin>>s[i];
  		}	
  		sort(s,s+snum);
  		if(s[0]>w){
  			printf("0 0.00\n");
  			continue;
  		}
  		int ndl=0; 
  		//int ndv=0;
  		int k=0; 
  		for(k=0;k<snum;k++){ 
  			ndl+=s[k];
  			//ndv+=v;
  			if(ndl>w*(k+1)){ //上面除/100，现在又*100，其实可以改为ndl<=w*(k+1)，也就是浓度和平均
  				//cout<<k<<endl;
  				ndl-=s[k]; 
  				break;
  			}	
  		}
  		printf("%d %0.2lf\n",k*v,(double)ndl/(100*k));//千万注意浓度和不等于ndl/k*v 
  	}
  	
  	return 0;
  }
  ```

- Repair the wall

  - 要求修补的block最少，那么只要选择尽量长的块切割修补就可以了【也是排序】
  - while(crack>b[k]&&**k<bnum**)
  - 退出while时判断【注意多种退出情况】
    - crack>0&&k<bnum——ans++
    - crack>0&&k==bnum？——无解
    - crack==0——ans

- To fill or not to fill

  - **如何贪心——一个难题。从测试数据入手，思考贪心策略【不要嫌麻烦】**

  - 分析：很明显，这道题的思路是贪心，也就是要用尽可能少的钱，要去尽可能远的地方。那么，像这种贪心的题目，怎么去思考呢？
    对于贪心的题目，测试样例，必须自己去体会一遍，这样，很有可能会给我们带来不少启发。那么，我们就一起来过一遍测试样例吧：
                
    Sample Input 1:
    50 1300 12 8
    6.00 1250
    7.00 600
    7.00 150
    7.10 0
    7.20 200
    7.50 400
    7.30 1000
    6.85 300

    Sample Output 1:
    749.17

    - 先画个图再看

      ![](C:\Users\asus\spidermana.github.io\assets\img\tx.jpg)

    - 对于当前站点S，所能到达的最大范围即满油量所能到达的距离，设满油量能前进的距离为maxToGo，则在S到S+maxToGo=S+600范围内。

    - 1：起点，肯定是要加油的，不然跑都跑不起来，那么，问题来了——加多少？
      让我们先来观察一下，油箱加满之后，最远能跑600；也就是说，如果我现在在起点把油箱加满的话，[0,600]都是我可以达到的路程范围；好了，那么，我们只需要看这个范围内的如何做出贪心策略；

    - 起点处的油价是7.1，如果之后遇到的第一个加油站A油价小于7.1，那么，在A之后不管是什么情况，我们都应该加油（至于要加多少，还不能确定），
      因为至少在当前状态下，这样做是最“贪婪”的。

    - 2：通过1的分析，我们选择了加油站B。而且值得强调的是，我们在起点A加的油跑到B时是正好用完的状态。这时，我们站在了B点，B点最远能到750(150+600），我们又如何根据贪心算法来做出贪婪的决策呢？B处的油价是7，显然，750之前的加油站有很多，油价有比7小的，比7大的，也有等于7的。那么，贪婪的你，一定不会傻到去选择一个油价贵的（如C、E）因为我完全可以到达比7小的加油站再加油，为什么要去比7大的加油站加油呢？so，我们选择了D（油价6.85），而且，D的油价比当前的便宜，所以我们加油只要够从B——>D就好，加多了就不符合我贪婪的本性了！

    - 3：到了D之后，可以说是比较开心的，因为在他[300,300+600]的范围内这价是最便宜的，此时不加更待何时！？因为是最便宜的，所以，为了贪，必须加满！
      加满了之后，最远可以到900（300+600），那么，在900之前，我们会遇到E、F，且F油价较E要便宜一些，因此，为了到达目的地，我们不得不到F加油。

    - 4：和之前的情况有所不同的是，这次，我们到目的地的时候，还是有油剩余的（600-300<600），而且剩余的油够跑300（即可以跑到900）。
      那么，我们在F加多少的油呢？
      站在F的位置，我们开始思考。距离400有一个加油站G，可是油价要7.3，坑爹呢！这么贵！
      可是，就算F加满了，我们也只能跑到1200（600+600），所以，没办法，为了到达目的地，我们不得不到G加，但是，这里要注意，因为G比F的油价要贵，
      所以，为了贪，我们会在F把油加满，（在能够达到目的地的前提下，尽可能在贵的地方少加点油，在便宜的地方多加点油——贪）；

    - 5：到了G之后，计算了此时邮箱还剩下的油够跑200，也就是说，我们在贵的的地方G只需要加50（1250-1000-200），能到H即可，因为H的油价是最便宜（没有之一），
      在[1000,1000+600]的范围内，是最便宜的，so，就这样走到了H

    - 6：走到了H之后，就不用多想了，H之后也没有加油站了，而且加满能够到目的地I的油量就够了。

  - ☆：经过了以上分析之后，要开始对以上的各个情况进行抽象，<u>即把遇到的情况分类（要包括所有的情况），并且，基于贪心的思想去考虑不同的情况下，做出何种决策：</u>

    - 情况1：600米范围内，有目的地——计算恰好能到目的地的油量【6】                                                       

    - 情况2：600米范围内没有加油站，无论油价多贵——加满——能跑多远算多远 【这种情况应该是到不了终点的情况，即有两个加油站的距离大于600；依据题意输出：maximum possible distance the car can run。】                                              

    - 情况3：600米范围内有加油站：

      - a:有比当前加油站的油价更便宜的加油站——加到恰好能到那个**最近的**油站的油量【1】【2】【5】（注：1、如果有多个便宜的，还是要<u>先选取最近的那个，而不是最便宜的那个</u>；【那么再下n轮贪心时会慢慢走到最便宜的那个，但是省下来一开始的贵的邮费】2、可能还有油剩余）

      - b:没有比当前加油站的油价更便宜的加油站——加满，然后在600范围内找到**最便宜**的加油站加油 【3】【4】

        注意这里不是找最远的加油站，如果最远的点是贵中最便宜的固然好。但是如果不是，我还是当前先贪心吧，这样我可以走更远的距离【说不定能遇到便宜的点】。如果走更远的距离没有碰到便宜的点，那么我又会进行情况3的b规则。每次找最便宜的点【肯定最优】，走的更远。

    再来看第二组数据：
    Sample Input 2:
    50 1300 12 2
    7.10 0
    7.00 600

    Sample Output 2:
    The maximum travel distance = 1200.00

  - 分析过程：

    - 1：600的范围内（包括600），有加油站，而且比当前的油价要便宜，因此，属于情况3—a，故，我们加到恰好能到，这里比较特殊的是，只有加满才恰好能到。
    - 2：600范围内，没有加油站，这里属于情况2，能跑多远跑多远，因为已经无法到达目的地了，只能尽可能地跑更远

  - 经过以上的分析，就可以开始尝试地写代码了。注意特殊情况处理：

    - 起点没有加油站
    - 起点即终点

  ```c++
  #include<iostream>
  #include<algorithm>
  using namespace std;
  int cmax;
  int totd;
  int avgdis;
  int n;
  int MaxToGo;
  //https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=63&&tqId=29602&rp=1&ru=/activity/oj&qru=/ta/zju-kaoyan/question-ranking 
  struct Station{
  	double pri;
  	int dis;
  	Station(){}
  	Station(double pp,int dd){
  		pri=pp;
  		dis=dd;
  	}
  };
  bool cmp1(Station a,Station b){
  	if(a.dis<b.dis)
  		return true;
  	else if(a.dis==b.dis){ 
  		return a.pri<b.pri;//否则会出现同距离下，更贵的进入flags 
  	} 
  	else
  		return false; 
  }
  Station st[505];
  //the cheapest price，accurate up to 2 decimal places. 
  //If it is impossible ，print "The maximum travel distance = X" 
  //where X is the maximum possible distance the car can run, accurate up to 2 decimal places.
  int main(){
  	while(cin>>cmax>>totd>>avgdis>>n){
  		for(int i=0;i<n;i++){
  			cin>>st[i].pri>>st[i].dis;
  		}
  		MaxToGo=avgdis*cmax;
  		sort(st,st+n,cmp1);
  		int nowdis=0;
  		int nowind=0;
  		double price=0;
  		double nowpri=st[0].pri; 
  		double nowoil=0; 
  		while(nowdis<=totd){
  			int sind;
  			bool flags=false;
  			int cind;
  			bool flagc=false; 
  			double cpri=1<<30; 
  			for(int i=nowind+1;i<n;i++){
  				if(st[i].dis>nowdis&&st[i].dis<=nowdis+MaxToGo){
  					//cout<<"ok i="<<i<<endl;
  					if(st[i].pri<nowpri){
  						flags=true;//比当前便宜又最近 
  						sind=i;
  						break;
  					}
  					else{
  						//cout<<"flagc condition="<<st[i].pri<<" "<<cpri<<endl; 
  						if(st[i].pri<cpri){
  							flagc=true;
  							cind=i;
  							cpri=st[i].pri;
  							//cout<<cpri<<" "<<i<<endl;
  						}
  					}
  				}
  			}
  			if(flags){//肯定是还没有到终点的，还能减少再到终点 
  				//cout<<"flags "<<sind<<endl;
  				if(nowoil==0)
  					price+=nowpri*((double)(st[sind].dis-nowdis))/avgdis;
  				else{
  					double need = ((double)(st[sind].dis-nowdis))/avgdis;
  					if(need>nowoil){
  						price+=((double)(need-nowoil))*nowpri;
  						nowoil=0;
  					} 
  					else{
  						nowoil-=need;
  					}
  				}
  				nowdis=st[sind].dis;
  				nowpri=st[sind].pri;
  				nowind=sind;
  			}
  			else if(flagc){//可能直接开到终点
  				//cout<<"flagc "<<cind<<endl;
  				if(nowdis+MaxToGo>=totd){//直接到终点 
  					if(nowoil==0){
  						price+=nowpri*(double)(totd-nowdis)/avgdis;
  						printf("%.2lf\n",price); 
  						break;
  					}
  					else{
  						double need=(double)(totd-nowdis)/avgdis;
  						if(need>nowoil)
  							price+=nowpri*((double)(need-nowoil))*nowpri;
  						else
  							price-=((double)(nowoil-need))*nowpri;
  						printf("%.2lf\n",price); 
  						break;
  					}
  				} 
  				if(nowoil==0){
  					//cout<<"oil=0"<<endl;
  					price+=nowpri*(double)cmax;
  					nowoil=(double)cmax-(((double)(st[cind].dis-nowdis))/avgdis);
  				}
  				else{
  					//cout<<"oil="<<nowoil<<endl;
  					price+=nowpri*((double)(cmax-nowoil));
  					nowoil=(double)cmax-(((double)(st[cind].dis-nowdis))/avgdis);
  				}
  				nowdis=st[cind].dis;
  				nowpri=st[cind].pri;
  				nowind=cind;
  			}
  			else{//maxtogo内没有加油站 
  				//cout<<"no station "<<endl;
  				if(nowdis+MaxToGo<totd){
  					//cout<<"oil="<<nowoil<<endl;
  					price+=nowpri*(double)(cmax-nowoil);
  					printf("The maximum travel distance = %.2lf\n",(double)nowdis+MaxToGo); 
  					break;
  				} 
  				else{
  					if(nowoil==0)
  						price+=((double)(totd-nowdis)/avgdis)*nowpri;
  					else{
  						double need=(double)(totd-nowdis)/avgdis;
  						if(need>nowoil){
  							price+=((double)(need-nowoil))*nowpri;
  						}
  					}	
  					printf("%.2lf\n",price); 
  					break;
  				}
  			}
  		}
  	}
  	return 0;
  }
  ```

#### 浮点数的向下/上取整、四舍五入

>                                                            ​                                                                 2.1             2.6              -2.1              -2.6
>                                                            floor : 不大于自变量的最大整数             2                2                  -3                  -3
>                                                            ceil   :不小于自变量的最大整数              3                3                  -2                  -2
>                                                            round:四舍五入到最邻近的整数             2                3                  -2                  -3

**floor(),ceil() 需包含头文件<math.h>**

**C++中没有直接的round函数 需自己建立**【整数部分，四舍五入】
double round(double r)
{
    return (r > 0.0) ? floor(r + 0.5) : ceil(r - 0.5);
}  

但是对于小数部分，输入时指定“%.2lf”，一般会自动四舍五入，保留两位小数。



## 高校专题

清华大学：https://www.nowcoder.com/ta/tsing-kaoyan

北京大学：https://www.nowcoder.com/ta/pku-kaoyan

浙江大学：https://www.nowcoder.com/ta/zju-kaoyan

上海交通大学：https://www.nowcoder.com/ta/sju-kaoyan