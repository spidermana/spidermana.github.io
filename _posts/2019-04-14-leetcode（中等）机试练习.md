---
title: leetcode和POJ机试练习
date: 2019-04-14
tags: 算法
---

## Leetcode

### Add Two Numbers

#### 一、题意

利用sscanf和sprintf进行字符串处理，计算加法，得到结果。

再按照要求输出

#### 二、知识点

##### ①sscanf：按格式拆分字符

> int sscanf(const char *str, const char *format, ...)
>
> str：待处理字符串
>
> format:格式化方式
>
> ……：处理后存储的变量
>
> 处理str，把匹配format中(%……）依次放到后面的变量中

```c++
//示例1
int day, year;
char weekday[20], month[20], dtm[100];

strcpy( dtm, "Saturday March 25 1989" );
sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );//注意&

printf("%s %d, %d = %s\n", month, day, year, weekday );
//March 25, 1989 = Saturday

//示例2
sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);
printf("%s/n", buf);
//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串
//先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中
//%*[^/]:贪婪匹配，直到到遇到一个/，*丢弃【/没有被匹配】
// /:匹配一个/
//%[^@]:从/后匹配到@之前，保留存储到buf中
```

format的用法：format 说明符形式为 **[=%[*]\[width][modifiers]type=]**

sscanf与scanf类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。
其中的**format**可以是一个或多个 {%[*] [width] [{h | l | I64 | L}] type | ' ' | '/t' | '/n' | 非%符号}。

1、* 亦可用于格式中, (即 %\*d 和 %\*s) **加了星号 (\*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)**
2、{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。
3、width表示读取宽度。
4、{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。
5、type :这就很多了，就是%s,%d之类。
6、特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值
支持集合操作：
7、%[a-z] 表示匹配a到z中任意字符，**贪婪模式**(尽可能多的匹配)
8、%[aB'] 匹配a、B、'中一员，贪婪模式
9、%\[**^**a] 匹配**非a**的任意字符，贪婪模式

##### ②sprintf：按格式拼接字符串

> int sprintf(char *str, const char *format, ...)
>
> format 标签属性是 **%[flags]\[width]\[.precision][length]specifier**

```c++
//示例
char str[80];
sprintf(str, "Pi 的值 = %f", M_PI);
puts(str);
//Pi 的值 = 3.141593
```

参考：[format各部分说明详解](http://www.runoob.com/cprogramming/c-function-sprintf.html)

##### ③str.erase（staind，len）

```c++
// 从位置pos=10处开始删除，直到结尾
str.erase(10);
//从位置pos=6处开始，删除4个字符
str.erase(6, 4);
//删除迭代器[first, last)区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.
str.erase(str.begin() + 10, str.end());
//erase后str本身存储了删除的结果，不需要重复赋值
```

注：void pop_back();方法也可以用来删除元素, 但是只能删除string的最后一个元素

##### ④getline(cin,str)

可以用于输入带有空格的字符，默认定界符为回车，<u>该定界符既不被放回输入流，也不被放入要生成的字符串。</u>

从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束。1）到文件结束，2）遇到函数的定界符，3）输入达到最大限度。

- 返回：成功->返回读取的字节数。失败->返回-1。
- 参数：getline (istream& is, string& str, char delim);、输入流、存储的str、定界符

#### 三、代码

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
int main(){
	string str;
	char str1[50],str2[50];
	getline(cin,str);
	int len=str.length();
	for(int i=0;i<len;i++){
		if(str[i]==' ')
			str.erase(i,1);
	}
	//cout<<str<<endl;
	sscanf(str.data(),"(%[^+)])+(%[^+)])",str1,str2);
	//cout<<str1<<endl;
	//cout<<str2<<endl;
	int len1=strlen(str1);
	int len2=strlen(str2);
	int sum1=0;
	int sum2=0;
	for(int i=len1-1;i>=0;i=i-3){
		sum1=sum1*10;
		sum1+=(str1[i]-'0');
	}
	for(int i=len2-1;i>=0;i=i-3){
		sum2=sum2*10;
		sum2+=(str2[i]-'0');
	}
	//cout<<sum1<<" "<<sum2<<" "<<sum1+sum2<<endl; 
	int totsum=sum1+sum2;
	int flag=false;
	while(totsum!=0){
		if(!flag){
			flag=true;
		}
		else{
			cout<<" -> ";
		}
		cout<<totsum%10;
		totsum=totsum/10;
	}
	cout<<endl;
	
	return 0;
}
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public://形成和的链表
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1==NULL and l2==NULL)
            return NULL;
        else if(l1==NULL)
            return l2;
        else if(l2==NULL)
            return l1;
        int a= l1->val+l2->val;
        ListNode *ans = new ListNode(a%10);
        ans->next = addTwoNumbers(l1->next,l2->next);
        if(a>=10)//如果l1和l2当前位的和，需要进位，则更新ans->next，要多加上一个1
            ans->next = addTwoNumbers(ans->next,new ListNode(1));
        return ans;
    }
};
```

### Longest Substring Without Repeating Characters

求最长非重复子串【longest substring 】，不是子序列【subsequence 】，因此要求连续。

- 一种方法直接暴力枚举区间[i,j]
- 另外一种是使用滑动区间
  - 维护一个滑动窗口，窗口内的都是没有重复的字符，尽可能扩大窗口的大小，窗口的大小就是非重复子串。
  - 窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界
  - 当前遍历到的字符从未出现过，right++
  - 如果之前出现过，那么就分两种情况，在或不在滑动窗口内。
    - 如果不在滑动窗口内，那么就没事，当前字符可以加进来
    - 如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，移动left指针到该重复字符最后出现的位置。
  - 维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int m[256] = {0}, res = 0, left = 0;
        //建立一个256位大小的整型数组来代替HashMap，ASCII表共能表示256个字符,s[i]的取值在0-255
        //但是由于键盘只能表示128个字符，所以用128也行,
        for (int i = 0; i < s.size(); ++i) {
            if (m[s[i]] == 0 || m[s[i]] < left) {//没有出现过或者在左边界以左
                res = max(res, i - left + 1);
            } else {
                left = m[s[i]];//字符出现过，移动左边界到出现过的位置
            }
            m[s[i]] = i + 1;
        }
        return res;
    }
};
```

###  Longest Palindromic Substring

注意对于可删除原串字符形成的回文子串的这类题目，可以通过串S和逆序串S'的最长公共子序列来求解。

对于本题，不可过串S和逆序串S'的最长公共子串来求解最长回文串。比如以下示例

> Let’s try another example: S*S* = "abacdfgdcaba", S'*S*′ = "abacdgfdcaba".
>
> The longest common substring between S*S* and S'*S*′ is "abacd". Clearly, this is not a valid palindrome.

我们给出 P(i,j)的定义如下：
$$
P(i,j) = \begin{cases} \text{true,} &\quad\text{如果子串} S_i \dots S_j \text{是回文子串}\\ \text{false,} &\quad\text{其它情况} \end{cases}
$$
因此，
$$
P(i, j) = ( P(i+1, j-1) \text{ and } S_i == S_j )
$$
首先初始化一字母和二字母的回文:
$$
P(i, i) = true  \\
P(i, i+1) = ( S_i == S_{i+1} )
$$
然后通过直观的动态规划解法，然后找到所有三字母回文，并依此类推…

**复杂度分析**

- 时间复杂度：O(n^2)， 这里给出我们的运行时间复杂度为 O(n^2) 。
- 空间复杂度：O(n^2)， 该方法使用 O(n^2)的空间来存储表。

```c++
class Solution {
public:
        string longestPalindrome(string s) {
            int len=s.length();
            bool **dp = new bool *[len+1];
            for(int i=0;i<=len;i++){
                dp[i]=new bool [len+1];
            }
            for(int i=0;i<len;i++){
            	for(int j=0;j<len;j++){
            		dp[i][j]=0;
				}
			}
			int left=0,anslen=1;
            for(int i=0;i<len;i++){
                dp[i][i]=1;
                if(i+1<len){
                	dp[i][i+1]=(s[i]==s[i+1]? 1:0);
                	if(dp[i][i+1]){
                        anslen=2;
                        left=i;
                	}
				}
            }
            for(int k=2;k<len;k++){
                for(int i=0;i+k<len;i++){
                    dp[i][i+k]=dp[i+1][i+k-1]&&(s[i]==s[i+k]);
                    if(dp[i][i+k]&&k+1>anslen){
                        anslen=k+1;
                        left=i;
                    }
                }
            }
            return s.substr(left,anslen);
            
        }
};
```

### ZigZag Conversion

就是简单的字符串处理

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        string ans="";
        int len=s.length();
        if(numRows==1)//numRows=1要特殊处理 
        	return s;
        for(int h=0;h<numRows;h++){
        	int i;
            //如果是numRows=1， i=i+2*numRows-2会变成i=i，因此不可行，死循环了 
            for(i=h;i<len;i=i+2*numRows-2){
                if(i!=h&&h!=0&&h!=numRows-1){
                    ans+=s[i-h*2];
                    cout<<"now="<<s[i-h*2]<<endl;
                }
                cout<<"h="<<h<<" char="<<s[i]<<endl;
                ans+=s[i];
            }
            if(h!=0&&h!=numRows-1&&i-h*2<len){
                ans+=s[i-h*2];
                cout<<"now="<<s[i-h*2]<<endl;
            }
        }
        return ans;
        
    }
};
//参考答案
class Solution {
public:
    string convert(string s, int numRows) {

        if (numRows == 1) return s;

        vector<string> rows(min(numRows, int(s.size())));//构造了min(numRows, int(s.size()))个元素，初始化为0/“”
		//每个元素是一个string，有多个string。每个string存储锯齿模式下的一行 
        int curRow = 0;
        bool goingDown = false;

        for (char c : s) {//顺序遍历s 
            rows[curRow] += c;//对这个string元素+char 
            //以下模拟了锯齿的路径，true表示行好增加【goingDown=true】，false表示行号减少
            //在行0和行尾，增加方向更改【1->-1、-1->1】 
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        string ret;
        for (string row : rows) //遍历vector的每个元素 
			ret += row;//每个元素=某行【string】 ，累加 
        return ret;
    }
};
```

### String to Integer (atoi)

模拟atoi，就是简单的字符串处理，要注意多种情况。

由于数据可能超过int上限，因此要使用long long int 存储结果。

在累加的过程中如果超过INT_MAX或INT_MIN就判断直接返回对应界限，否则一直累加下去可能会超过long long int的上限。

- 注意INT_MAX+5：得到的是负数【越过上界了，模运算回到负界限】

```c++
class Solution {
public:
    int myAtoi(string str) {
        long long int num=0;
        int len=str.length();
        int i;
        for(i=0;i<len;i++){
        	if(str[i]!=' ')
        		break;
		}
		if(i==len||!(str[i]=='+'||str[i]=='-'||(str[i]>='0'&&str[i]<='9'))){
			return 0;
		}
		bool minus=false;//默认不带负号，也就是一个数没有符号，我们是认为其为正数 
		if(str[i]=='+'||str[i]=='-'){
			minus=str[i]=='+'? 0:1;
			i++;
		}
		//cout<<"dasd"<<endl; 
		int sta=i;
		for(int j=sta;j<len;j++){
			if(str[j]>='0'&&str[j]<='9'){
				num*=10;
				num+=str[j]-'0';
				long long int temp=minus? -num:num;
                if(temp>INT_MAX||temp<INT_MIN){
                    return minus? INT_MIN:INT_MAX;
                }
                //cout<<num<<endl;
			}
			else{
				num=minus? -num:num;
				if(num>INT_MAX){
					return INT_MAX; 
				}
				else if(num<INT_MIN){
					return INT_MIN;
				} 
				else{
					return num;
				}
			}
		}
		//如果字符串只有一个符号，那么去掉符号后，已经遍历到字符串尽头,这种情况num保持0
		//或者全是数组，完全转化正常也返回num 
		num=minus? -num:num;
		if(num>INT_MAX){
			return INT_MAX; 
		}
		else if(num<INT_MIN){
			return INT_MIN;
		} 
		else{
			return num;
		}
    }
};
```

### Container With Most Water

可以暴力模拟，或两点逼近优化

1. 两个柱子之间可以装下的最大水量取决于更小柱子
2. 设置两个指针P1,P2，初始化位于头和尾，朝内逼近。
3. 将指向较小柱子的指针向内移动，指向较大柱子的指针不动
4. 这样才可能试探到更大的面积【朝内移动时，宽度减少了，但是指向较小柱子的指针向内移动，可能会找到比此前较大柱子更高的柱子，使得此时的高度minheight=（P1_height,P2_height）更高】
5. 相反如果移动较大柱子的指针，不仅宽度变小了，还使得高度不能更高【肯定比之前较小柱子更小】

```c++
//暴力枚举柱子O(n^2)
class Solution {
public:
    int maxArea(vector<int>& height) {
    	int size=height.size();
    	int maxSquare=0;
        for(int i=0;i<size;i++){
        	for(int j=i+1;j<size;j++){
				int Minh = min(height[i],height[j]);
				maxSquare = max(maxSquare,(j-i)*Minh);
			} 
		} 
		return maxSquare;
    }
};
//两点逼近优化O(n)
class Solution {
public:
    int maxArea(vector<int>& height) {
    	int size=height.size();
    	int maxSquare=0;
        int l=0,r=size-1;
        int minh=0;
        while(l<r){
            int width=r-l;
            if(height[l]<height[r]){
                minh=height[l];
                l++;
            }
            else{
                minh=height[r];
                r--;
            }
            maxSquare=max(maxSquare,minh*width);
        }
        return maxSquare;
    }
};
```

### Integer to Roman

模拟题，从大到小范围进行判断处理，先把大的罗马数减去，存储罗马字符到ans中，直到数字为0

```c++
class Solution {
public:
	string GetChar(int &num){
		if(num>=1000){
			num=num-1000;
			return "M";
		}
		else if(num>=900){
			num-=900;
			return "CM";
		}
		else if(num>=500){
			num-=500;
			return "D";
		}
		else if(num>=400){
			num-=400;
			return "CD";
		}
		else if(num>=100){
			num-=100;
			return "C";
		}
		else if(num>=90){
			num=num-90;
			return "XC";
		}
		else if(num>=50){
			num-=50;
			return "L";
		}
		else if(num>=40){
			num-=40;
			return "XL";
		}
		else if(num>=10){
			num-=10;
			return "X";
		}
		else if(num>=9){
			num-=9;
			return "IX";
		}
		else if(num>=5){
			num-=5;
			return "V";
		}
		else if(num>=4){
			num-=4;
			return "IV";
		}else{
			num-=1;
			return "I";
		}
	}
    string intToRoman(int num) {
        string ans="";
        while(num!=0){
        	ans+=GetChar(num);
		}
		return ans;
    }
};
```

## POJ

### poj 1037——dp及排序计数

POJ 1037 一个可爱的栅栏
 N 个木棒, 长度分别为1, 2, …, N。

想要构成可爱的栅栏，要满足：除了两端的木棒外，每一跟木棒，要么比它左右的两根都长，要么比它左右的两根都短。即木棒排列上呈现波浪状分布。

问题: 符合上述条件的栅栏建法有很多种，对于满足条件的所有栅栏, 按照字典序(从左到
右, 从低到高) 排序。根据排序，从1起标号。
给定一个栅栏的排序号，请输出该栅栏样式, 即每一个木棒的长度。

##### 1.排序计数

从最高位开始尝试，依次升序尝试各个数，累加排列数，直到当前累加排列数超过所求第x个排列，则确定当前位。而后再遍历下一个位，进行尝试。

用一个例子说明。 如1，2，3，4的全排列，共有4！种，求第10个的排列是（从1计
起）？

- 先试首位是1，后234有3！=6种<10，说明首位1偏小，问题转换成
  求2开头的第（10-6=4）个排列【还差10-6=4个排列】，而3！=6 >= 4，说明首位恰是2。
- 第二位先试1（1没用过），后面2！=2个<4，1偏小，待求序号也再减去2！，剩下4-2=2了。换成3（**2用过**
  **了**）为第二位。而此时2!>=2，说明第二位恰好是3。
- 第三位先试1，但后面1！<2，因此改用4。末位则是1了。
- 这样得出，第10个排列是2-3-4-1。

##### 2.本题dp思路

首先考虑一维，设 C[i] 为前i根木棒所组成的合法方案数目。看看能否找出C[i]和C[i-1]
或C[i-j]之间的递推关系。

但是在选定了某根木棒x作为第一根木棒的情况下,剩下i-1根木棒的合法
方案数是A[i-1]。但是，这A[i-1]种方案，并不是每种都能和x形成新的
合法方案【构成i根木棒】。因此A[i]和A[i-1]并不能直接递推。

那么就要增加状态。

要从i-1根木棒推出i根木棒组成的栅栏。肯定要考虑x【新增的这根】作为第一根木棒后面加上i-1根木棒能否符合题目要求。

这就要考虑x木板和i-1根木板的第一根【记为y】的长度关系。如果x>y，那么也不一定能合理，必须y开头的i-1根木板是先升序的。如果x<y，那么合理排序要求y开头的i-1根木板是先降序的。

![dp状态图](C:\Users\asus\spidermana.github.io\assets\img\poj1.png)

满足了以上两个条件【确定x和y的长度相对关系以及y开头的i-1根木板的开头顺序】，才可以由i-1状态递推到i状态。

因此应该是一个3维dp问题。以上分析给出了从1维慢慢走到3维的过程。

`C[i][k][DOWN]`是i根木棒的合法方案中以第k短的木棒打头的DOWN方案数【第k短
，指的是i根木棒中第k短。】。然后试图对C进行动归：
`C[i][k][UP]` = `∑ C[i-1][M][DOWN]` （M = k ... i -1）

- 对于i根木板：第一根木板k<M，是up状态【先升序】，后面再降序
- 第一维i指示了前i根木板
- 第二维k指示了第一根木板的相对长度【要遍历i根中，谁作为第一根】
- 第三位up/down指示了开头的升/降序情况

`C[i][k][DOWN]` = ∑ `C[i-1][N][UP]` （N = 1… k-1）

总方案数是 Sum{ `C[n][k][DOWN]` + `C[n][k][UP]` } k = 1.. n;

初始条件：`C[1][1][UP]`=`C[1][1][DOWN]` = 1

##### 3.代码

```c++
//POJ1037 A decorative fence by Guo Wei
#include <iostream>
#include <algorithm>
#include <cstring>
#include<cstdio>
 
using namespace std;
const int UP =0;
const int DOWN =1;
const int MAXN = 25;
long long C[MAXN][MAXN][2]; //C[i][k][DOWN] 是S(i)中以第k短的木棒打头的DOWN方案数,C[i][k][UP] 是S(i)中以第k短的木棒打头的UP方案数,第k短指i根中第k短
void Init(int n)
{
    memset(C,0,sizeof(C));
    C[1][1][UP] = C[1][1][DOWN] = 1;
    for( int i = 2 ; i <= n; ++ i )
        for( int k = 1; k <= i; ++ k )   //枚举第一根木棒的长度
        {
            for( int M = k; M <i ; ++M ) //枚举第二根木棒的长度
                C[i][k][UP] += C[i-1][M][DOWN];
            for( int N = 1; N <= k-1; ++N ) //枚举第二根木棒的长度
                C[i][k][DOWN] += C[i-1][N][UP];
        }
//总方案数是 Sum{ C[n][k][DOWN] + C[n][k][UP] } k = 1.. n;
}
void Print(int n, long long cc)
{
    long long skipped = 0; //已经跳过的方案数
    int seq[MAXN]; //最终要输出的答案
    int used[MAXN]; //木棒是否用过
    memset(used,0,sizeof(used));
    for( int i = 1; i<= n; ++ i )   //依次确定每一个位置i的木棒序号
    {
        long long oldVal = skipped;
        int k;
        int No = 0; //k是剩下的木棒里的第No短的,No从1开始算
        for( k = 1; k <= n; ++k )   //枚举位置i的木棒 ，其长度为k
        {
            oldVal = skipped;//存储还没有加上k时的skipped，如果加上k的方案数超了，说明第i个位置为k
            if( !used[k])
            {
                //固定后面是k打头了，要计算k是第几短的 
                ++ No; //k是剩下的木棒里的第No短的。没有使用中第几短的 
                if( i == 1 )//如果是第一个位置，那么up或者down都可以
                    skipped += C[n][No][UP] + C[n][No][DOWN];
                else
                {
                    //当前考虑的k，必须是加在已摆放的序列后合法的
                    //确定k位置后，其后方可能序列为摆放n-i+1个木板，以no短开头的序列数
                    if( k > seq[i-1] && ( i <=2 || seq[i-2]>seq[i-1]))//合法放置
                        skipped += C[n-i+1][No][DOWN];
                    else if( k < seq[i-1] &&(i<=2 || seq[i-2]<seq[i-1])) //合法放置
                        skipped += C[n-i+1][No][UP];
                }
                if( skipped >= cc )
                    break;
            }
        }
        used[k] = true;
        seq[i] = k;
        skipped = oldVal;//保存旧的skipped，即oldval
    }
    for( int i = 1; i <= n; ++i )
        if( i < n) printf("%d ",seq[i]);
        else
            printf("%d",seq[i]);
    printf("\n");
}
int main()
{
    int T,n;
    long long c;
    Init(20);
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %lld",&n,&c);
        Print(n,c);
    }
    return 0;
}
```

### POJ 1050——最大子矩阵和

##### 1.二维化一维思路

假设最大子矩阵的结果为从第r行到k行、从第i列到j列的子矩阵，如下所示(ari表示`a[r][i]`,假设数组下标从1开始)：
  | a11 …… a1i ……a1j ……a1n |
  | a21 …… a2i ……a2j ……a2n |
  |  .     .     .    .    .     .    .   |
  |  .     .     .    .    .     .    .   |
  | ar1 …… ari ……arj ……arn |
  |  .     .     .    .    .     .    .   |
  |  .     .     .    .    .     .    .   |
  | ak1 …… aki ……akj ……akn |
  |  .     .     .    .    .     .    .   |
  | an1 …… ani ……anj ……ann |
那么我们将从第r行到第k行的每一行中相同列的加起来，可以得到一个一维数组如下：
(ar1+……+ak1, ar2+……+ak2, ……,arn+……+akn)
由此我们可以看出最后所求的就是此一维数组的最大子序列和问题，就可以转化成二维最大子矩阵和问题。

通过遍历列段的起点和终点，可将最大子矩阵问题分解为最大子段和。

时间复杂度O(n^3)。

##### 2.代码

```c++
#include<iostream>
#include<limits.h>//这里一定要有.h，否则编译不够【没有这个头文科】
#include<string.h>
#define NMAX 105
using namespace std;
int dp[NMAX];
int temp[NMAX];
int num[NMAX][NMAX];
int Maxsubstr(int a[],int n){
	memset(dp,0,sizeof(dp));
	dp[0]=0;
	int tempMax=INT_MIN;
	for(int i=1;i<=n;i++){//前i个,包括i-1个【结尾】 
		dp[i]=max(0,dp[i-1])+a[i-1];
		tempMax=max(tempMax,dp[i]);
	}
	return tempMax;
} 
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			cin>>num[i][j];
		}
	}
	int maxAns=INT_MIN;
	for(int i=0;i<n;i++){//i为列起点，j为列终点,i=j时说明只有一个列 
		memset(temp,0,sizeof(temp));
		for(int j=i;j<n;j++){
			for(int k=0;k<n;k++)//遍历所有行 
				temp[k]+=num[k][j];
			int now=Maxsubstr(temp,n);
			maxAns=max(maxAns,now);	
		} 
	}
	cout<<maxAns<<endl;
	return 0;
} 
```

### POJ 1160

递推：前i个村庄，前j个邮局。

存在村庄和邮局两个实体，要用两次动态规划。

有两个实体，要找一个可计算的点，将两个实体联系起来。

**即先考虑1个邮局，i个村庄【区间dp】**

**再计算j个邮局，i个村庄**

双重dp :拿到题先考虑，能解出什么？对于本题可以解出建立一个邮局的最小距离和 
思路：首先求出在连续的几个村庄上建立一个邮局的最短距离，
用数组`dis[i][j]`表示在第i个村庄和第j个村庄之间建一个邮局的最短距。【区间dp】 
`dis[i][j]=dis[i][j-1]+x[j]-x[(i+j)/2]; `（村庄位置为x[i]）
【**当我们在v个村庄中只建一个邮局，可以推导出，只有邮局位于中间村庄的位置，距离和才最小**。有一个特殊情况是，当村庄数为偶数，中间位置有两个村庄，经过计算，两个村庄的距离和相等，所以俩位置均可。】 

至于`dis[i][j]`可以用`dis[i][j-1]`直接推导出的原因，下图论证了：

![](C:\Users\asus\spidermana.github.io\assets\img\dp.png)

用数组`dp[i][j]`表示在前i个村庄[包括i]中建立j个邮局的最小距离。
即**在前k（k<i）个村庄建立j-1个邮局，在k+1到i个村庄建立一个邮局[由dis给出]。**
`dp[i][j]=min(dp[i][j],dp[k][j-1]+dis[k+1][i])`

```c++
//有些村庄存在邮局，有些没有
//邮局的坐标和所在村庄相同
//求应该把邮局建造在哪里使得每个村庄和最临近邮局的距离之和最小 

#include<iostream>
#include<string.h>
#define NMAX 305
using namespace std; 
int vnum,pnum;
int x[NMAX];
int dis[NMAX][NMAX];
int dp[NMAX][35]; 
int main(){
	cin>>vnum>>pnum;
	for(int i=0;i<vnum;i++)
		cin>>x[i];
	for(int i=0;i<vnum;i++){
		dis[i][i]=0;
		for(int j=i+1;j<vnum;j++){
			dis[i][j]=dis[i][j-1]+x[j]-x[(i+j)/2];
		}
	}
	memset(dp,0x3f,sizeof(dp));
	dp[0][1]=0;
	//初始化，建立一个邮局的我已知 
	for(int i=0;i<vnum;i++)
		dp[i][1]=dis[0][i]; 
	
	for(int j=2;j<=pnum;j++){//j个邮局，一个邮局的已经初始化，从j=2开始 
		for(int i=j;i<vnum;i++){//i个村庄，已有j<i个邮局才有意义，因此要求邮局数<村数，因此邮局遍历在外层 
			for(int k=0;k<i;k++){
				dp[i][j]=min(dp[i][j],dp[k][j-1]+dis[k+1][i]);
			}
		}
	}
	cout<<dp[vnum-1][pnum]<<endl; 
	
	return 0;
} 
```

### POJ 1141——括号匹配【区间DP】+具体结果序列【标记/递归】

`dp[i][j]`表示index=i到j的匹配后的括号数。

初始化：`dp[i][i]`=2，表示对于原串中的一个字符，组成匹配括号后，有2个字符

状态转移方程：

1. 遍历中间k位置：`dp[i][j]=dp[i][k]+dp[k+1][j] `
2. 当s[i]=='('&&s[j]==')' || s[i]=='['&&s[j]==']' 时，特判一下`dp[i][j]=min(dp[i][j],dp[i+1][j-1]+2)  `
3. 通过标记断开位置，递归得到具体序列



```c++
//区间DP【i到j区间，一般初始化为dp[i][i]，len从0扩展到n】 +递归 
//题意：给了一个括号序列（只有"("  ")"  "["  "]"） 
//现在让添加括号，使括号序列变得匹配，要求添加最少的括号，输出这个匹配的括号序列；
// 
//思路：区间DP，dp[i][j]表示区间i~j匹配添加括号后【完全匹配了】的区间/串最小长度，
//dp[i][j]=dp[i][k]+dp[k+1][j] ,
//注意当s[i]=='('&&s[j]==')' || s[i]=='['&&s[j]==']' 时，特判一下dp[i][j]=min(dp[i][j],dp[i+1][j-1]+2);  
//这样可以找出匹配后的序列最小长度，
//
//区间dp求具体序列，要使用递归+标记 
//
//但是题目要求输出匹配的序列，那么可以在定义一个数组v[i][j] 标记i~j区间的断开位置，
//如果s[i]=='('&&s[j]==')' || s[i]=='['&&s[j]==']' 时 v[i][j]==-1, 然后在递归调用输出即可； 
//参考连接：https://www.cnblogs.com/chen9510/p/5849467.html
#include<iostream>
#include<string.h>
#define NMAX 205
using namespace std;
int dp[NMAX][NMAX];
int bk[NMAX][NMAX]; 
string a;
char getPair(char now){
	switch(now){
		case '(':
			return ')';
		case '[':
			return ']';
		case ')':
			return '(';
		case ']':
			return '['; 
	} 
} 
void printseq(int l,int r){
	if(l>r)
		return;
	if(l==r){
		if(a[l]=='('||a[l]=='['){
				cout<<a[l]<<getPair(a[l]);
		}
		else{
			cout<<getPair(a[l])<<a[l];
		} 
		return;
	} 
	if(bk[l][r]!=-1){
		printseq(l,bk[l][r]);
		printseq(bk[l][r]+1,r);
	}
	else{
		cout<<a[l];
		printseq(l+1,r-1);
		cout<<a[r];
	}
	return;
} 
int main(){
	
	cin>>a;
	int n=a.length();
	memset(dp,0,sizeof(dp));
	memset(bk,0xff,sizeof(bk));
	//dp初始化 
	for(int i=0;i<n;i++){
		dp[i][i]=2;//对于区间i到i，只有一个括号，只能是再加上匹配的括号，形成一对括号2个 
	}
	for(int l=1;l<n;l++){//l=0时为初始化，现在考虑l=1开启 
		for(int j=0;j+l<n;j++){
			dp[j][j+l]=0x3fffffff;
			for(int k=j;k<=j+l;k++){
				if(dp[j][j+l]>dp[j][k]+dp[k+1][j+l]){
					dp[j][j+l]=dp[j][k]+dp[k+1][j+l];
					bk[j][j+l]=k;
				}
			} 
			if((a[j]=='('&&a[j+l]==')')||(a[j]=='['&&a[j+l]==']')){
				if(l>1&&dp[j][j+l]>dp[j+1][j+l-1]+2){
					 dp[j][j+l]=dp[j+1][j+l-1]+2;
					 bk[j][j+l]=-1;
				}
				else if(l==1&&dp[j][j+l]>2){
					dp[j][j+l]=2;//如果l==1，那么会出现 j+1>j+l-1的情况，因此dp[j+1][j+l-1]无意义了 【但是想一下，无意义的这个dp恰好为0，导致dp[j+1][j+l-1]+2=2所以不分类讨论也对，不用加l>1，直接统一处理 
					bk[j][j+l]=-1;//如果l==1，两头匹配，那么就匹配后只有2个长度，此时标记br=-1，表示不用切割 
				}
			}
		}
	}
	printseq(0,n-1); 
	cout<<endl;
	return 0;
} 
```

##### 总结1：

注意！！！：通过本题区间dp和上一题区间dp可明确，区间dp和递推式dp的区别

1. **区间dp是遍历中间断点来构造状态转移方程**从而扩展的。初始化`dp[i][i]`位于矩阵对角线上，遍历len扩展。for循环len，再for循环起点。
2. 递推式dp：由前i-1个递推出前i个，从而进行扩展的。标准的0~n，for循环。

