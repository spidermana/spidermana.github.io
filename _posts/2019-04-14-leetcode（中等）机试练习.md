---
title: leetcode（中等）机试练习
date: 2019-04-14
tags: 算法
---

## Leetcode

### Add Two Numbers

#### 一、题意

利用sscanf和sprintf进行字符串处理，计算加法，得到结果。

再按照要求输出

#### 二、知识点

##### ①sscanf：按格式拆分字符

> int sscanf(const char *str, const char *format, ...)
>
> str：待处理字符串
>
> format:格式化方式
>
> ……：处理后存储的变量
>
> 处理str，把匹配format中(%……）依次放到后面的变量中

```c++
//示例1
int day, year;
char weekday[20], month[20], dtm[100];

strcpy( dtm, "Saturday March 25 1989" );
sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );//注意&

printf("%s %d, %d = %s\n", month, day, year, weekday );
//March 25, 1989 = Saturday

//示例2
sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);
printf("%s/n", buf);
//给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串
//先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中
//%*[^/]:贪婪匹配，直到到遇到一个/，*丢弃【/没有被匹配】
// /:匹配一个/
//%[^@]:从/后匹配到@之前，保留存储到buf中
```

format的用法：format 说明符形式为 **[=%[*]\[width][modifiers]type=]**

sscanf与scanf类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源。
其中的**format**可以是一个或多个 {%[*] [width] [{h | l | I64 | L}] type | ' ' | '/t' | '/n' | 非%符号}。

1、* 亦可用于格式中, (即 %\*d 和 %\*s) **加了星号 (\*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)**
2、{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。
3、width表示读取宽度。
4、{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。
5、type :这就很多了，就是%s,%d之类。
6、特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值
支持集合操作：
7、%[a-z] 表示匹配a到z中任意字符，**贪婪模式**(尽可能多的匹配)
8、%[aB'] 匹配a、B、'中一员，贪婪模式
9、%\[**^**a] 匹配**非a**的任意字符，贪婪模式

##### ②sprintf：按格式拼接字符串

> int sprintf(char *str, const char *format, ...)
>
> format 标签属性是 **%[flags]\[width]\[.precision][length]specifier**

```c++
//示例
char str[80];
sprintf(str, "Pi 的值 = %f", M_PI);
puts(str);
//Pi 的值 = 3.141593
```

参考：[format各部分说明详解](http://www.runoob.com/cprogramming/c-function-sprintf.html)

##### ③str.erase（staind，len）

```c++
// 从位置pos=10处开始删除，直到结尾
str.erase(10);
//从位置pos=6处开始，删除4个字符
str.erase(6, 4);
//删除迭代器[first, last)区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.
str.erase(str.begin() + 10, str.end());
//erase后str本身存储了删除的结果，不需要重复赋值
```

注：void pop_back();方法也可以用来删除元素, 但是只能删除string的最后一个元素

##### ④getline(cin,str)

可以用于输入带有空格的字符，默认定界符为回车，<u>该定界符既不被放回输入流，也不被放入要生成的字符串。</u>

从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束。1）到文件结束，2）遇到函数的定界符，3）输入达到最大限度。

- 返回：成功->返回读取的字节数。失败->返回-1。
- 参数：getline (istream& is, string& str, char delim);、输入流、存储的str、定界符

#### 三、代码

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
int main(){
	string str;
	char str1[50],str2[50];
	getline(cin,str);
	int len=str.length();
	for(int i=0;i<len;i++){
		if(str[i]==' ')
			str.erase(i,1);
	}
	//cout<<str<<endl;
	sscanf(str.data(),"(%[^+)])+(%[^+)])",str1,str2);
	//cout<<str1<<endl;
	//cout<<str2<<endl;
	int len1=strlen(str1);
	int len2=strlen(str2);
	int sum1=0;
	int sum2=0;
	for(int i=len1-1;i>=0;i=i-3){
		sum1=sum1*10;
		sum1+=(str1[i]-'0');
	}
	for(int i=len2-1;i>=0;i=i-3){
		sum2=sum2*10;
		sum2+=(str2[i]-'0');
	}
	//cout<<sum1<<" "<<sum2<<" "<<sum1+sum2<<endl; 
	int totsum=sum1+sum2;
	int flag=false;
	while(totsum!=0){
		if(!flag){
			flag=true;
		}
		else{
			cout<<" -> ";
		}
		cout<<totsum%10;
		totsum=totsum/10;
	}
	cout<<endl;
	
	return 0;
}
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public://形成和的链表
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1==NULL and l2==NULL)
            return NULL;
        else if(l1==NULL)
            return l2;
        else if(l2==NULL)
            return l1;
        int a= l1->val+l2->val;
        ListNode *ans = new ListNode(a%10);
        ans->next = addTwoNumbers(l1->next,l2->next);
        if(a>=10)//如果l1和l2当前位的和，需要进位，则更新ans->next，要多加上一个1
            ans->next = addTwoNumbers(ans->next,new ListNode(1));
        return ans;
    }
};
```

### Longest Substring Without Repeating Characters

求最长非重复子串【longest substring 】，不是子序列【subsequence 】，因此要求连续。

- 一种方法直接暴力枚举区间[i,j]
- 另外一种是使用滑动区间
  - 维护一个滑动窗口，窗口内的都是没有重复的字符，尽可能扩大窗口的大小，窗口的大小就是非重复子串。
  - 窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界
  - 当前遍历到的字符从未出现过，right++
  - 如果之前出现过，那么就分两种情况，在或不在滑动窗口内。
    - 如果不在滑动窗口内，那么就没事，当前字符可以加进来
    - 如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，移动left指针到该重复字符最后出现的位置。
  - 维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int m[256] = {0}, res = 0, left = 0;
        //建立一个256位大小的整型数组来代替HashMap，ASCII表共能表示256个字符,s[i]的取值在0-255
        //但是由于键盘只能表示128个字符，所以用128也行,
        for (int i = 0; i < s.size(); ++i) {
            if (m[s[i]] == 0 || m[s[i]] < left) {//没有出现过或者在左边界以左
                res = max(res, i - left + 1);
            } else {
                left = m[s[i]];//字符出现过，移动左边界到出现过的位置
            }
            m[s[i]] = i + 1;
        }
        return res;
    }
};
```

###  Longest Palindromic Substring

注意对于可删除原串字符形成的回文子串的这类题目，可以通过串S和逆序串S'的最长公共子序列来求解。

对于本题，不可过串S和逆序串S'的最长公共子串来求解最长回文串。比如以下示例

> Let’s try another example: S*S* = "abacdfgdcaba", S'*S*′ = "abacdgfdcaba".
>
> The longest common substring between S*S* and S'*S*′ is "abacd". Clearly, this is not a valid palindrome.

我们给出 P(i,j)的定义如下：
$$
P(i,j) = \begin{cases} \text{true,} &\quad\text{如果子串} S_i \dots S_j \text{是回文子串}\\ \text{false,} &\quad\text{其它情况} \end{cases}
$$
因此，
$$
P(i, j) = ( P(i+1, j-1) \text{ and } S_i == S_j )
$$
首先初始化一字母和二字母的回文:
$$
P(i, i) = true  \\
P(i, i+1) = ( S_i == S_{i+1} )
$$
然后通过直观的动态规划解法，然后找到所有三字母回文，并依此类推…

**复杂度分析**

- 时间复杂度：O(n^2)， 这里给出我们的运行时间复杂度为 O(n^2) 。
- 空间复杂度：O(n^2)， 该方法使用 O(n^2)的空间来存储表。

```c++
class Solution {
public:
        string longestPalindrome(string s) {
            int len=s.length();
            bool **dp = new bool *[len+1];
            for(int i=0;i<=len;i++){
                dp[i]=new bool [len+1];
            }
            for(int i=0;i<len;i++){
            	for(int j=0;j<len;j++){
            		dp[i][j]=0;
				}
			}
			int left=0,anslen=1;
            for(int i=0;i<len;i++){
                dp[i][i]=1;
                if(i+1<len){
                	dp[i][i+1]=(s[i]==s[i+1]? 1:0);
                	if(dp[i][i+1]){
                        anslen=2;
                        left=i;
                	}
				}
            }
            for(int k=2;k<len;k++){
                for(int i=0;i+k<len;i++){
                    dp[i][i+k]=dp[i+1][i+k-1]&&(s[i]==s[i+k]);
                    if(dp[i][i+k]&&k+1>anslen){
                        anslen=k+1;
                        left=i;
                    }
                }
            }
            return s.substr(left,anslen);
            
        }
};
```

### ZigZag Conversion

就是简单的字符串处理

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        string ans="";
        int len=s.length();
        if(numRows==1)//numRows=1要特殊处理 
        	return s;
        for(int h=0;h<numRows;h++){
        	int i;
            //如果是numRows=1， i=i+2*numRows-2会变成i=i，因此不可行，死循环了 
            for(i=h;i<len;i=i+2*numRows-2){
                if(i!=h&&h!=0&&h!=numRows-1){
                    ans+=s[i-h*2];
                    cout<<"now="<<s[i-h*2]<<endl;
                }
                cout<<"h="<<h<<" char="<<s[i]<<endl;
                ans+=s[i];
            }
            if(h!=0&&h!=numRows-1&&i-h*2<len){
                ans+=s[i-h*2];
                cout<<"now="<<s[i-h*2]<<endl;
            }
        }
        return ans;
        
    }
};
//参考答案
class Solution {
public:
    string convert(string s, int numRows) {

        if (numRows == 1) return s;

        vector<string> rows(min(numRows, int(s.size())));//构造了min(numRows, int(s.size()))个元素，初始化为0/“”
		//每个元素是一个string，有多个string。每个string存储锯齿模式下的一行 
        int curRow = 0;
        bool goingDown = false;

        for (char c : s) {//顺序遍历s 
            rows[curRow] += c;//对这个string元素+char 
            //以下模拟了锯齿的路径，true表示行好增加【goingDown=true】，false表示行号减少
            //在行0和行尾，增加方向更改【1->-1、-1->1】 
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        string ret;
        for (string row : rows) //遍历vector的每个元素 
			ret += row;//每个元素=某行【string】 ，累加 
        return ret;
    }
};
```

### String to Integer (atoi)

模拟atoi，就是简单的字符串处理，要注意多种情况。

由于数据可能超过int上限，因此要使用long long int 存储结果。

在累加的过程中如果超过INT_MAX或INT_MIN就判断直接返回对应界限，否则一直累加下去可能会超过long long int的上限。

- 注意INT_MAX+5：得到的是负数【越过上界了，模运算回到负界限】

```c++
class Solution {
public:
    int myAtoi(string str) {
        long long int num=0;
        int len=str.length();
        int i;
        for(i=0;i<len;i++){
        	if(str[i]!=' ')
        		break;
		}
		if(i==len||!(str[i]=='+'||str[i]=='-'||(str[i]>='0'&&str[i]<='9'))){
			return 0;
		}
		bool minus=false;//默认不带负号，也就是一个数没有符号，我们是认为其为正数 
		if(str[i]=='+'||str[i]=='-'){
			minus=str[i]=='+'? 0:1;
			i++;
		}
		//cout<<"dasd"<<endl; 
		int sta=i;
		for(int j=sta;j<len;j++){
			if(str[j]>='0'&&str[j]<='9'){
				num*=10;
				num+=str[j]-'0';
				long long int temp=minus? -num:num;
                if(temp>INT_MAX||temp<INT_MIN){
                    return minus? INT_MIN:INT_MAX;
                }
                //cout<<num<<endl;
			}
			else{
				num=minus? -num:num;
				if(num>INT_MAX){
					return INT_MAX; 
				}
				else if(num<INT_MIN){
					return INT_MIN;
				} 
				else{
					return num;
				}
			}
		}
		//如果字符串只有一个符号，那么去掉符号后，已经遍历到字符串尽头,这种情况num保持0
		//或者全是数组，完全转化正常也返回num 
		num=minus? -num:num;
		if(num>INT_MAX){
			return INT_MAX; 
		}
		else if(num<INT_MIN){
			return INT_MIN;
		} 
		else{
			return num;
		}
    }
};
```

### Container With Most Water

可以暴力模拟，或两点逼近优化

1. 两个柱子之间可以装下的最大水量取决于更小柱子
2. 设置两个指针P1,P2，初始化位于头和尾，朝内逼近。
3. 将指向较小柱子的指针向内移动，指向较大柱子的指针不动
4. 这样才可能试探到更大的面积【朝内移动时，宽度减少了，但是指向较小柱子的指针向内移动，可能会找到比此前较大柱子更高的柱子，使得此时的高度minheight=（P1_height,P2_height）更高】
5. 相反如果移动较大柱子的指针，不仅宽度变小了，还使得高度不能更高【肯定比之前较小柱子更小】

```c++
//暴力枚举柱子O(n^2)
class Solution {
public:
    int maxArea(vector<int>& height) {
    	int size=height.size();
    	int maxSquare=0;
        for(int i=0;i<size;i++){
        	for(int j=i+1;j<size;j++){
				int Minh = min(height[i],height[j]);
				maxSquare = max(maxSquare,(j-i)*Minh);
			} 
		} 
		return maxSquare;
    }
};
//两点逼近优化O(n)
class Solution {
public:
    int maxArea(vector<int>& height) {
    	int size=height.size();
    	int maxSquare=0;
        int l=0,r=size-1;
        int minh=0;
        while(l<r){
            int width=r-l;
            if(height[l]<height[r]){
                minh=height[l];
                l++;
            }
            else{
                minh=height[r];
                r--;
            }
            maxSquare=max(maxSquare,minh*width);
        }
        return maxSquare;
    }
};
```

### Integer to Roman

模拟题，从大到小范围进行判断处理，先把大的罗马数减去，存储罗马字符到ans中，直到数字为0

```c++
class Solution {
public:
	string GetChar(int &num){
		if(num>=1000){
			num=num-1000;
			return "M";
		}
		else if(num>=900){
			num-=900;
			return "CM";
		}
		else if(num>=500){
			num-=500;
			return "D";
		}
		else if(num>=400){
			num-=400;
			return "CD";
		}
		else if(num>=100){
			num-=100;
			return "C";
		}
		else if(num>=90){
			num=num-90;
			return "XC";
		}
		else if(num>=50){
			num-=50;
			return "L";
		}
		else if(num>=40){
			num-=40;
			return "XL";
		}
		else if(num>=10){
			num-=10;
			return "X";
		}
		else if(num>=9){
			num-=9;
			return "IX";
		}
		else if(num>=5){
			num-=5;
			return "V";
		}
		else if(num>=4){
			num-=4;
			return "IV";
		}else{
			num-=1;
			return "I";
		}
	}
    string intToRoman(int num) {
        string ans="";
        while(num!=0){
        	ans+=GetChar(num);
		}
		return ans;
    }
};
```

