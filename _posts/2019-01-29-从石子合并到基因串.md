---
title:石子合并问题-->基因串（DP）
date: 2019-01-29 15:10:00
tags: 算法
---



## 石子合并问题

石子合并问题是最经典的DP问题，主要有三种题型
$$
\begin{cases} 
		任意合并\\
		相邻合并\\
		环形合并
	\end{cases}
$$
目的是：将N堆石子，根据一定的规则有序【找到某种最优合并顺序】的合并成一堆，使得合并代价最小。

### (一)任意合并

##### 1.题目

有N堆石子，现要将石子有序的合并成一堆，规定如下：

每次只能移动**任意**的2堆石子合并，合并<u>花费为新合成的一堆石子的数量</u>。

求将这N堆石子合并成一堆石子的最小花费

##### 2.思想

由于合并的是任意两堆，则直接**贪心**即可，<u>**每次选择最小的两堆合并**</u>。

本问题**实际上就是哈夫曼的变形**。

【如果先合并大堆的石子，则每次合并这个大堆的石子就会有更多次计入到费用中，因此合并小的堆合理，小的石子堆更多次计入费用中，使得总花费最小】

##### 3.解法

- STL堆算法


```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std; 
int main()
{
	int t;
	cin>>t;
	
    while(t--){
        int n;
        cin>>n;
        vector<int> v;
        while(n--){
            int x;
            cin>>x;  
            v.push_back(x); //创建队列
        }
        long long sum=0;
        make_heap(v.begin(),v.end(),greater<int>()); //对混乱的队列构建最小堆
        while(v.size()>1)
        {
            int min1=v.front(); //取出堆顶，即最小值
            pop_heap(v.begin(),v.end(),greater<int>()); //pop堆顶到队尾【end()-1】
            v.pop_back(); //删除队尾元素

            int min2=v.front(); 
            pop_heap(v.begin(),v.end(),greater<int>());
            v.pop_back();

            //cout<<min1<<" "<<min2<<endl;
            sum+=(min1+min2); //合并两个最少的石子堆
            v.push_back(min1+min2); //重新插入堆中
            push_heap(v.begin(),v.end(),greater<int>()); //更新堆元素，做上拉
        }
        cout<<sum<<endl;
    }
    return 0;

}
```

- STL优先队列 


```c++
#include<iostream>
#include<queue>
//#include<bits/stdc++.h>
using namespace std;
const int MAX=1e4+5;
int n; 
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--){
		int n,x;
	cin>>n;
	priority_queue<int,vector<int>,greater<int> >q; //最小堆数据结构
	for(int i=0;i<n;i++)
	{
		cin>>x;
		q.push(x);
	}
	long long sum=0;
	while(q.size()>1)
	{
		int min1=q.top(); //取出堆顶元素【此时没有删除】
		q.pop(); //删除堆顶元素
		int min2=q.top();
		q.pop();
		sum+=(min1+min2);
		q.push(min1+min2); //合并成的石子重新插入堆中
	}
	cout<<sum<<endl;
	} 
	return 0;
 }
```



### (二)相邻合并

这就是标准的dp问题了。

##### 1.题目

有N堆石子，现要将石子有序的合并成一堆，规定如下：

1.每次只能移动相邻的2堆石子合并 
2.合并花费为新合成的一堆石子的数量。

求将这N堆石子合并成一堆的总花费最小（或最大）。

##### 2.思路

第i堆到第j堆的石子合并的最小/大费用在于遍历k(i<=k<=j)【即尝试所有i到j的切割点】，找使得第i堆到第k堆合并费用+第k堆到第j堆合并费用最小/大的那个k，由此确定合并的某个切割点。
则第i堆到第j堆的石子合并的最小/大费用=第i堆到第k堆合并费用+第k堆到第j堆合并费用+这两个堆【第i堆到第k堆合并形成的堆及第k堆到第j堆合并形成的堆】合并成大堆的费用

（1）建立最优值递归式

- 设 `Min[i][j]`代表从第 i 堆石子到第 j 堆石子合并的最小花费,`Min [i][k] `代表从第 i 堆石子到第 k 堆石子合并的最小花费,`Min[k+1][j]`代表从第 k+1 堆石子到第 j 堆石子合并的最小花费, w ( i , j )代表从 i 堆到 j 堆的石子数量之和。列出递归式:

$$
\begin{cases}
Min [ i ][ j ] = 0 （i = j）\\
Min [ i ][ j ] = min ( Min [ i ][ k ] + Min [ k + 1][ j ]) + w ( i , j ) , i < j（ i ≤ k < j）
\end{cases}
$$

- 设`Max [i][j] `代表从第 i 堆石子到第 j 堆石子合并的最大花费,`Max [i][k] `代表从第 i 堆石子到第 k 堆石子合并的最大花费,`Max [k+1][j] `代表从第 k+1 堆石子到第 j 堆石子合并的最大花费, w ( i , j )代表从 i 堆到 j 堆的石子数量之和。列出递归式:

$$
\begin{cases}
Max [ i ][ j ] = 0 （i = j）\\
Max [ i ][ j ] =max( Max [ i ][ k ] + Max [ k + 1][ j ] )+ w ( i , j )， i < j （ 遍历k，i ≤ k < j）
\end{cases}
$$

二维数组 `Min [i][j] `、`Max [i][j] `来记录第 i 堆到第 j 堆石子合并的最小花费和最大花费。

（2）初始化

- 各堆石子的数量存储在 a[i] 
-  `Min [i][i]=0 `或`Max [i][i]=0 `
- sum[0]=0 ,计算 sum[i] ,其中 i= 1 , 2 , 3 ,..., n 。
  - sum[i]：表示前i堆石子的总数。用于简化计算，减少复杂度。

（3）循环阶段

- 按照递归式计算 2 堆石子合并 {a i , a i+1 } 的最小花费和最大花费, i=1 , 2 , 3 ,..., n−1 。
- 按照递归式计算 3 堆石子合并 {a i , a i+1 , a i+2 } 的最小花费和最大花费, i=1 , 2 , 3 ,...,n−2 。
- .....
- 以此类推,直到求出所有堆 {a 1 ,..., a n } 的最小花费和最大花费。

（4）总结

- 求前i堆石子总数sum[i]
- 求第i堆到第j堆石子总数目：`w(i,j)=sum[j]-sum[i-1]`
- 最小/最大花费的递推公式：

```
初始化：dp [ i ] [ i ] = 0 （i = j）【初始化dp[i][i]为0，其他为无穷大】
递推：dp[ i ] [ j ] = min ( dp[i][j],dp[i][k] + dp[k + 1][j] + w (i,j)) = min(dp[i][j],d[i][k]+dp[k+1][j]+sum[j]-sim[i]), i < j（ i ≤ k < j）
```

##### 3.解法

```c++
#include <iostream>
 
using namespace std;
 
#define LEN 1024
#define MAXDATA 200000
int MIN[LEN][LEN];
int MAX[LEN][LEN];
int data[LEN];
int sum[LEN];
 
int min(int a, int b)
{
	return a > b? b : a;
}
 
int max(int a, int b)
{
	return a > b ? a : b;	
}
 
void straight(int len)
{
	//初始化对角线,我们知道MIN[i][i]和MAX[i][i]为0
	for (int i = 1; i <= len; ++i)
	{
		MIN[i][i] = 0;
		MAX[i][i] = 0;
	}
	sum[0] = 0;
	sum[1] = data[1];
	for (int i = 1; i < len; ++i)
	{
		sum[i + 1] = sum[i] + data[i + 1];
	}
	for (int i = 0; i <= len; ++i)
	{
		std::cout << sum[i] << "\t";
	}
    
	//数据坐标分析,我们知道是需要循环5次
	for (int v = 2; v <= len; ++v) //区间长度
	{
    /** 
	下面是其中的下标的数据,我们知道i从1到5,1到4,1到3,1到2,1到1,
	j从2到6,3到6,4到6,5到6,6到6
	1,2 1,3 1,4 1,5 1,6
	2,3 2,4 2,5 2,6
	3,4 3,5 3,6
	4,5 4,6
	5,6
	**/
		for (int i = 1; i <= len - v + 1; ++i)//区间起点
		{
			int j = i + v - 1;
			MIN[i][j] = MAXDATA;
			MAX[i][j] = -1;
			int temp = sum[j] - sum[i - 1];
			for (int k = i; k < j; ++k) //用k来表示分割区间 
			{
				MIN[i][j] = min(MIN[i][j], MIN[i][k] + MIN[k + 1][j] + temp);
				MAX[i][j] = max(MAX[i][j], MAX[i][k] + MAX[k + 1][j] + temp);
			}
		}
	}
}
int main()
{
	int all;
	cout << "请输入有多少堆石子" << endl;
	cin >> all;
	cout << "请分别输入每堆石子的个数" << endl;
	for (int i = 1; i <= all; ++i)
	{
		cin >> data[i];
	}
	straight(all);
	cout << "\n";
	cout << "直线形最小花费是" << MIN[1][all] << endl;
	cout << "直线形最大花费是" << MAX[1][all] << endl;
	return 0;	
}

```

```c++
//这个代码的变量意义有所不同
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
//#define inf 1<<20
const int maxn=210;
int n,a[maxn]; 
int  dp[maxn][maxn];//dp[i][j]表示从第i堆到第j堆合并的代价
int  sum[maxn][maxn];//表示石头的数量 
int main()
{
	ios::sync_with_stdio(0);
	while(cin>>n)
	{
		for(int i=1;i<=n;i++)
		cin>>a[i];
		memset(sum,0,sizeof(sum));
		//fill(dp[0],dp[0]+n*n,inf);//错误 
		fill(dp[0],dp[0]+maxn*maxn,inf);//fill填充量必须是常数 
                          
        for(int i=1;i<=n;i++)
        sum[i][i]=a[i],dp[i][i]=0; //初始化

        for(int len=1;len<n;len++){//区间长度 
            for(int i=1;i<=n&&i+len<=n;i++){//区间起点,注意满足i<=n&&i+len<=n[i+len为终点]
                int j=i+len;//区间终点
                for(int k=i;k<=j;k++)//用k来表示分割区间 
                {
                    sum[i][j]=sum[i][k]+sum[k+1][j];
                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[i][j]);
                 } 
            }
        }
        cout<<dp[1][n]<<endl;
    }
    return 0;

} 
```

![代码for循环变量遍历顺序](C:\Users\asus\spidermana.github.io\assets\img\stone2.png)

### (三)环形合并

##### 1.题目

有N堆石子，现要将石子有序的合并成一堆，规定如下：

1.每次**只能选择相邻**的两堆石子合并成新的一堆

2.合并花费为新合成的一堆石子的数量。

3.**石子成环形摆放**

求将这N堆石子合并成一堆的总花费最小（或最大）。

```
 测试用例：
 4（石子的堆数）
 4 4 5 9（每一堆的石子数目）
 输出： 43  54
```

![img](https://pic002.cnblogs.com/images/2010/117588/2010120200361545.png)

##### 2.思路

首先，注意这是环形排布的石子，石子堆圆形摆放，也就是最后一堆石子可以和第一堆石子合并。

**如果照旧使用`dp[i][j]`表示第i堆到第j堆合并，那么这个定义将不准确，无法唯一确定状态**。因为是环形，不可知第i堆到第j堆，是顺时针还是逆时针的。即方式①的第i到第j合并，还是方式②。

![szhb](C:\Users\asus\spidermana.github.io\assets\img\szhb.jpg)

思路：因为环形收尾相接，相当于从每一个元素为起点，长度为n的n条链式问题。

所以，这个问题**有两种解法**： 

- 拆环成链，设置大小为2*n 的数组，值为a1 a2 a3 … an a1 a2 a3 …an， 这样就可以组成一个链式问题。 
  - **此时dp含义不变。**
  - 循环时，长度还是从1到n的， <u>最后的结果是每个元素作为起点，长度为n的最小的值中最小的</u>。
- **改变动态规划中的dp的含义**，`dp[i][j]`定义为从第i堆开始，至向后j长度的堆进行合并。

##### 3.解法

- dp含义不变，2n数组

```c++
#include<iostream>
#include<string>
#include<stdio.h>
#include<algorithm>

using namespace std;

const int inf = 99999999;
const int N = 300;
int num[N], sum[N], n;
int dpmax[N][N], dpmin[N][N];

int main() {
    while(cin>>n) {
        int i,j,k,total;
        for(i = 0; i < n; i++) {
            cin>>num[i];
            num[i+n] = num[i]; //将环变成链
        }

        sum[0] = num[0];
        for(i = 1; i < 2*n; i++) {
            sum[i] = sum[i-1] + num[i];
        }

        for(i = 0; i < 2 * n; i++) {
            for(j = i; j < 2 * n; j++) {
                dpmax[i][j]= -inf;
                dpmin[i][j] = inf;
            }
        }

        for(i = 0; i < 2 * n; i++) {
            dpmax[i][i] = 0;
            dpmin[i][i] = 0;
        }

        for(k = 1; k < n; k++) {//长度
            for(i = 0; i + k < 2 * n; i++) {
                for(j = i; j < i + k; j++) {
                    if(i==0) total = sum[i+k];
                    else total = sum[i+k] - sum[i-1];
                    dpmax[i][i+k] = max(dpmax[i][i+k], dpmax[i][j] + dpmax[j+1][i+k] + total);
                    dpmin[i][i+k] = min(dpmin[i][i+k], dpmin[i][j] + dpmin[j+1][i+k] + total);//起点i的n长度链的合并最小费用
                }
            }
        }
        int resmax = -inf;
        int resmin = inf;
        //不同起点的n长度链合并的最小费用中的最小值。
        for(i = 0; i + n - 1 < 2 * n; i++) {//以每个元素为起点
            resmax = max(resmax,dpmax[i][i+n-1]);//长度为n
            resmin = min(resmin,dpmin[i][i+n-1]);//长度为n
        }
        cout<<resmin<<"\n"<<resmax<<endl;
    }
    return 0;
}

```

- n数组，取模

  设`dp[i][j] `表示从i开始长度为j的一段合并后的最小（最大）值，这样j的最大为n，很好的避免了下标越界问题。 

  递推公式如下所示： 

  假设石头为a1,a2,a3.....an,首尾相连之后就是 a1,a2,a3.....an,a1,a2,a3....an;序列长度变为原来的2倍

  ![这里写图片描述](https://img-blog.csdn.net/20151017201559883) 
  ![这里写图片描述](https://img-blog.csdn.net/20151017201617496) 

  

  ```c++
  #include<bits/stdc++.h>
  #define maxn 1<<27
  #define N  101
  using namespace std;
  int n,ansmin = 1<<27,ansmax = -1;
  int dp_max[N][N],dp_min[N][N];
  int date[N];
  void init()
  {
  	cin>>n;
  	date[0] = 0;
  	for(int i=1;i<=n;i++)
  	{
  		cin>>date[i];
  		dp_min[i][1] = 0;//还没合并，没有花费 
  		dp_max[i][1] = 0;
  	}
  	
  }
  int sum(int i,int v)
  {
  	int ans = 0;
  	for(;v>0;v--,i++)
  	{
  		if(i>n)
  		i%=n;
  		ans+=date[i];
  	}
  	return ans;
  }
  void AC()
  {
  	init();
  	for(int v=2;v<=n;v++)//合并的个数 
  	{
  		for(int i=1;i<=n;i++)//起始位置 
  		{
  			dp_min[i][v] = maxn;
  			dp_max[i][v] = -1;
  			for(int k =1;k<v;k++)
  			{
  				dp_min[i][v] = min(dp_min[i][v],dp_min[i][k]+dp_min[(i+k-1)%n+1][v-k]+sum(i,v));
  				dp_max[i][v] = max(dp_max[i][v],dp_max[i][k]+dp_max[(i+k-1)%n+1][v-k]+sum(i,v));
  			 } 
  		 } 
  	}
  	for(int i=1;i<=n;i++)
  	{
  		if(dp_min[i][n]<ansmin)
  		ansmin = dp_min[i][n];
  		if(dp_max[i][n]>ansmax)
  		ansmax = dp_max[i][n];
  	}
  }
  int main()
  {
  	AC();
  	cout<<ansmin<<endl<<ansmax;
  	return 0;
  }
  ```

  


## 基因串问题

#### ①F:基因串问题

- **总时间限制:** 

  1000ms

- **内存限制:** 

  65536kB

- **描述**

  基因串是由一串有限长度的基因所组成的，其中<u>每一个基因都可以用26个英文大写字母中的一个来表示</u>，不同的字母表示不同的基因类型。一个单独的基因可以生长成为一对新的基因，而可能成长的规则是通过一个有限的成长规则集所决定的。每一个成长的规则可以用<u>三个大写英文字母*A*1*A*2*A*3</u>来描述，这个规则的意思是基<u>因*A*1可以成长为一对基因*A*2*A*3</u>。 用大写字母*S*来表示一类称作超级基因的基因，因为<u>每一个基因串都是由一串超级基因根据给出的规则所成长出来的</u>。 请写一个程序，<u>读入有限条成长的规则和一些我们想要得到的基因串，然后对于每个基因串，判断它是否可以由一个有限长度的超级基因串成长得出</u>。如果可以，给出可成长为该基因串的<u>最短超级基因串的长度</u>【即求最少的S个数】。

- **输入**

  第一行为正整数*N*(*N* ≤ 50)表示规则的数目。 接下来*N*行，每行一个规则。 最后一行是目标基因串，长度不超过100。

- **输出**

  输出最短的超级基因串的长度，如果无法生成，请输出-1

- **样例输入**

  ```
  3 
  BCA  
  ABC  
  SAB  
  BCCA 
  ```

- **样例输出**

  `1 `

- **提示**

  - S -> AB -> BCB -> BCCA  
  - 此题和石子归并问题类似,可以用`f[i][j][C]`表示从*i*到*j*的子串能否由C推导得出,`f[i][j][C] = 0`表示不能,`f[i][j][C] = 1`表示能,则有: `f[i][j][C] = max{f[i][k][A]·f[k+1][j][B]} `【如果i到j可由C推导出，则i到k可由A推导出，且k+1到j可由B推导出，并且AB可由C推导出，遍历所有的k切割点，尝试C->AB规则，取max】 这样可以计算出每一段能否由一个超级基因*S*推导得出. 
  - 再由一次类似的动态规划过程可以算出每个子串最少由几个*S*推导得出(比如用`g[i][j]`表示从*i*到*j*的子串至少由几个*S*推导得出),即得到原问题的解.
  - 二重动态规划

#### ②分析

- 置换规则的特殊性：两个字符置换成为一个字符，并目标串的所有字符为一个确定的超级基因字符。这样，**置换的过程实际上是分别把一段一段连续的字符置换成为这个超级基因字符**。
- 置换方法：
  - 第一种：这段字符本身就是超级基因字符； 
  - 第二种：把这一段字符拆成左右两段，分别置换为两个字符，并且这两个字符也可以被置换为超级基因字符。
- 由此可以看出，这个置换的过程是包括**许多重复子问题的**。又由于每次置换都会减少字符的数目，所以可以考虑用动态规划来解决这个问题。



##### <u>方法一</u>

##### 这道题是典型的双重动态规划。

**第一步**： 由题意可以知道，分化具有阶段性和规律性，这正是动态规划的特征。由于要求的是最少的特等基因数目，所以考虑一次分化的情况。要一次分化到的串【目标串】设为T，假设字符Ch1能够一次分化成Ch2和Ch3，并且Ch2能够一次分化成从第p位到第i位的字符串，而Ch3能够一次分化成从第i+1位到第q位的字符串， 那么必有Ch1能够一次分化到从第p位到第q位的字符串。如Ch1=S,Ch2=A,Ch3=B时，S->AB，A->BC，B-> CD，则 S -> BCCD。**需要穷举 Ch2 和 Ch3**。动态转移方程如下：

```
 can[ch1,p,q]:= can[ch2,p,i] and can[ch3,i+1,q] 
 //遍历所有切割点i,取max{can[ch2,p,i] and can[ch3,i+1,q]}
```

其中ch1能够一次分化到ch2和ch3。这里的i作为划分点，再次体现了二分的思想。
由于本人的程序中使用了记忆化搜索的思想，所以 can 设置为了数值型，初始值为 0，能够一次分化为 1，否则为 2。
**第二步**：**由上面的思路可以得出任意一个字符Ch能否一步分化到字串T的任意一段**。那么，可知T串的哪些段可以得出一个字符S，也就可以通过dp得出指定字串至少可由多少个S分化得到。**即再次使用动态规划思想**。假设DP[i]表示T的前i位字串至少需要的特等基因S的数目，那么易得动态转移方程如下：

```
 DP[i]:= min {DP[j] + 1}; 
 //其中的 j 符合，can['S',j+1,i]=true 
 //即0-j需要DP[j]个S分化出，j+1到i需要1个S分化出【can['S',j+1,i]=true】
```

（或，记忆化搜索中使用 can['S',j+1,i]=1）

**第三步：结果形成目标串T需要的超级基因字符‘S’的最少字符数为dp[T.length()]**



##### <u>方法二</u>

仅在第二步有所不同，其实是第二步的二维版本，没有做成一维优化，但是更好理解。

1. 初始化`g[i][j]=0`

2. 判断如果can['s',i,j]=1,则`g[i][j]=1`

3. 【再次使用dp】否则，遍历切割点k【i<=k<=j】

   ```
   if (g[i][k] && g[k+1][j])
   	g[i][j]=min(g[i][j],g[i][k]+g[k+1][j])
   ```

4. 输出生成整个目标串需要的S超级基因数`g[0][T.length()-1]`，如果`g[0][T.length()-1]`=0，输出-1表示无法生成。

#### ③代码

```c++
#include <iostream>
#include<string.h>
#include<stdio.h> 
#include<stdlib.h>
using namespace std;
int m[100][100][26]; //石子合并 
int g[100][100];//dp，记录第i到第j需要最少的超级基因数。
char target[100];
char norm[50][3];
//双重dp
//第一重dp要考虑合并成A-Z所有字符的情况
//第二重dp考虑合并成S字符的情况 
int main()
{
	int n;
	cin>>n;//规则数目 
	for (int i = 0; i < n; ++i)
	{
		cin>>norm[i][0]>>norm[i][1]>>norm[i][2];
	}

	int len = 0;
	scanf("%s", target);
	while (target[len] != ' ') len++;//目标串长度 
	
	len = strlen(target);
	int i, j, k, r, ns, ss;
	//初始化 
	for (i = 0; i < len; i++)
	{
		for (ss = 0; ss < 26; ss++)
		{
			if (target[i] == 'A'+ ss)
				m[i][i][ss] = 1;  //m[i][j][ss]=1:目标串的第i个位置到第j个位置可以转化成字符【ss+'A'】，否则=0 
			else
				m[i][i][ss] = 0;
		}
		if (target[i] == 'S') g[i][i] = 1;
		else g[i][i] = 0;
	}
	//石子合并变式 
	for (r = 1; r <= len; ++r) //遍历可能长度r 
	{
		for (i = 0; i < len-r; ++i) //起始点，起始点+长度<=总长  ：i+r<len 
		{
			j = i + r;//起点i，终点j，切割点k 
			for (ss = 0; ss < 26; ss++) m[i][j][ss] = 0;
			for (k = i; k < j; k++) //遍历切割点 
			{
				for (ss = 0; ss < 26; ss++)//遍历每种合成以后可能的目标字符ss+'A' 
				{
					for (ns = 0; ns < n; ++ns)//对于A/B/C/D……，找规则满足这个字符的 
					{
						if (norm[ns][0] == 'A'+ss)//遍历所有规则， norm[ns][0]->norm[ns][1]、norm[ns][2] 
						{
							int left = norm[ns][1] - 'A';
							int right = norm[ns][2] - 'A'; //计算第i到第j能够合成的所有可能字符，能不能合成A？m[i][j][0]=1? 能不能合成B？m[i][j][1]=1? 能不能合成C？m[i][j][3]=1? 
							int temp = m[i][k][left] & m[k+1][j][right];
							m[i][j][ss] = m[i][j][ss] > temp ? m[i][j][ss] : temp; //取max 
						}
					}
				}
			}
			//到此处，已判断完第i到第j可合成的所有字符可能，设置好m[i][j][a],0<=a<=25的值 
			g[i][j] = 0;
			if (m[i][j][18])//本身 m[i][j][18]=1，则说明i到j可以合成为一个s 
				g[i][j] = 1;//18表示s 
			else//否则，进行切割点切割 
			{
				int temp = 101;
				for (k = i; k < j; ++k)//考虑i到j部分的子串，如果 
				{
					if (g[i][k] && g[k+1][j])//由于i到k和k+1到j已经更新过。因为最外围是长度，长度小的[k-i.j-(k+1)小于j-i]已经更新 
					{ //如果g[i][k]和g[k+1][j]不等于0，则说明已经确定了S字符的个数 
						int tt = g[i][k] + g[k+1][j];//则g[i][j]就是两者相加 
						temp = temp < tt ? temp : tt;//取最小值 
					}
				}
				if (temp != 101) g[i][j] = temp; //题目说：目标基因串，长度不超过100。
                //因此最终的超级基因串肯定也不会超过100，故temp一定不会达到101的 
			}
		}
	}
	
	if(g[0][len - 1] == 0) //如果无法生成，请输出-1
		cout<<-1;
	else
		cout<<g[0][len - 1];//生成整个目标串需要的S超级基因数 
	return 0;
}
```

![ac截图](C:\Users\asus\spidermana.github.io\assets\img\jycac.jpg)

## 其他

### 堆算法

1. 头文件`#include<algorithm>`

2. 库函数

   - std::make_heap将[start, end)范围进行**堆排序**，默认使用`less<int>`, 即最大元素放在第一个
     - 对于一个整体混乱的队列/数组，做一个堆【新建堆】
   - std::pop_heap**将front（即第一个最大元素）移动到end的前部**【因此这个元素实际没有删除】，同时将剩下的元素重新构造成(堆排序)一个新的heap。
     - 如果要删除最大元素，则要pop_heap以后【此时最大元素已经在vec.end()-1】，再vec.pop_back()，删除最大值。
   - std::push_heap对**刚插入的（尾部）元素**做(堆排序)。
     - 一般在vec.push_back(元素)以后执行
     - "插入堆"操作，只会影响部分堆位置
   - std::sort_heap将一个堆做排序,**最终成为一个有序的系列**【这个就是全排序】，可以看到sort_heap时，必须先是一个堆（两个特性：1、最大元素在第一个 2、添加或者删除元素以对数时间），因此**必须先做一次make_heap.**

3. 参数

   - first, last：迭代器指定范围，使用范围为 `[first,last)`

   - comp：The element with <u>the highest value</u> is an element for which this would <u>return `false` when compared to every other element in the range.</u>
     - 可选有greater<**int**>()和less<**int**>()
     - 自定义cmp比较函数，返回值为bool
     - 重载小于号`operator<` 

4. 示例

   ```c++
   // range heap example
   #include <iostream>     // std::cout
   #include <algorithm>    // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap
   #include <vector>       // std::vector
   
   int main () {
     int myints[] = {10,20,30,5,15};
     std::vector<int> v(myints,myints+5);
   
     std::make_heap (v.begin(),v.end());
     std::cout << "initial max heap   : " << v.front() << '\n';
   
     std::pop_heap (v.begin(),v.end()); v.pop_back();
     std::cout << "max heap after pop : " << v.front() << '\n';
   
     v.push_back(99); std::push_heap (v.begin(),v.end());
     std::cout << "max heap after push: " << v.front() << '\n';
   
     std::sort_heap (v.begin(),v.end());
   
     std::cout << "final sorted range :";
     for (unsigned i=0; i<v.size(); i++)
       std::cout << ' ' << v[i];
   
     std::cout << '\n';
   
     return 0;
   }
   ```

   

