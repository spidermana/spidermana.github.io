---
title: 深度优先搜索
date: 2017-09-05 14:15:00
tags:
- 算法
- ACM
categories:
- 算法
- ACM
---

# 例题一：A Knight's Journey 

## Problem
[knight深搜走遍棋盘+按字典顺序输出](https://cn.vjudge.net/problem/POJ-2488)

**备注**：国际象棋中knight（马）的大致走法就是，第一步向上下左右方向选择走一步，然后斜着走一步。例如下图中马在中心，白点就是它可以走情况。
![knight下步可走的8种可能](/assets/img/8moves.jpg)

## 大致题意
给出一个p行q列的国际棋盘，马可以从任意一个格子开始走，问马能否不重复的走完所有的棋盘。如果可以，输出按字典序排列最小的路径。打印路径时，列用大写字母表示（A表示第一列），行用阿拉伯数字表示（从1开始），先输出列，再输出行。

## 分析

**如何保证字典顺序最小：**

1.如果马可以不重复的走完所有的棋盘，那么它一定可以走到A1这个格子。所以我们从A1走也肯定可以走遍棋盘，因此我们只需从A1这个格子开始搜索，就能保证字典序是小的；

2.控制好马每次移动方向的选择才可以保证字典顺序最小。如何保证移动的选择使得字典顺序小?关键是能向左上方移动的时候，就往左上方移动，尽可能靠近左上方的方向移动，保证行列的字典序小。即按照下图白点标识的序号考虑顺序。
![保证字典顺序最小的移动顺序](/assets/img/possible_move.jpg)

**备注：**种类数可以枚举的时候，常常使用常量数组存储情况。const或者#define这样的。

综合上述1,2两点：用int s[8][2]={-2,-1,-2,1,-1,-2,-1,2,1,-2,1,2,2,-1,2,1}; 来实现搜索过程，能保证输出的是字典序最小的序列~.比如s[0][0]=-2,s[0][1]=-1。说明先考虑行数-2，列数-1的这种走法是否可行（也就是2点中图标识的1情况）。之后依次考虑s[1][0]=-2,s[1][1]=1、s[2][0]=-1,s[2][1]=-2
……

**实现过程变量需求**

1.用path[][0]用来存储路径的横坐标，path[][1]来存储路径的纵坐标。

2.s[][]记录走法，遍历走法情况

3.flag判断是否成功走完棋盘

4.vis[][]判断是否已经走过（新旧点标识）

## 深度搜索求方案数类型题注意事项
对待**求深搜方案数的题**要注意对于记录新旧点的变量，在**尝试走这个新点之后遍历累加所有情况，最后要还原成新点。**目的是为了尝试别的新点的时候，这个点还可以走。

## 代码实现

    #include<stdio.h>  
    #include<string.h>  
    int vis[30][30];  
    int path[30][2];  
    int s[8][2]={-2,-1,-2,1,-1,-2,-1,2,1,-2,1,2,2,-1,2,1};  
    int a,b,flag;  
    void dfs(int x,int y,int ans)  
    {  
        if(ans==a*b)  
        {  
            flag=1;  
            for(int i=0;i<ans;i++)  
            {  
                printf("%c%d",path[i][0]+'A',path[i][1]+1);  
            }  
            printf("\n");  
        }  
        for(int i=0;i<8;i++)  
        {  
            int m=x+s[i][0];  
            int n=y+s[i][1];  
            if(m>=0&&m<b&&n>=0&&n<a&&!flag&&!vis[m][n])  
            {  
                vis[m][n]=1;  
                path[ans][0]=m;  
                path[ans][1]=n;  
                dfs(m,n,ans+1);  
                vis[m][n]=0;  
            }  
        }  
    }  
    int main()  
    {  
        int test,kase=1;  
        scanf("%d",&test);  
        while(test--)  
        {  
            scanf("%d%d",&a,&b);  
            memset(vis,0,sizeof(vis));  
            memset(path,0,sizeof(path));  
            flag=0;  
            vis[0][0]=1;  
            printf("Scenario #%d:\n",kase++);  
            dfs(0,0,1);  
            if(!flag) printf("impossible\n");  
            printf("\n");  
        }  
     }   
