---
layout: post
title: "「MIT 6.828」MIT 6.828 Fall 2018 lab3 "
subtitle: "一直放在心上要做完啊！！！"
date:        2020-10-26 15:00:00
author:  "许大仙"
catalog: true
tags:
    - 系统
---


## Lab3

you will implement the basic kernel facilities required to get **a protected user-mode environment (i.e., "process")** running. 

You will enhance the JOS kernel to set up the data structures to keep track of user environments, create a single user environment, load a program image into it, and start it running. 

You will also make the JOS kernel capable of handling any system calls the user environment makes and handling any other exceptions it causes.

综上，需要实现的基本内核功能如下：

- 进程运行
- 追踪用户环境
- 加载程序镜像
- 处理系统调用和异常

要完成lab3需要关注以下源文件：

```
inc/	env.h	Public definitions for user-mode environments
trap.h	Public definitions for trap handling
syscall.h	Public definitions for system calls from user environments to the kernel
lib.h	Public definitions for the user-mode support library

kern/	env.h	Kernel-private definitions for user-mode environments
env.c	Kernel code implementing user-mode environments
trap.h	Kernel-private trap handling definitions
trap.c	Trap handling code
trapentry.S	Assembly-language trap handler entry-points
syscall.h	Kernel-private definitions for system call handling
syscall.c	System call implementation code

lib/	Makefrag	Makefile fragment to build user-mode library, obj/lib/libjos.a
entry.S	Assembly-language entry-point for user environments
libmain.c	User-mode library setup code called from entry.S
syscall.c	User-mode system call stub functions
console.c	User-mode implementations of putchar and getchar, providing console I/O
exit.c	User-mode implementation of exit
panic.c	User-mode implementation of panic

user/	*	Various test programs to check kernel lab 3 code
```

本实验由PartA和PartB两部分组成。

提交当前lab2修改的部分，并切换到lab3.

```shell
cd ~/lab
git commit -am 'changes to lab2 after handin'
Created commit 734fab7: changes to lab2 after handin
 4 files changed, 42 insertions(+), 9 deletions(-)
git pull
Already up-to-date.
git checkout -b lab3 origin/lab3
Branch lab3 set up to track remote branch refs/remotes/origin/lab3.
Switched to a new branch "lab3"
git merge lab2
Merge made by recursive.
 kern/pmap.c |   42 +++++++++++++++++++
 1 files changed, 42 insertions(+), 0 deletions(-)
```

### Part A: User Environments and Exception Handling

文件`inc/env.h`包含了JOS内核对用户环境的基本定义，即内核使用Env数据结构来追踪每个用户环境。

在本实验中，最初只会创建一个环境，但您需要设计JOS内核以支持多个环境; lab4将通过允许用户环境`fork`其他环境来利用此功能。

#### 用户环境变量

主要涉及`inc/env.h`和`kern/env.c`两个文件。前者是用户环境变量的变量定义，后者是有关的kern管理用户环境所需的变量。

```c

// An environment ID 'envid_t' has three parts:
//
// +1+---------------21-----------------+--------10--------+
// |0|          Uniqueifier             |   Environment    |
// | |                                  |      Index       |
// +------------------------------------+------------------+
//                                       \--- ENVX(eid) --/
//
// The environment index ENVX(eid) equals the environment's index in the
// 'envs[]' array.  The uniqueifier distinguishes environments that were
// created at different times, but share the same environment index.
//
// All real environments are greater than 0 (so the sign bit is zero).
// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and
// stands for the current environment.

#define LOG2NENV		10                       
#define NENV			(1 << LOG2NENV) //JOS可同时管理的最大active environments数量
#define ENVX(envid)		((envid) & (NENV - 1))   //获取ENVX字段
```

environment ID标识了某种特定的环境，每个环境都有各自唯一的ID。可知一个environment ID有三个组成部分：

- environment index，即ENVX(eid)，就是`envs[]`数组的下标
- uniqueifier字段用于区别共享相同用户环境的、不同时间创建的环境【比如不同时间创建的父子进程】
- 第一个bit标识了环境的属性：
  - 为0则表示当前环境
  - 为负，非法
  - 为正，表示所有的真实环境。

接下来就是kern管理用户环境所需的变量：

```c
struct Env *envs = NULL;		// All environments
struct Env *curenv = NULL;		// The current env
static struct Env *env_free_list;	// Free environment list
```

Once JOS gets up and running, <u>the `envs` pointer points to an array of `Env` structures representing all the environments in the system.</u> 

the JOS kernel will support **a maximum of `NENV` simultaneously active environments.**

The JOS kernel keeps all of the inactive `Env` structures on the `env_free_list`. 

- 这使得环境的分配和释放很简单，只需要从free list中删除或添加。

The kernel uses **the `curenv` symbol to keep track of the *currently executing* environment at any given time**. 【在启动过程中，在第一个环境被创建之前，这个字段一直保持NULL】

#### Environment State

`Env`结构在`inc/env.h`定义如下（将来的实验中将添加更多字段）：

```c
struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run

	// Address space
	pde_t *env_pgdir;		// Kernel virtual address of page dir
};
```

- env_tf

  - defined in `inc/trap.h`

    存储未运行该环境时的寄存器数据：holds the saved register values for the environment while that environment is *not* running: i.e., when the kernel or a different environment is running.

  - 内核会负责保存从用户模式到内核模式的寄存器数据，以便之后这个环境被重新启动时可以恢复到他被切换前的状态。

- **env_link**:

  -  `env_free_list`中的next指针
  - This is a link to the next `Env` on the `env_free_list`. 
  - `env_free_list` points to the first free environment on the list.

- **env_id**:

  - kernel会创建一个唯一标识某个环境的字段【uniquely identifiers】、
  - 也就是`environment ID `，该结构中有 `envs` 数组的index
  -  After a user environment terminates, the kernel may re-allocate the same `Env` structure to a different environment - **but the new environment will have a different `env_id` from the old one** <u>even though the new environment is re-using the same slot in the `envs` array.</u>
  - 如果某个Env结构体被回收后重用了，这个env_id字段和之前的环境也不会相同，就是使用了相同的 `envs` array slot【应该说的是environment ID的index一样，Uniqueifier也不同】。

- **env_parent_id**:

  - 存储了创建这个环境的父环境env_id
  - In this way the environments can **form a “family tree,”**
  - 这对于制定允许哪些环境对谁执行操作的相关安全决策很有用。

- **env_type**:

  - 用于区别特殊环境

  - For most environments, it will be `ENV_TYPE_USER`. 

  - We'll <u>introduce a few more types for special system service environments in later labs.</u>

  - ```c
    // Special environment types
    enum EnvType {
    	ENV_TYPE_USER = 0,
    };
    ```

  **env_status**:

  This variable holds one of the following values:

  - `ENV_FREE`: 不活跃状态，放置于`env_free_list`

    Indicates that the `Env` structure is inactive, and therefore on the `env_free_list`.

  - `ENV_RUNNABLE`:等待被调度

    Indicates that the `Env` structure represents an environment that is waiting to run on the processor.

  - `ENV_RUNNING`:当前正在运行

    Indicates that the `Env` structure represents the currently running environment.

  - `ENV_NOT_RUNNABLE`:active但没准备好被调度，可能在等待IO、IPC

    Indicates that the `Env` structure represents a currently active environment, but it is not currently ready to run: for example, because it is waiting for an interprocess communication (IPC) from another environment.

  - `ENV_DYING`:zombie环境

    Indicates that the `Env` structure represents a zombie environment. **A zombie environment will be freed the next time it traps to the kernel**. <u>We will not use this flag until Lab 4.</u>

  **env_pgdir**:

  - This variable holds the kernel *virtual address* of this environment's page directory.
  - 存储了kernel管理环境的页目录

Like a Unix process, a JOS environment couples the concepts of "thread" and "address space". 

- The thread is defined primarily by the saved registers (the `env_tf` field), 
- and the address space is defined by the page directory and page tables pointed to by `env_pgdir`. 

JOS environment和Unix的进程概念相似，需要保存页目录【context】以及寄存器值

**To run an environment**, <u>the kernel must set up the CPU with *both* the saved registers and the appropriate address space</u>.

Our `struct Env` is analogous to `struct proc` in xv6. 

- Both structures hold the environment's (i.e., process's) user-mode register state in a `Trapframe` structure. 

- ```c
  struct PushRegs {
  	/* registers as pushed by pusha */
  	uint32_t reg_edi;
  	uint32_t reg_esi;
  	uint32_t reg_ebp;
  	//……
  	uint32_t reg_eax;
  } __attribute__((packed));
  
  struct Trapframe {
  	struct PushRegs tf_regs;
  	uint16_t tf_es;
  	uint16_t tf_padding1;
  	uint16_t tf_ds;
  	//c ……
  } __attribute__((packed));
  //tarp.h中定义
  ```

**In JOS, individual environments do not have their own kernel stacks** as processes do in xv6. There can be **only one JOS environment active in the kernel** at a time, so <u>JOS needs only a *single* kernel stack</u>.

JOS只有一个内核栈，和xv6不同不是一个用户环境对应一个内核栈。

#### Allocating the Environments Array







### 参考

- https://linux.cn/article-10307-1.html
- https://zhuanlan.zhihu.com/p/74028717
- https://jiyou.github.io/blog/2018/04/28/mit.6.828/jos-lab3/

