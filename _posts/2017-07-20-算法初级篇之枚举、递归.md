---
layout: post
title: 初级算法笔记之枚举、递归
date: 2017-07-20 14:52:00
categories:
- 算法
---

# 一、枚举
简化问题减少枚举数量，避免超时（如，熄灯问题n行的灯要全部灭掉，只取决于第一行如何操作，因为要全灭，第一行的灯是否熄灭只与一、二行有关，若第一行开关情况已经定下，那么第二行必须使得第一行剩下的亮灯熄灭。至此第一行全灭，第二行的开关情况也已经定下，现在要控制第三行使得第二行全部熄灭，所以第三行也定下（第二行的开关不可能由第四行控制）。以此类推……直到第n-1行开关被定下（最后一行也要根据上一行选择按与不按情况）。观察为保证n-2行熄灭而定的n-1按与不按的选择是否满足：最后的第n-1行是否熄灭，如果熄灭则所有灯都熄灭，第一行的操作满足情况。不熄灭则考虑下一种第一行的操作。这样的思路就把n行m列的灯的开关情况：2^(n*m)种，简化为考虑第一行的开关情况：2^m种）


二进制枚举。（以1中题为例）（熄灯问题.cpp文件可以参考二进制常用法）
第一行m个灯的枚举情况，只有两种状态按和不按（开和不开）（按两次就是不按，所以只有两种状态：简化为0,1状态）
 
## 考虑思路一：
0000000（全关，min）………遍历……………1111111（全开，max）（即从数字0到数字2^0 〖+2〗^1+2^2+2^3+⋯+2^(m-1)进行遍历（二进制加一和十进制加一一致））

## 考虑思路二：
第一行的m个开关有2^m种（1-2^m）情况，也就是0——2^m-1的数字进行遍历（恰好能达到2^m种，最小情况是0）
在按照二进制进行移位取&1，把每一位取下来 

（拨钟问题， 熄灯问题）此类问题：其共通点在于：操作对环境的改变是无序的，每个操作都会影响到周围的状态。同时每一种操作都有周期性限制，也即最多需要几次操作，多于这个次数产生循环。

# 二．递归
函数调用通过栈来实现，（调用了这个函数或者运行了某个应用程序，会分配给它一定的内存空间---叫做栈）调用一次栈就增长一层（存放函数形参，执行期间的局部变量，返回地址（函数调用执行完后到哪继续执行）。函数结束时候栈顶放着返回值，然后退栈。）

## 递归作用：
### 1）替代多重循环
Ps：需要n重循环来解决的问题，但是不知道n是多少。
例如N皇后问题

```
#include<iostream>
#include<cmath> 
using namespace std;
int N;
int queenPos[100];
void NQueen(int k);
int main(){
	cin>>N;
	NQueen(0);	
	return 0;
}
void NQueen(int k){
	int i;
	if(k==N){
		for(i=0;i<N;i++)
			cout<<queenPos[i]+1<<' ';
		cout<<endl;
		return;
	}
	for(i=0;i<N;i++){//遍历所有位置的可能 
		int j;
		for(j=0;j<k;j++){//和前面k-1个位置比对有没有冲突，有冲突就提前退出 
			if(queenPos[j]==i||abs(queenPos[j]-i)==abs(k-j)) 
				break;
		}
		if(j==k){//如果没有提前退出，说明有可能的位置可选，那么k+1判断下一个queen的位置 
			queenPos[k]=i;
			NQueen(k+1);
		}
	}
}
```
### 2）解决本来就是用递归形式定义的问题（定义中有循环定义的内容）
Ps：第二条定义中包含第一条定义的内容
```
#include<iostream>
#include<cstdlib>
using namespace std;
//input:* + 11.0 12.0 + 24.0 35.0
//output:1357.000000
double exp(){//读入一个逆波兰表达式并计算其值 
	char s[20];
	cin>>s;//遇到空格结束
	switch(s[0]){
		case '+':return exp()+exp();break;
		case '-':return exp()-exp();break;
		case '*':return exp()*exp();break;
		case '/':return exp()/exp();break;
		default: return atof(s);break; 
	} 
}
int main(){
	printf("%lf",exp());
	return 0;
	return 0;
}
```

### 3）将问题分解为规模更小的子问题进行求解
例如：汉诺塔问题（把n块圆盘从A借助B移动到C，可以等价于把n-1从A-C。也就是要把n化为n-1来解决，进而化成n-2……最后化为1个圆盘直接移动A-C。关键在于n化为n-1，也就是把n变成最底层的1放到C+剩下n-1放到C）


ps:上述题目可以在[百度](http://baidu.com/)中找到题干

如果一个函数执行到底部之前没有调用新的函数，或者递归下一层函数或者return语句，那么它会寻找自己栈中的返回地址，走到地址指向的那步（一般指的是这个函数被执行的起因句）。

