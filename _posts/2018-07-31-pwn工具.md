---
title: pwn tools for pwntools、peda
date: 2018-07-24 16:37:00
tags:
- CTF
categories:
- CTF
---

day1 for tools(pwntools,peda,ida)

# 一、pwntools #
## 1.简介 ##
> pwntools是由Gallopsled开发的一款**专用于CTF Exploit的Python库**，包含了**本地执行、远程连接读写、shellcode生成、ROP链的构建、ELF解析、符号泄漏等众多强大功能**，可以说把exploit繁琐的过程变得简单起来。

## 2.安装 ##
目前pwntools支持python2，如果需要python3，也有一个python3-pwntools。 
Pwntools的主页在[pwntools.com](https://github.com/Gallopsled/pwntools)，Github项目地址为[pwntools](https://github.com/Gallopsled/pwntools#readme)，可以下载到最新的源码用python进行安装
安装方法其实最简单的是使用pip，如下：

    sudo pip install pwntools

虽然Pwntools大部分的功能都是纯python实现的可以直接使用，其还是依赖一些外部的python库例如capstone等，如果使用pip安装的话可以发现安装了不少依赖的库。而如果需要使用其ROP链的构建功能的话，则需要安装libcapstone这个非Python的库，不过需要注意的一点就是要保持python的capstone与这个libcapstone的版本一致否则可能出现API Version冲突的问题，在pip安装时可以指定其版本pip install capstone==3.0.4

## 3.大体构架 ##


- 导入模块：一般使用的话可以直接用from pwn import *将所有的模块导入到当前namespace。
**这条语句还会帮你把os,sys等常用的系统库导入。**

- 常用模块及介绍
	- asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台
	- dynelf : 用于远程符号泄漏，需要提供leak方法[暂时还未接触]
	- elf : 对elf文件进行操作
	- gdb : 配合gdb进行调试
	- memleak : 用于内存泄漏
	- shellcraft : shellcode的生成器
	- tubes : 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE[暂时还未使用]
	- utils : 一些实用的小功能，例如CRC计算，cyclic pattern等

## 4.分模块简介 ##
### 汇编与反汇编 ###
使用asm来进行汇编

    >>> asm('nop')
    '\x90'
    >>> asm('nop', arch='arm')
    '\x00\xf0 \xe3'

可以使用context来指定cpu类型以及操作系统[上述的arch指示了系统构架，cpu类型，比如arm构架是32位精简指令集RISC处理器构架]

    >>> context.arch  = 'i386'  #即Intel 80386，i386通常被用来作为对Intel（英特尔）32位微处理器的统称
    >>> context.os= 'linux' #操作系统
    >>> context.endian= 'little' #小端
    >>> context.word_size = 32 #字长

使用disasm进行反汇编

    >>> print disasm('6a0258cd80ebf9'.decode('hex'))
       0:   6a 02   push   0x2
       2:   58  popeax
       3:   cd 80   int0x80
       5:   eb f9   jmp0x0

注意，asm需要binutils中的as工具[汇编器]辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips[一种RISC处理器]的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils。[包含其他处理器的汇编器]
### shellcode生成器 ###
使用shellcraft可以生成对应的架构的shellcode代码[产生的是汇编代码，如果要产生机器码则要再使用asm]，直接使用链式调用的方法就可以得到

    >>> print shellcraft.i386.nop().strip('\n')
    nop
    >>> print shellcraft.i386.linux.sh()
    /* push '/bin///sh\x00' */
    push 0x68
    push 0x732f2f2f
    push 0x6e69622f
    ...

如上所示，如果需要在64位的Linux上执行/bin/sh就可以使用shellcraft.amd64.linux.sh()，配合asm函数就能够得到最终的pyaload了。
除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。

### ELF文件操作 ###
这个还是挺实用的，**在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置**。

    >>> e = ELF('/bin/cat')
    >>> print hex(e.address)  # 文件装载的基地址
    0x400000
    >>> print hex(e.symbols['write']) # 函数地址
    0x401680
    >>> print hex(e.got['write']) # GOT表的地址
    0x60b070
    >>> print hex(e.plt['write']) # PLT的地址
    0x401680

同样，也可以打开一个libc.so来解析其中system函数的位置:)
甚至可以修改一个ELF的代码

    >>> e = ELF('/bin/cat')
    >>> e.read(e.address+1, 3)  #读取地址e.address+1下的3个字节
    'ELF'
    >>> e.asm(e.address, 'ret')  #在指定地址下汇编
    >>> e.save('/tmp/quiet-cat') #存储成新的文件
    >>> disasm(file('/tmp/quiet-cat','rb').read(1))  #打开这个文件，返回基地址，在基地址处出去第一个字节
    '   0:   c3            ret'

ELF模块在文档里好像还没有写的样子，不过可以从源码中看到一些可用的函数

- asm(address, assembly) : 在指定地址进行汇编
- bss(offset) : 返回bss段的位置，offset是偏移值
- checksec() : 对elf进行一些安全保护检查，例如NX, PIE等。
- disasm(address, n_bytes) : 在指定位置进行n_bytes个字节的反汇编
- offset_to_vaddr(offset) : 将文件中的偏移offset转换成虚拟地址VMA
- vaddr_to_offset(address) : 与上面的函数作用相反
- read(address, count) : 在address(VMA)位置读取count个字节
- write(address, data) : 在address(VMA)位置写入data
- section(name) : dump出指定section的数据


### ROP链生成器 ###

先简单回顾一下ROP的原理，由于NX开启[栈保护机制，NX]不能在栈上执行shellcode，**我们可以在栈上布置一系列的返回地址与参数，这样可以进行多次的函数调用，通过函数尾部的ret语句控制程序的流程，而用程序中的一些pop/ret的代码块(称之为gadget)来平衡堆栈。其完成的事情无非就是放上/bin/sh，覆盖程序中某个函数的GOT为system的，然后ret到那个函数的plt就可以触发system('/bin/sh')。由于是利用ret指令的exploit，所以叫Return-Oriented Programming。（如果没有开启ASLR，可以直接使用ret2libc技术**）

这种技术的难点自然就是如何在栈上布置返回地址以及函数参数了。而ROP模块的作用，就是自动地寻找程序里的gadget，自动在栈上部署对应的参数。

    elf = ELF('ropasaurusrex')
    rop = ROP(elf)
    rop.read(0, elf.bss(0x80))
    rop.dump()
    # ['0x0000:0x80482fc (read)',
    #  '0x0004:   0xdeadbeef',
    #  '0x0008:  0x0',
    #  '0x000c:0x80496a8']
    str(rop)
    # '\xfc\x82\x04\x08\xef\xbe\xad\xde\x00\x00\x00\x00\xa8\x96\x04\x08'

使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。

因为ROP对象实现了__getattr__的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call('read', (0, elf.bss(0x80)))。
通过多次添加函数调用，最后使用str[转换成字符串]将整个rop chain dump出来就可以了。


- call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号)
- chain() : 返回当前的字节序列，即payload
- dump() : 直观地展示出当前的rop chain
- raw() : 在rop chain中加上一个整数或字符串
- search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget。
- unresolve(value) : 给出一个地址，反解析出符号


### 其他 ###
对于整数的pack与数据的unpack，可以使用
**p32/p64:** 打包一个整数,分别打包为32或64位的字符串.

**u32/u64:**解包一个字符串,得到字符串对应整数
[有些不可打印字符的相互转换，或机器码写入时常用]
p对应pack,打包,u对应unpack,解包：
    payload = p32(0xdeadbeef) # pack 32 bits number

另外，在**utils工具中**比较常用的就是**可以使用cyclic pattern来找到return address的位置**，这个功能在gbd peda中也是有的

数据输出方面，如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,用法:

    some_str = "hello, world"
    log.info(some_str)

其中的info代表是log等级，也可以使用其他log等级。


### 样例 ###

    from pwn import *
    context(arch = 'i386', os = 'linux')
    
    r = remote('exploitme.example.com', 31337)
    # EXPLOIT CODE GOES HERE
    r.send(asm(shellcraft.sh()))
    r.interactive()

基本上仿造这个格式就可以写exp[即exploit]了。

> from pwn import *

用来导入pwntools模块



> context(arch = 'i386', os = 'linux')

设置目标机的信息：

context是pwntools用来设置环境的功能。在很多时候，**由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。**

一般来说我们设置context只需要简单的一句话，比如context(os='linux', arch='amd64', log_level='debug')

这句话的意思是： 

1. os设置系统为linux系统，**在完成ctf题目的时候，大多数pwn题目的系统都是linux**

2. arch设置架构为**amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’**
 
3. log_level**设置日志输出的等级为debug**，这句话在调试的时候一般会设置，**这样pwntools会将完整的io过程都打印下来，使得调试更加方**便，可以避免在完成CTF题目时出现一些和IO相关的错误。


> r = remote('exploitme.example.com', 31337)

用来建立一个远程连接，url或者ip作为地址，然后指明端口，这里也可以仅仅使用本地文件,调试时方便:

> r = process("./test")

test即为文件名,这使得改变远程和本地十分方便.



> asm(shellcraft.sh())

asm()函数接收一个字符串作为参数，得到汇编码的机器代码。 
比如：

    >>> asm('mov eax, 0')
    '\xb8\x00\x00\x00\x00'


shellcraft.sh()则是执行/bin/sh的shellcode了

注：shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。
其中的子模块声明架构，比如shellcraft.arm 是ARM架构的，shellcraft.amd64是AMD64架构，shellcraft.i386是Intel 80386架构的，以及有一个shellcraft.common是所有架构通用的。


> r.send()

将shellcode发送到远程连接


> r.interactive()

将控制权交给用户，这样就可以使用打开的shell了

# 二、peda  #
peda是Python Exploit Development Assistance for GDB[增强GDB的功能，比如在调试时自动显示寄存器信息，栈等]
极其不建议用pip安装，据说高版本的gdb不匹配pip安装的peda。[即使安装了，用pip list查看到了peda的包，gdb还是不识别peda的命令]
git虽然慢，但是为了正常使用还是用git吧：

    $ git clone https://github.com/longld/peda.git ~/peda
    $ echo "source ~/peda/peda.py" >> ~/.gdbinit 

常用命令：


- aslr – 显示/设定GDB的ASLR(地址空间配置随机加载)设置[aslr on 就是栈随机化开启] 

- checksec – 检查二进制文件的各种安全选项[包括NX，金丝雀等]

- dumpargs – 函数将要被调用时，显示将要被传入函数的所有参数(默认会在反汇编代码下方自动显示)

- dumprop – 在给定内存范围中Dump出所有ROP gadgets 


- elfheader – Get headers information from debugged ELF file

- elfsymbol – 获取non-debugging symbol信息（plt表中的情况） 

- lookup – Search for all addresses/references to addresses which belong to a memory range

- patch – Patch memory start at an address with string/hexstring/int

- pattern – 生成字符串模板 写入内存 用于定位溢出点

- pshow – Show various PEDA options and other settings

- pset – Set various PEDA options and other settings

- readelf – 获取elf头信息 

- ropgadget – Get common ROP gadgets of binary or library 

- ropsearch – Search for ROP gadgets in memory

- searchmem|find – 在内存中查找字符串，支持正则表达式 

- shellcode – 生成shellcode 

	> 比如shellcdeo generate x86/linux exec

- vmmap – 可以用来查看栈、bss段是否可以执行 

- xormem – XOR a memory region with a key


# 三、补充 #

1. python脚本在linux环境下运行

	- 直接使用python xxxx.py执行。其中python可以写成python的绝对路径。使用which python进行查询。
	- 或在py脚本的头部（第一行）写上#!/usr/bin/python2.7，这个地方使用python的绝对路径[可用which python查看]。此后该脚本路径下就可使用./xxx.py直接执行了

2. System与execev的区别: system =fork+execve+waitpid,**是在单独的进程中执行命令，完了还会回到你的程序中【像是当前父进程中断了，先在子进程中运行你的程序/命令，等待子进程运行完成才继续运行父进程中system之后的代码[子进程还是复制了父进程的栈等内存]】**。而**exec函数是直接在你的进程中执行新的程序，新的程序会把你的程序覆盖**，除非调用出错，否则你再也回不到exec后面的代码，就是说你的程序就变成了exec调用的那个程序了。

3. Gdb 中查看内存的命令：x/<n/f/u> <addr>
n、f、u是可选的参数。

	- n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
	

	- f 表示显示的格式。


		> x 按十六进制格式、d 按十进制格式、u 按十六进制格式无符号整型、o 按八进制格式、t 按二进制格式、a 按十六进制格式、c 按字符格式、f 按浮点数格式……显示变量。
		
		> 如果地址所指的是**字符串，那么格式可以是s**，如果地址是**指令地址，那么格式可以是i**。



	- u 表示从当前地址往后请求的字节数，**如果不指定的话，GDB默认是4个bytes**。
		
		> u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。



	-  < addr >表示一个内存地址。

	**例如：**
	命令：x/3uh 0x54320 
	表示从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。

4. execl()其中后缀"l"代表list也就是参数列表的意思，第一参数path字符指针所指向要执行的文件路径， 接下来的参数代表执行该文件时传递的参数列表：argv[0],argv[1]... 最后一个参数须用空指针NULL作结束。



# 四、术语 #

1.开启NX:linux下开启了NX的以及windows下开启了DEP的程序堆栈是不可执行的

2.数据执行保护（Data Execution Prevention， DEP）安全机制：让攻击者注入的Shellcode无法执行

3.ASLR:是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置



----------

参考链接：

1. http://brieflyx.me/2015/python-module/pwntools-intro/

2. https://blog.csdn.net/qq_29343201/article/details/51337025

3. https://blog.csdn.net/smalosnail/article/details/53149426