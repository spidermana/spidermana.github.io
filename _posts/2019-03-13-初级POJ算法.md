title：初级POJ算法笔记
date: 2019-03-13 15:57:00
tags: 算法

## 基础算法

####  大纲

(1)枚举. (poj1753,poj2965)
(2)贪心(poj1328,poj2109,poj2586)
(3)递归和分治法.
(4)递推.
(5)构造法.(poj3295)
(6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)

#### 枚举

##### （一）POJ1753 Filp game

- 题目大意

  - 有4×4的棋盘，其中的棋子一面是黑的，一面是白的。规定翻转一个棋子的同时也要翻转它的上、下、左、右的棋子，问给定一个棋盘的棋子状态，至少需要翻转多少个棋子，能使得所有棋子都是白的或黑的（面在上）。

- 基本思路：

  - 为什么能用枚举：

    - 首先看到4*4的棋盘很明确，数据很小。
    - 假设枚举，那么多少种可能呢？棋子的状态只有黑或者白，2种。一共16枚棋子，那么只有2^16=65536种棋盘的状态，这样看来从输入的棋盘状态为起始，遍历剩下的65536-1=65535种状态就够了。因此枚举时间复杂度可以过得去【O(1e8)为1000ms的上限】

  - 如何遍历棋盘的状态呢？

    - （搜索）方法一：

      - 考虑翻棋子的最多的次数只能是16次，再翻就有棋子被翻两次了，相当于那个棋子没翻过
      - 因此总的状态数为：![1552529614628](C:\Users\asus\spidermana.github.io\assets\img\1552529614628.png)【和前面分析的一致】
      - 对上式的解释为：不翻棋子有C(0,16)种情况，翻一枚棋子有C(1,16)种情况，翻二枚棋子有C(2,16)种情况【从16枚棋子中选2枚翻，无序】……
      - 因此我们可以遍历从起始状态起，不翻棋子能不能使得所有棋子都是白的或黑的。翻一枚棋子能不能使得所有棋子都是白的或黑的，翻两枚棋子能不能使得所有棋子都是白的或黑的……
      - 首先成功全白/全黑的翻棋数，就是最小步数。翻16个都不满足即输出Impossible

    - （枚举）方法二：

      - 在下面叙述。

      ```c++
      bool find(int n,int x,int y){//从(x,y)位置起【不包括该位置】再翻n次棋子
      //棋盘共有C(0,16)+C(1,16)+……+C(16,16)=2^16=65536可以枚举 
      //不翻、翻一枚、翻两枚、……翻16枚 
      	if(n==0){//终止条件 
      		return check(); //判断是否全黑或者全白
      	}
      	y++;
      	if(y==4){
      		x++;
      		y=0;	
      	} 
      	for(int i=x;i<4;i++){//翻n次，每次翻哪个棋子 
      		for(int j=y;j<4;j++){
      			flip(i,j);//翻这个棋子 
      			if(find(n-1,i,j))
      				return true; 
      			flip(i,j);//不翻这个棋子，把这个翻机会留个后面的棋子
      		}
      		y=0;
      	}
      	return false;
      }
      ```

  - 翻棋子的技巧

    - 由于棋子都只有黑、白两面，可以用0、1表示，因此可以位压缩成一个数字来进行判断，翻棋子的操作可使用位运算，即异或【和0异或表示不动、和1异或表示翻面/取反】。以下有两种方法：
      - 方法一：每一行压缩一个数字，对第i行第j列棋子进行翻转，比如j=2，那么第i-1行以及第i+1行的棋子应该和4（0100）相异或（与1异或切换状态，与0异或不改变），而第i行棋子应与14（1110）相异或。
      - 方法二：一个棋盘压缩成一个数字。只有16个棋子，一个int型变量就能存下这16个0/1了，所以可以直接压缩成一个数字。如翻i=2,j=2位置的棋子，则与20032（0100 1110 0100 0000）相异或。

  - 注意点：搜索过程中要注意搜过的位置不需要再搜了，所以在函数里控制一下起始搜索位置i，j。如果没搜成功，把棋子再翻（flip）一遍，这样就能恢复原样了。不需要memcpy。【每次搜索如果该棋盘数目不成，返回到调用者时棋盘还是初始状态，因为都翻回来了】

  - 枚举方法：将棋盘压缩成一个数，如果不能压成一个int的话这题当然也用不了枚举。需要考虑的是如何实现C(i，16)，也就是16个选i个(*i*∈[0,16])。

    考虑我选哪几个棋子也表示成0/1，选择翻转的棋子我用1表示，比如要选择第1个、第3个、第5个和第6个，那就是11 0101的状态。这样枚举就很方便了，枚举值范围0x0000～0xFFFF【这范围内有几个1就表示翻几个棋子。0-FFFF就是翻0个-翻16个棋子的所有可能翻的方法=65536种】

```c++
#include<iostream>
#include<stdio.h>//getchar()定义 
using namespace std;
int map[5]={0,0,0,0,0};//表示棋盘图，map[i]表示第i行
int flipnum[]={12,14,7,3};//1100、1110,0111,0011 
int updown[]={8,4,2,1};//1000、0100、0010、0001 
void flip(int i,int j){//翻转就是取反，即与1异或 
	map[i]^=flipnum[j];
	if(i-1>=0){
		map[i-1]^=updown[j];
	}
	if(i+1<=3){
		map[i+1]^=updown[j];
	}
}
bool check(){
	if(map[0]==0||map[0]==15){//棋盘全为黑/白
		if(map[0]==map[1]&&map[1]==map[2]&&map[2]==map[3])
			return true;
	}
	return false;
}
bool find(int n,int x,int y){//棋盘共有C(0,16)+C(1,16)+……+C(16,16)=2^16=65536可以枚举 
//不翻、翻一枚、翻两枚、……翻16枚 
	if(n==0){//终止条件 
		return check();
	}
	y++;//从下一个位置开始决定翻不翻
	if(y==4){
		x++;
		y=0;	
	} 
	for(int i=x;i<4;i++){//翻n次，每次翻哪个棋子 
		for(int j=y;j<4;j++){
			flip(i,j);//翻这个棋子 
			if(find(n-1,i,j))//减少可翻棋数
				return true; 
			flip(i,j);//恢复，不翻这个棋子
		}
		y=0;//遍历完一行，要从下一行的第0列开始
	}
	return false;//如果当前n种翻棋数，不能成功则返回上一级【false】
    //上一级会恢复当前翻的棋子，考虑下一个位子的翻不翻棋子。
}
void GetTime(){
	for(int i=0;i<=16;i++){//遍历翻的次数 
		if(find(i,0,-1)){//找到最小的成功的翻棋数。若i成功，i-1及以下一定不成功。
			cout<<i<<endl;
			return;
		}
	} 
	cout<<"Impossible"<<endl;
} 
int main(){
	for(int i=0;i<4;i++){
		for(int j=0;j<4;j++){//map[i]表示第i行棋子的状态
			map[i]<<=1;
			char ch=getchar();
			if(ch=='b')//1表示黑，0表示白
				map[i]|=1; 
		} 
		getchar();//换行消除 
	}	
	GetTime();
	return 0;
}
```

参考链接:https://www.cnblogs.com/BlackStorm/p/5231470.html

##### （二）POJ2965

- 题目大意
  - 一个冰箱上有4*4共16个开关，改变任意一个开关的状态（即开变成关，关变成开）时，此开关的同一行、同一列所有的开关都会自动改变状态。要想打开冰箱，要所有开关全部打开才行。+表示关闭，-表示打开。输出使冰箱打开所需要执行的最少操作次数以及所操作的开关坐标。
- 基本思路
  - 和上一题几乎一样。不同点在于：
    - 改变一个开关，同行同列都反转状态
    - 成功状态只有一个，map[1]=map[2]=map[3]=map[4]=15
    - 需要记录操作开关坐标

```c++
// The Pilots Brothers' refrigerator
#include<iostream>
#include<vector>
#include<stdio.h> 
using namespace std;
int map[6]={0,0,0,0,0,0};
int colflip[]={0,8,4,2,1};//1000,0100,0010,0001
vector<int> seq;
void change(int i,int j){
	map[i]^=15;//^1111，同行全部反转
	for(int k=1;k<5;k++){ //同列全部反转
		if(k!=i)//避免对中心子重复翻 
			map[k]^=colflip[j];
	}
}
bool check(){
	if(map[1]==15&&map[1]==map[2]&&map[2]==map[3]&&map[3]==map[4])
		return true;
	return false;
}
bool GetMinTime(int n,int x,int y){
	if(n==0){
		return check();	
	}
	y++;//1~4
	if(y==5){
		x++;
		y=1;
	}
	for(int i=x;i<5;i++){
		for(int j=y;j<5;j++){
			change(i,j);
			seq.push_back(i*10+j);
			if(GetMinTime(n-1,i,j)){
				return true;
			}	
			seq.pop_back();
			change(i,j);
		}
		y=1;
	}
	return false;
} 
int main(){
	for(int i=1;i<5;i++){
		for(int j=1;j<5;j++){
			map[i]<<=1;
			if(getchar()=='-')//减号表示open 
				map[i]|=1;	
		}
		getchar();//换行 
	}
	for(int i=0;i<=16;i++){
		while(seq.size()!=0)
			seq.pop_back();
		if(GetMinTime(i,1,0)){
			cout<<i<<endl;
			break;
		}
	}
	int size=seq.size();
	for(int i=0;i<size;i++){
		cout<<seq[i]/10<<" "<<seq[i]%10<<endl; 
	}	
	return 0;
}
```

##### （三）POJ1328

- 题目大意：x轴是海岸线，y轴正方向部分是海。海上有很多小岛。现在要在海岸线上建立雷达【也就是在x轴上建立雷达】，使得建立最少的雷达数目【雷达的有效范围为半径d的圆】，但是能覆盖到所有岛屿。

- 解题思路：

  - 这很明显是一个贪心题目，要求雷达数最少。我们就尽量让每个雷达覆盖最多的岛屿

  - 对于一个岛屿P，要建立d半径的雷达可以覆盖到P。那么只能在A和B点之间建立。

    ![](C:\Users\asus\spidermana.github.io\assets\img\radar.png)

  - 对每个岛屿计算这样的AB线段。如果线段有重复，则说明，这两个岛屿可以公用雷达。

  - 既然要贪心，我们就需要排序。如果我们以线段左端点排序【左端点大的排在前面，下标小】。依次取出每个线段以比较。取出的第i条线段和取出的第i+1线段，一定满足line[i].left>line[i+1].left。

  - 现在我们要满足两个线段有交集，那么我们必须，要求W点要在Q点的右边，这样line[i+1]一定可以包含住Q点。那么line[i]和line[i+1]就有交集。【line[i].left>line[i+1].left + W大于等于Q】

    ![](C:\Users\asus\spidermana.github.io\assets\img\radar2.png)

  - 可以知道如果W<Q，那么肯定要增加一个雷达了。因为两个线段已经没有交集了。只能多一个雷达以覆盖line[i+1]

```c++
//n是岛屿数、d是雷达半径 
//n行岛屿坐标【都在海上】 
//0,0表示结束cases 

//m表示雷达数，初始为m=n 
//确定每个岛屿的雷达x轴范围，以起点线段排序
//如果某线段终点在下一个线段的起点和中间之间，m--
//遍历下一个不可行线段的终点 
//goto以后不能出现新定义的变量。 
#include<iostream>
#include<stdio.h>
#include<cmath>
#include<algorithm>
using namespace std;
//贪心最关键是排序，思考为什么要这样排序才可以限制住 
struct Line{
	double r;//一定要注意是double类型！！！ 
	double l;
}line[1005];
bool cmp(Line a,Line b){
	if(a.l>b.l){
		return true;
	}
	else if(a.l==b.l){//小的范围可以控制住的，大的范围肯定可以控制住。 
		if(a.r<b.r) //但是分析一下这道题对同右界的情况，其实排序无所谓。 
			return true;
	}
	return false;
}
int main(){
	int n,d;
	int casenum=0;
	while(cin>>n>>d){
		bool flag=true;
		casenum++;
		int radar=1;
		int islandx,islandy;
		double stand;
		bool add=0;
		if(n==0&&d==0)
			break;
		for(int i=0;i<n;i++){
			cin>>islandx>>islandy;
			if(islandy>d){
				flag=false;
			}
			line[i].r=islandx+sqrt(d*d-islandy*islandy);
			line[i].l=islandx-sqrt(d*d-islandy*islandy);
		}
		if(flag==false){
			cout<<"Case "<<casenum<<": -1"<<endl;
			goto part2;
		}
		sort(line,line+n,cmp);
		stand=line[0].l;
		for(int i=1;i<n;i++){ 
			if(line[i].r<stand){
				radar++;
				stand=line[i].l;
			}
		}
		cout<<"Case "<<casenum<<": "<<radar<<endl;
	part2:
		getchar();
		getchar();
	}
}
```

##### （三）POJ2586

- 题目大意：

  - 有个公司数据丢了。但是知道一些信息，要在满足这些信息的情况下，求这个公司全年盈利状况可能的最大利润。亏损就输出“deficit”。信息如下：

    - **每**连续5个月的报表都是亏损，共8个这样的报表 【1-5、2-6、3-7、4-8、5-9、6-10、7-11、8-12】
    - 对于每一个月，如果这个月盈利则盈利S，如果亏空则亏空D【是一个定数】 

  - 解题思路：

    - 暴力：每个月只有两种状态，一种亏损，一种盈利=2^12=4096，遍历所有情况，找到最大利润值

    - 贪心： 要在保证连续5个月都亏损的前提下，使得每5个月中亏损的月数最少。若每五个月都要亏损，则说明五个月中一定要有一个d。因此从ssssd开始增加d的个数。

      > 状态1:  ssssd,ssssd,ss    如果要满足每5个月亏损则d>4s     赢利10个月，盈利额=10s-2d
      > 状态2:  sssdd,sssdd,ss   如果要满足每5个月亏损则2d>3s    赢利8个月，盈利额=8s-4d
      > 状态3:  ssddd,ssddd,ss   如果要满足每5个月亏损则3d>2s    赢利6个月，盈利额=6s-6d 
      > 状态4:  sdddd,sdddd,sd   如果要满足每5个月亏损则4d>s     赢利3个月，盈利额=3s-9d
      > 状态5:  ddddd,ddddd,dd  4d<s     无赢利

  - 实现：

    - 贪心

    ```c++
    //在保证连续5个月都亏损的前提下，使得每5个月中亏损的月数最少。
    //每五个月都要亏损，则说明五个月中一定要有一个d。
    //因此从ssssd开始增加d的个数 
    //        x=1:  ssssd,ssssd,ss    d>4s     赢利10个月:10s-2d
    //        x=2:  sssdd,sssdd,ss    2d>3s    赢利8个月:8s-4d
    //        x=3:  ssddd,ssddd,ss    3d>2s    赢利6个月:6s-6d 
    //        x=4:  sdddd,sdddd,sd    4d>s     赢利3个月:3s-9d
    //        x=5:  ddddd,ddddd,dd    4d<s     无赢利
    #include<iostream>
    using namespace std;
    int main(){
    	int s,d;
    	long long int earnings;
    	while(cin>>s>>d){
    		if(d>4*s){
    			earnings = 10*s-2*d;
    		}
    		else if(2*d>3*s){
    			earnings = 8*s-4*d;
    		}
    		else if(3*d>2*s){
    			earnings = 6*s-6*d;
    		}
    		else if(4*d>s){
    			earnings = 3*s-9*d;
    		}
    		else if(4*d<s){
    			earnings = -1;
    		}
    		if(earnings<0)
    			cout<<"Deficit"<<endl;
    		else
    			cout<<earnings<<endl;
    	}
    	
    } 
    ```

    - 暴力

    ```c++
    //每连续5个月的报表就是亏损，共8个这样的报表 
    //要统计全年盈利状况，对于每一个月来说
    //如果盈利则盈利S，如果亏空则亏空D【是一个定数】 
    //每个月只有两种状态，一种亏损，一种盈利=2^12=4096
    //可以暴力、可以贪心 
    #include<iostream>
    #include<climits>
    using namespace std; 
    int month[13];
    int s,d;
    long long int maxMoney;
    void GetSD(int type){
    	for(int i=1;i<=12;i++){
    		int temp=type&0x01;
    		if(temp){
    			month[i]=s;
    		}
    		else{
    			month[i]=-d;//deficit是负的啊！！ 
    		}
    		type=type>>1;
    	}
    	
    }
    bool EightDeficit(int type){
    	long long tot=0;
    	for(int i=1;i<=8;i++){
    		long long tot=0;
    		for(int j=0;j<5;j++){
    			tot+=month[i+j];
    		}
    		if(tot>=0)
    			return false;
    	}
    	return true;
    }
    int main(){
    	while(cin>>s>>d){
    		maxMoney=INT_MIN;
    		for(int i=0;i<4095;i++){//枚举12个月的盈亏情况，每个月就两种s或者d。=2^12种 
    			GetSD(i);
    			if(EightDeficit(i)){
    				long long int tot=0;
    				for(int j=1;j<=12;j++){
    					tot+=month[j];
    				}
    				maxMoney=maxMoney>tot?maxMoney:tot;
    			}
    		} 
    		if(maxMoney<0){
    			cout<<"Deficit"<<endl; 
    		}
    		else
    			cout<<maxMoney<<endl;
    	}
    } 
    ```

    

## 模拟题

##### （一）POJ1068

- 题目大意：有个括号序列，有两种编码格式P模式和W模式，给出P模式，写一个程序将P模式转换成W模式 

  - P模式：每个右括号位置有一个数，这个数表示这个右括号左边【从头起】有几个左括号
  - W模式：每个右括号位置有一个数，这个数表示从与这个右括号匹配的左括号起到这个右括号为止【包括这个右括号】一共有几个右括号。

- 解题思路：先将P模式转化成括号字符串【vec】，再将括号字符串转化成W模式【栈模拟括号匹配，map记录匹配左右括号的下标】。

  ```c++
  //P模式：每个右括号位置有一个数，这个数表示这个右括号左边【从头起】有几个左括号
  //W模式：每个右括号位置有一个数，这个数表示从与这个右括号匹配的左括号起到这个右括号为止【包括这个右括号】一共有几个右括号 
  //写一个程序将P模式转换成W模式 
  #include<iostream>
  #include<vector>
  #include<map>
  #include<stack>
  using namespace std;
  int P[25];
  int W[25]; 
  vector<char> vec;//存储P模式转换后的括号字符串 
  map<int,int> mat;//存储匹配左右括号的下标 
  struct item{//下标为ind处的括号par 
  	char par;
  	int ind;
  	item(){}
  	item(int ii,char pp):par(pp),ind(ii){}
  };
  stack<item> mystack;//匹配时用的栈 
  void  GetParentheses(int n){
  	int nowleft=0;
  	for(int i=0;i<n;i++){
  		if(i!=0)
  			nowleft = P[i]-P[i-1];
  		else
  			nowleft = P[i];
  		for(int j=0;j<nowleft;j++)
  			vec.push_back('(');
  		vec.push_back(')');
  	}
  }
  void GetMatch(int n){
  	while(!mystack.empty()){
  		mystack.pop();
  	}
  	int size= vec.size();
  	for(int i=0;i<size;i++){
  		if(vec[i]=='(')
  			mystack.push(item(i,'('));
  		else{
  			item it=mystack.top();
  			mystack.pop();
  			mat[i] = it.ind;//右括号下标小的先来 
  			//i是右括号下标，mat[i]是匹配的左括号下标 
  			//cout<<i<<" "<<mat[i]<<endl;
  		}
  	}
  }
  void Ans(){
  	map<int,int>::iterator iter;
  	int vecsize =vec.size();
  	for(iter=mat.begin();iter!=mat.end();iter++){
  		int sta = iter->second;//从左括号下标 
  		int tail = iter->first;//到右括号下标 
  		int count=0;
  		for(int j=sta;j<tail;j++){
  			if(vec[j]=='(')
  				count++;
  		} 
  		cout<<count<<" ";
  	}
  	cout<<endl;
  }
  int main(){
  	int t;
  	cin>>t;
  	while(t--){
  		int n;
  		cin>>n;
  		vec.erase(vec.begin(),vec.end());
  		mat.erase(mat.begin(),mat.end());
  		for(int i=0;i<n;i++){
  			cin>>P[i];
  		}
  		GetParentheses(n);
  		GetMatch(n);
  		Ans();
  		
  	}
  } 
  ```

  

## 图算法

#### 知识点复习

##### Floyd：

- 适用范围：适合**多源**之间【两两节点】最短路径。稠密图效果最佳。**边权可正可负**。

- 思路：不断加入中转节点。最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。

- 理解：如果要让任意两点（例如从顶点a点到顶点b）之间的路程变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a->k->b，才可能缩短原来从顶点a点到顶点b的路程。有时候不只通过一个中转点，而是经过两个点或者更多点中转会更短，即a->k1->k2b->或者a->k1->k2…->k->i…->b。

- 时间复杂度：O(n^3);

- 实现：

  - 每更新一次e[i] [j]说明，再加入了一个中转点

  - for(k=1;k<=n;k++) //中转点

    ​    for(i=1;i<=n;i++)

    ​        for(j=1;j<=n;j++)

    ​            if(e[i] [j]>e[i] [k]+e[k] [j])

    ​                 e[i] [j]=e[i] [k]+e[k] [j];

##### Bellman-Ford

- 适用范围：带权有向图中**单源最短路径**，**带有负权边可以但不可带有负权环**。【得到单源到其他每个点的最短路径】、**可以判断是否有负环**

- Bellman-Ford和Dijkstra的区别：

  - Bellman-Ford 算法和 Dijksrtra 算法同为解决单源最短路径的算法。Dijkstra 算法要求图 G 中边的权值均为非负，而 Bellman-Ford 算法能适应一般的情况（即存在负权边的情况）
  - 对于图 G = (V, E)，Bellman-Ford 算法基于动态规划设计，实现的时间复杂度为 O(V*E)。Dijkstra 算法基于贪心算法设计，普通实现的时间复杂度为 O(V^2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O(E + VlogV)

- 算法思路：

  - 对于图 G = (V, E)【顶点为V，边为E】创建<u>源顶点 v 到图中所有顶点的距离的集合</u> distSet，为图中的所有顶点指定一个距离值，**初始均为 Infinite，源顶点距离为 0**
  - 计算最短路径，**执行 V - 1 次遍历**，**每次遍历的内部，遍历所有的边**【即对于每条边要遍历/处理V-1次】：对于每一条边e(u, v)，如果**Distant[u] + w(u, v) < Distant[v]**，则另Distant[v] = Distant[u]+w(u, v)。【第一次迭代保证给所有最短路径最多只有1条边、第二次迭代保证给所有最短路径最多只有2条边、……】
  - **检测图中是否有负权边形成了环，遍历图中的所有边**，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环。【distance（v） > distance(u) + w(u,v)，若返回false，存在环】

- 时间复杂度：对于带权有向图 G = (V, E)，Bellman-Ford 算法实现的**时间复杂度为 O(V*E)**。

- 算法实现：

  ```c++
  typedef struct Edge //边  
  {  
      int u, v;  
      int cost;  
  }Edge;  
     
  Edge edge[N];  
  int dis[N], pre[N];  
     
  bool Bellman_Ford()  
  {  
      for(int i = 1; i <= nodenum; ++i) //初始化  
          dis[i] = (i == original ? 0 : MAX);  
      for(int i = 1; i <= nodenum - 1; ++i)  //迭代V-1次
          for(int j = 1; j <= edgenum; ++j)  
              if(dis[edge[j].v] > dis[edge[j].u] + edge[j].cost) //松弛 
              {  //注意顺序，cost是u->v。v为终点
                  dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;  
                  pre[edge[j].v] = edge[j].u;  //记录最短路径，每个点的前驱节点
              }  
      bool flag = 1; //判断是否含有负权回路  
      for(int i = 1; i <= edgenum; ++i)  
          if(dis[edge[i].v] != INT_MAX && dis[edge[i].v] > dis[edge[i].u] + edge[i].cost) //成立，则还能松弛
          {  //上述条件要是还成立，说明dis[edge[i].v]还能更小。但是我们已经迭代了V-1次了
              flag = 0;  //故存在负环
              break;  
          }  
          return flag;  
  }  
  ```

##### Spfa

- 使用范围：是 Bellman-Ford算法的队列优化算法，通常用于**求含负权边的单源最短路径**【不可有负环】，以及**判负权环**。
- 算法思路：
- 时间复杂度：SPFA 最坏情况下复杂度和朴素 Bellman-Ford 相同，为 O(VE)
- 算法实现：

##### Dijkstra

- 使用范围：单源最短路径问题，一个顶点到其余各顶点的最短路径算法，不可存在负权边

  - 为了避免最坏情况的出现，在正权图上应使用效率更高的Dijkstra算法。【一个实现的很好的 Dijkstra 算法比 Bellman-Ford 算法的运行时间要低】

- 算法思路：

  - Dijkstra算法采用的是一种贪心的策略。
  - 声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T。【两个集合一个dis，一个T】
  - 初始过程：原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
  - **选择dis数组的最小值**，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 
  - 看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 
  - 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

- 时间复杂度：

  - O(E+VlgV)(用堆优化后)
  - O(V²)(未优化)

- 算法实现：

  - 未优化O（V²）

  ```c++
  #include<stdio.h>
  #include<stdlib.h>
  #define max1 10000000  //原词条这里的值太大，导致溢出，后面比较大小时会出错
  int a[1000][1000]; //存储图
  int d[1000];//d表示源节点到该节点的最小距离
  int p[1000];//p标记访问过的节点【已知最小路径的点】
  int i, j, k;
  int m;//m代表边数
  int n;//n代表点数
  int main()
  {
      scanf("%d%d",&n,&m);
      int    min1;
      int    x,y,z;
      for(i=1;i<=m;i++)
      {
          scanf("%d%d%d",&x,&y,&z);
          a[x][y]=z;
          a[y][x]=z;
      }
      //初始过程
      for( i=1; i<=n; i++)
          d[i]=max1;
      d[1]=0;
      for(i=1;i<=n;i++)
      {
          min1 = max1;
          //找到当前不在p集合的d[]最小值，作为下一个访问节点，用k标记
          for(j=1;j<=n;j++)
              if(!p[j]&&d[j]<min1)//不在p中的节点
              {
                  min1=d[j];
                  k=j;
              }
          p[k] = 1; //置1表示第k个节点已经访问过了：将k节点加入p集合
          for(j=1;j<=n;j++)//用这个k节点松弛不在p集合中的节点【且这个节点和k有边】
              if(a[k][j]!=0&&!p[j]&&d[j]>d[k]+a[k][j])
                  d[j]=d[k]+a[k][j];
      }
      //最终输出从源节点到其他每个节点的最小距离
      for(i=1;i<n;i++)
          printf("%d->",d[i]);
      printf("%d\n",d[n]); 
      return 0;
  }
  ```

  - 堆优化：
    1. 队列操作的地方，首先就是搜索刚开始，要为起点赋初始值，此时必须将起点加入优先队列中。该队列元素的节点编号为起点的编号，该节点当前与起点的距离为0。
    2. 那么如果一个节点到起点的最短距离通过其他的运算流程发生了变化，那么如何处理队列中的那个已经存入的元素？
    3. 事实上，你不需要理会队列中的元素，而是再存入一个就行了。因为如果要发生变化，只能将节点与起点之间的距离变得更小，而优先队列恰好是先让最小的那个弹出。
    4. 因此，轮到某一个队列元素弹出的时候，如果有多个元素的节点编号相同，那么被弹出的一定是节点编号最小的一个。等到后面再遇到这个节点编号的时候，我们只需要将它忽略掉就行了【即使不忽略掉，那么这个节点也不能更加松弛其他节点，所以无所谓】

```c++
//堆找出最值的时间为O(logn)
#include <iostream>  
#include <cstdio>  
#include <queue>  
#include <vector>  
using namespace std;  
const int Ni = 10000;  
const int INF = 1<<27;  
struct node{  
    int x,d;  
    node(){}  
    node(int a,int b){x=a;d=b;}  
    bool operator < (const node & a) const  
    {  
        if(d==a.d) return x<a.x;  
        else return d > a.d;//d>a.d则交换，因此是小的先出堆  
    }  
};  
//邻接表
vector<node> eg[Ni]; //eg[i]存储起点为i的所有边，eg[i][j].x为起点为i的第j条边的终点为x，权值为d
int dis[Ni],n;  
void Dijkstra(int s)  
{  
    int i;  
    for(i=0;i<=n;i++) dis[i]=INF;  
    dis[s]=0;  
    //用优先队列优化  
    priority_queue<node> q; //取出最小值
    q.push(node(s,dis[s])); //初始放入起点节点
    while(!q.empty())  
    {  
        node x=q.top();q.pop(); //得到队列最小值
        for(i=0;i<eg[x.x].size();i++)  //由此更新出边的所有节点
        {  
            node y=eg[x.x][i];  
            if(dis[y.x]>x.d+y.d)  
            {  
                dis[y.x]=x.d+y.d; 
                q.push(node(y.x,dis[y.x])); //如果松弛了，那么这个更小路径就可以去更新其他点
            }  
            //如果没有松弛，那不需要等待出堆更新其他节点，反正没有变化，没有可能通过它中转更小
        }  
    }  
}  
```

##### 最小生成树（MST）Prim算法——加点法

- 使用范围：加权连通图【无向的，对于最小生成树的定义而言，有向没什么意义】

- 算法思想：每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。

  - 建立两个集合，图的所有顶点集合为V；初始令集合u={s},v=V−u【直到u中包含所有的点】
    在两个集合u,v能够组成的边中，选择一条代价最小的边(ui,vi)，加入到最小生成树中，并把vi并入到集合u中。

    重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止

    ![最小生成树Prim](https://img-blog.csdn.net/20160714161107576)

- 时间复杂度：贪心的思想，O（n²）【两重for循环】

- 算法实现：

  - 为了便于选中当前权值最小的边的节点，需要建立两个数组closest和lowcost，**对于某个未选中的节点j**，lowcost[j]存储的是节点j与当前已选节点相连【u集合中所有的点】的最小权值（<u>lowcost[j]==0表示节点j已被选</u>），closest[j]存储lowcost[j]对应的连接点

  - ```c++
    //存储图，邻接矩阵的数据类型
    #define MAXV 50 //最大顶点数
    typedef struct
    {
    	int no;//顶点编号
    	//InfoType info;//顶点的其他信息
    }VertexType;//顶点类型
    typedef struct
    {
    	int edges[MAXV][MAXV];//邻接矩阵的边数组
    	int n, e;//顶点数，边数
    	VertexType vexs[MAXV];//存放顶点信息
    }MGraph;//图邻接矩阵类型
    ```

  - ```c++
    void Prim(MGraph g, int v)//普利姆算法（参数：邻接矩阵，起点（即第一个生成的点，可随便取））
    {   //lowcost:j到u集合的最短边权、closest最短边的另一个顶点
    	int lowcost[MAXV], closest[MAXV], i, min, j, k;
     
    	//v作为起始顶点，只有它在u集合中，因此j到u集合的最短边一定是和v的链接边
    	for (i = 0; i < g.n; i++)//赋初值
    	{//将closest数组都赋为第一个节点v，lowcost数组赋为第一个节点v到各节点的权重
    		closest[i] = v;
    		lowcost[i] = g.edges[v][i];
    	}
     
    	for (i = 1; i < g.n; i++)//接下来找剩下的n-1个节点（g.n是图的节点个数）
    	{
     
    		//找到一个节点，该节点到已选节点中的某一个节点的权值是当前最小的
            //INF表示正无穷（每查找一个节点，min都会重新更新为INF，以便获取当前最小权重的节点）
    		min = INF;
    		for (j = 0; j < g.n; j++)//遍历所有节点
    		{
    			if (lowcost[j] != 0 && lowcost[j] < min)//若该节点还未被选【被选在u集合中的点的lowcost值为0】且到u集合中权值更小
    			{
    				min = lowcost[j];//更新min的值
    				k = j;//记录当前最小权重的节点的编号
    			}
    		}
     
    		//输出被连接节点与连接节点，以及它们的权值
    		//printf("边(%d,%d)权为:%d\n", closest[k], k, min);
     
    		//更新lowcost数组，closest数组，以便生成下一个节点
    		lowcost[k] = 0;//表明k节点已被选入u集合(作标记)
    		//选中一个节点完成连接之后，作数组相应的调整
    		for (j = 0; j < g.n; j++)//遍历所有节点
    		{
    			/* if语句条件的说明：
    			  （1）g.edges[k][j] != 0是指k！=j，即跳过自身的节点
    			  （2）这里默认设图中的边的权值大于0，因此egdgs[][]>0,因此已选节点j是不满足g.edges[k][j] < lowcost[j]，则会被跳过。【也可以在if语句条件中增加跳过所有的已选节点的条件（即lowcost[j] == 0）】*/
                //跳过已选节点【lowcost[j]==0和自身】，更新不在u集合的节点的lowcost
                //加入k节点后，更新现在j节点到u集合中的最短边和对应另一顶点
    			if (g.edges[k][j] != 0 && g.edges[k][j] < lowcost[j])
    			{
    				//更新lowcost数组，closest数组
    				lowcost[j] = g.edges[k][j];
    				closest[j] = k;
    			}
    		}
    	}
    }
    ```

    

##### 最小生成树Kruskal算法——加边法

- 使用范围：加权连通图【无向的，对于最小生成树的定义而言，有向没什么意义】

- 算法思想：初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

  - 把图中的所有边按代价从小到大排序； 

  - 把图中的**n个**顶点看成独立的n棵树——组成森林； 

  - 按权值从小到大选择边，**所选的边连接的两个顶点ui,vi应属于两颗不同的树**【并将这两颗树合并作为一颗树】，则成为最小生成树的一条边。【如果两个顶点在一颗树，则会形成环】 

  - 重复(3),直到所有顶点都在一颗树内或者**有n-1条边为止**。

    ![最小生成树kruskal过程](https://img-blog.csdn.net/20160714144315409)

- 算法实现：

  - ```
    1、利用优先级队列将权值小的边放到队列最前，优先出对，保证了每次选择的都是权值最小的边。
    
    2、利用并查集的查找及结合把同处同一连通分量中的顶点连到同一父节点下。这样，每次判断是否构成回路，只要判断父节点是否相同的即可。
    3.并查集：int find(int x) {return p[x]==x?x:p[x]=find(p[x]);}
    //以上代码实现了根据x找到x所在树的根节点，p[x]表示:找x的父节点/祖先节点
    //find(p[x])最终递归到p[x]=x=树根，返回使得p[x]=find(p[x])=树根：这顺便把遍历过的结点都改成树根的儿子，下次查找就会快很多
    //如果p[x]=x，说明x本身就是树根，因此返回x；否则返回x的父亲p[x]所在树的根结点。
    ```

  - ```c++
    #include <iostream>
    #include <queue>
    using namespace std;
    #define max 200
    
    int MST; //  最小生成树
    int Nodenum;
    int father[max];
    struct edge {
      int from;
      int to;
      int cost;
      friend bool operator < (const edge& a, const edge& b) {
        return a.cost > b.cost;
      }
    };
    // to find the minimal distance of edge.
    priority_queue<edge> SQ;
    
    int find(int x) {
      return x == father[x] ? x : find(father[x]);
    }
    int Kruskal() {
      MST = 0;
      for (int i = 1; i <= Nodenum; i++) {
        father[i] = i;
      }
      int num = 0;
      while (!SQ.empty() && num != Nodenum - 1) {
        edge temp = SQ.top();
        SQ.pop();
        int father_x = find(temp.from);
        int father_y = find(temp.to);
        if (father_x != father_y) {
          father[father_y] = find(father[father_x]);
          MST += temp.cost;
          num++;
        }
      }
      /**
       *  Let every index has their final father.
       */
      for (int i = 1; i <= Nodenum; i++) {
        father[i] = find(father[i]);
      }
      return MST;
    }
    bool judge() {
      int flag = father[1];
      for (int i = 2; i != Nodenum + 1; i++) {
        if (flag != find(father[i])) {
          return false;
        }
      }
      return true;
    }
    int main() {
      int edgeNum; //  边总数
      cin >> Nodenum;
      cin >> edgeNum;
      while (!SQ.empty()) {
        SQ.pop();
      }
      while (edgeNum--) {
        int from; int to; int cost;
        cin >> from >> to >> cost;
        edge a;
        a.from = from;
        a.to = to;
        a.cost = cost;
        SQ.push(a);
      }
      int MST = Kruskal();
      if (judge()) {
        cout << MST << endl;
      } else {
        cout << "Don't exist!" << endl;
      }
      return 0;
    }
    ```

- Prim算法和Kruskal算法的比较

  - 稠密图：边数很多，边数接近于完全图
  - Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣
  - 因此边多的图用Prim【毕竟是加点法，考虑的点少】
  - 边少的图，相对节点多，用Kruskal【毕竟是加边法，考虑的边少，速度快】

##### 拓扑排序

- 什么是拓扑排序？

  - 对于任何有向图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向图而言<u>可能存在多个这样的结点排序</u>）。该排序满足这样的条件——对于图中的任意两个结点*u*和*v*，<u>若存在一条有向边从*u*指向*v*，则在拓扑排序中*u*一定出现在*v*前面</u>。【但是如果在排序中a排在b的前面，可能a到b不存在边】
  - 拓扑排序主要用来解决有向图中的依赖解析（dependency resolution）问题。
  - 举例来说，如果我们<u>将一系列需要运行的任务构成一个有向图</u>，图中的<u>有向边则代表某一任务必须在另一个任务之前完成这一限制</u>。那么运用拓扑排序，我们就能得到满足执行顺序限制条件的一系列<u>任务所需执行的先后顺序</u>。当然也<u>有可能图中并不存在这样一个拓扑顺序，</u>这种情况下我们无法根据给定要求完成这一系列任务，这种情况称为<u>循环依赖</u>（circular dependency）。

- 适用范围：当且仅当一个有向图为**有向无环图（directed acyclic graph，或称DAG**）时，才能得到对应于该图的拓扑排序。每一个有向无环图都<u>至少存在一种【可能有多种】</u>拓扑排序。【对于非有向无环图而言，其拓扑排序不存在】

  - 注意上述所谓环，是顺时针环或者逆时针环，要考虑有向。有两种方向的边成环的，那不是这里所谓的环。

- 算法思想：可用使用一个改进的深度优先遍历或广度优先遍历算法来完成拓扑排序。

  - 每次都**应当从入度为0的结点开始遍历**。因为<u>只有入度为0的结点才能够成为拓扑排序的起点</u>。

  - 广度优先搜索【建议只熟悉这种】——邻接表

    1. 初始化一个int inDegree[]<u>保存每一个结点的入度</u>。
    2. 对于图中的每一个结点的子结点，将其子结点的入度加1。
    3. <u>选取入度为0的结点开始遍历</u>，并将该节点加入输出，进行扩展。
    4. 对于<u>遍历过的每个结点，更新其子结点的入度：将子结点的入度减1</u>。
    5. <u>重复步骤3，直到遍历完所有的结点</u>。
    6. **如果无法遍历完所有的结点，则意味着当前的图不是有向无环图。不存在拓扑排序**。

    ```c++
    //有些拓扑排序要求字典序最小什么的，那就把队列换成优先队列就好了
    //同样的in[]=0，取字典序最小的先出队
    #include<iostream>
    #include<cstdio>
    #include<queue>
    #include<list>
     
    using namespace std;
     
    const int maxn=1e5+5;
     
    int indeg[maxn];
    bool book[maxn];
    vector<vector<int> >g(maxn);
    list<int>out;//拓扑排序结果集
    int n,m;
     
    void bfs(int s)
    {
        queue<int>q;//只存储入队0的节点
        q.push(s);
        book[s]=true;//访问标记
        while(!q.empty()){
            int u=q.front();//选一个入度为0的点，出队列
            q.pop();
            //如果q.size()不是为1，说明有分叉。也就是说拓扑排序不唯一
            out.push_back(u);//出队的节点加入结果集
            for(int i=0;i<g[u].size();i++){//扩展
                int n=g[u][i];
                indeg[n]--;
                if(indeg[n]==0&&!book[n]){//只有入度为0的才入队
                    book[n]=true;
                    q.push(n);
                }
            }
        }
    }
     
    bool tsort()
    {
        for(int u=0;u<n;u++){
            for(int i=0;i<g[u].size();i++){
                int v=g[u][i];
                indeg[v]++;//记录入度
            }
        }
        for(int i=0;i<n;i++){//起点肯定是入队为0的节点
            if(!book[i]&&indeg[i]==0){//没有访问过，并且入队为零
                bfs(i);
            }
        }
        //如果out.size()<n，肯定就是成环了。因为环路中的节点肯定入度都不为0.所以肯定有节点没有加入q
        //out中的长度与n不相等，就说明无拓扑序列
        //这里只输入可以形成拓扑序列的部分。如果要判断是否有环，还要另外处理，比如如下
        //if(out.size()!=n)
        //    return false;//成环
        for(list<int>::iterator it=out.begin();it!=out.end();it++){
            cout<<*it<<endl;
        }
        return true;
    
    }
     
    int main()
    {
        cin>>n>>m;
        for(int i=0;i<n;i++){
            book[i]=false;
        }
        int s,t;
        for(int i=0;i<m;i++){
            cin>>s>>t;
            g[s].push_back(t);
        }
        tsort();
        return 0;
    }
    
    //或者
    int topo()///拓扑，可做模板
    {
        queue<int>q;
        int indeg[maxn];
        for(int i=0; i<n; i++)//一开始就找到所有入度为0的顶点入队
        {	
            indeg[i]=indegree[i];
            if(indeg[i]==0)
                q.push(i);
        }
        int k=0;
        int res=0;
        int v;
        while(!q.empty())
        {
            if(q.size()!=1) {
            	res=1;
    		}
            int u=q.front();
            q.pop();
            seq[k++]=u;
            for(int i=head[u]; i!=-1; i=edge[i].next)
            {	
                v=edge[i].v;
                indeg[v]--;
                if(indeg[v]==0)
                    q.push(v);
            }
        }
    	//sum表示节点总数		
        if(k<sum)return -1;///存在有向环，总之不能进行拓扑排序
        if(res) return 0;//可以进行拓扑排序，有多种情况，seq数组是其中一种序列
        return 1;//可以进行拓扑排序，并且只有唯一一种方式，seq数组即是排序完好的序列
    }
    
    ```

  - 深度优先搜索——邻接矩阵

    - 首先用邻接矩阵存储图
    - topo[]用于存储拓扑序列，topo[--n]倒叙存储，以便顺序输出
    - 设置标志位c[]，初始化为0表示从来没有访问过
      - c[]=-1，表示这是当前正在走的路
      - c[]=1，表示这是曾经已经访问完的路
    - 遍历所有节点，如果c[i]==0，则从这个节点开始进行dfs(s)【s=i】
      1. 将当前访问节点标志位c[s]设置为-1，表示处于当前正常走的路径中
      2. 扩展从该点可到的其他点v，如果出现c[v]表示成环，返回false
      3. 否则，遍历未访问的其他点【跳过c[]=1的已访问点】
      4. 访问到头了/死路了，说明这条路已经走完。回溯将每个节点的标志位c设置为1，并且倒叙加入拓扑排序中。返回true，表示这条路没成环
    - 继续找下一个c[i]==0节点进行dfs，直到所有节点都标记为已访问过
    - 输出拓扑序列

    ```c++
    #include<iostream>
    #include<cstring>
    using namespace std;
    int n,m,topo[100];       //topo数组用来储存最终形成的拓扑序列
    int G[100][100];          //储存有序对信息
    int c[100];                   //储存每个节点是否被访问过的信息
    int t;                           
    bool dfs(int u)
    {
        c[u]=-1;               //该段代码的一个亮点，表示u节点正在被访问
        for(int v=1;v<=n;v++)
        {
            if(G[u][v]) //u到v有边
            {
                if(c[v]==-1)   //访问到正在访问的节点，即为存在有向环
                	return false;
                if(c[v]==0){ //不是正在走的那条路并且之前也没有访问过
                    if(!dfs(v))   //深度优先遍历
                    	return false;
                }
            }
        }
        c[u]=1;            //返回时将该节点标记为已访问过
        topo[--t]=u;   //将此节点插入拓扑序列
        return true;
    }
    int main()
    {
         int a,b;
         cin>>n>>m;
         t=n;//dfs存储的时候是倒着存储的。从n-1开始存储到0
         memset(G,0,sizeof(G));
         memset(c,0,sizeof(c));
         for(int i=0;i<m;i++)
         {
             cin>>a>>b;
             G[a][b]=1;
         }
         for(int u=1;u<=n;u++)
         {
             if(!c[u])    //如果该节点没有被访问过 
             if(!dfs(u)){ //dfs函数对图中节点进行深度优先遍历，返回值表示拓扑排序是否存在
                 cout<<"存在有向环，失败退出"<<endl;
                 return 0;
             }
         }
         for(int i=0;i<n;i++)
         cout<<topo[i]<<" "<<endl;
         return 0;
    }
    ```

##### Tarjan

- tarjan是一种求强连通分量、双连通分量的常用算法，其拓展例如求缩点、割点、割桥以及2-SAT等都是非常实用的

- 强连通图：有向图中任意两个节点都两个可达

- 一个图的强连通分量就是这个图中的各个尽可能大的强连通子图的集合，也就是说一个图可能有多个强联通分量

  ![img](https://5b0988e595225.cdn.sohucs.com/images/20180808/8c0209717117446882f56307436b57ab.png)

- 参考链接：[Tarjan算法详解，包括讲解和例题](https://blog.csdn.net/mengxiang000000/article/details/51672725)

- 算法模板：

  - low[u]初始化为dfn[u]，即标号。回溯返回后更新low【u】=min(low【u】，low【v】）u代表当前节点，v代表其能到达的节点。即使v之前被别的节点搜过了，也要进行这步操作。
  - 需要获得强联通分量则要加入stack，否则只要记录强联通分量数，只需要计数

  ```c++
   #include<cstdio>
   #include<algorithm>
   #include<string.h>
   using namespace std;
   struct node {
       int v,next;
   }edge[1001];
    int DFN[1001],LOW[1001];
   int stack[1001],heads[1001],visit[1001],cnt,tot,index;
  void add(int x,int y)
  {
       edge[++cnt].next=heads[x];
       edge[cnt].v = y;
       heads[x]=cnt;
      return ;
   }
   void tarjan(int x)//代表第几个点在处理。递归的是点。
   {
       DFN[x]=LOW[x]=++tot;// 新进点的初始化。
       stack[++index]=x;//进站
       visit[x]=1;//表示在栈里
      for(int i=heads[x];i!=-1;i=edge[i].next)
       {
           if(!DFN[edge[i].v]) {//如果没访问过，没有标号，或用visit[edge[i].v]==0
              tarjan(edge[i].v);//往下进行延伸，开始递归
               LOW[x]=min(LOW[x],LOW[edge[i].v]);//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。
          }
          else if(visit[edge[i].v]){  //如果访问过【dfn!=0】，并且还在栈里。【走到过他】
               LOW[x]=min(LOW[x],DFN[edge[i].v]);
           }
       }
       if(LOW[x]==DFN[x]) //发现是整个强连通分量子树里的最小根。
      {
           do{
              printf("%d ",stack[index]);
               visit[stack[index]]=0;//表示出栈，一定要注意标记出栈
               index--;
           }while(x!=stack[index+1]);//注意退出条件为stack从栈顶到u本身
           printf("\n");
       }
       return ;
   }
   int main()
   {
       memset(heads,-1,sizeof(heads));
       int n,m;
       scanf("%d%d",&n,&m);
      int x,y;
       for(int i=1;i<=m;i++)
       {
           scanf("%d%d",&x,&y);
          add(x,y);
       }
      for(int i=1;i<=n;i++)
           if(!DFN[i])  tarjan(i);//当这个点没有访问过，就从此点开始。防止图没走完【从而没有dfs到过】
      return 0;
   }
  ```

##### 判断一个图是否有环

- 可用算法：

------

#### POJ题目

#####  (一)POJ1860

​	判断是否有正环、有的话资金可以无限增加【保证源点在正环中】

```c++
//兑换货币，这题可以当做一个图论题
//每次在兑换点可以兑换货币X-Y，给出了X到Y以及Y到X的汇率和手续费【手续费从源货币类型扣除】
//要从货币起始货币类型开始转换，结束时也为同类的货币类型
//可以将每种类型的货币当做节点，从一种类型到另外一种类型为一条路【每个兑换点是一条双向路径】，权值/代价为手续费和汇率
//目的是使得Nick变得富有。
//floyd算法是计算所有节点之间的【两两之间】的最短路径。
//这里已经固定了起点和终点没必要用floyd【多源最短路】
//因此可以考虑spfa，bellman-ford、Dijkstra 【都是解决单源最短路的】 
//这里从一个节点到另外一个节点，可能会总资金变大，也可能总资金变小。因此是包含正权边和负权边的图。
//由于Dijkstra算法无法判断含负权边的图的最短路。[pass]
//如果遇到负权，在没有负权回路（回路的权值和为负）存在时，
//也可以采用Bellman - Ford算法正确求出最短路径【有负权环路则不可】
//因此可以使用bellman-ford和spfa
//此时应该反向运用SPFA或bellman-ford，判断是否有正环。 
//【如果有正环，则说明从起点起到这个转一圈，每转一圈，资金就增加，再回到起点。因此变得富有】
//也就是说这是一个判断是否存在正环的题。 
#include<iostream>
#include<string.h>
using namespace std;
struct Edge{
	int u;
	int v;
	double rate;
	double comm;
}edge[205]; //一个兑换点相当于双边 
int EdgeNum=0;
int NodeNum;
double d[110];
bool bellman_ford(int sta,double value){  //注意这里的value是double类型 
	memset(d,0,sizeof(d));//注意这里的初始化，原来的bellman_ford求的是最短路。现在像是在求最长路，因此要初始化为0 
	d[sta]=value;
	for(int i=0;i<NodeNum-1;i++){
		for(int j=0;j<EdgeNum;j++){
			if(d[edge[j].v]<(d[edge[j].u]-edge[j].comm)*edge[j].rate){ //资金越多越好 
				d[edge[j].v]=(d[edge[j].u]-edge[j].comm)*edge[j].rate;
			}
		}
		if(d[sta]>value)
			return true;
	}
	for(int j=0;j<EdgeNum;j++){
		if(d[edge[j].v]!=0&&d[edge[j].v]<(d[edge[j].u]-edge[j].comm)*edge[j].rate){//还能再扩大说明有正环
			return true;
		}
	}
	return false;
}
int main(){
	int n,m,s;
	double v;//n种货币、m个兑换点、Nick的第s类货币有V个 
	cin>>n>>m>>s>>v;
	NodeNum = n;
	//注意是判断正环，而非负环
	for(int i=0;i<m;i++){
		// 货币种类 A and B 、 R AB, C AB, R BA and C BA
		int a,b;
		double rab,rba,cab,cba;
		cin>>a>>b>>rab>>cab>>rba>>cba;
		edge[EdgeNum].u=a;
		edge[EdgeNum].v=b;
		edge[EdgeNum].rate=rab;
		edge[EdgeNum].comm=cab;
		EdgeNum++;
		edge[EdgeNum].u=b;
		edge[EdgeNum].v=a;
		edge[EdgeNum].rate=rba;
		edge[EdgeNum].comm=cba;
		EdgeNum++;
	} 
	if(bellman_ford(s,v)){
		cout<<"YES"<<endl;
	}
	else{
		cout<<"NO"<<endl;
	}
	return 0;
} 

```

## 二分图算法

#### 二分图的概念

- 二分图又称作二部图，是图论中的一种特殊模型。
- 设G=(V, E)是一个无向图。如果**顶点集**V可**分割**为两个互不相交的子集X和Y，并且<u>图中每条边连接的两个顶点一个在X中，另一个在Y中，则称图G为二分图</u>。 
- 分割点为两个集合，使得图中所有的边，每条边的两个端点处于不同集合
- ![img](https://img-blog.csdn.net/20170414203853417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQzIwMTgwNjMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 二分图的判定

- 如果一个图是连通的，可以用如下的方法判定是否是二分图： 
- 在图中**任选一顶点v，定义其距离标号为0**，然后<u>把它的邻接点的距离标号均设为1，接着把所有标号为1的邻接点均标号为2（如果该点未标号的话），如图所示，以此类推</u>。
- <u>标号过程</u>可以用一次<u>BFS实现</u>。标号后，**所有标号为奇数的点归为X部，标号为偶数的点归为Y部**。 
  接下来，**二分图的判定就是依次检查每条边，看两个端点是否是一个在X部，一个在Y部**。 如果不是，则说明这个图不是二分图
- 如果一个图不连通，则在每个连通块中作判定。 
  ![img](https://img-blog.csdn.net/20170414203938168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQzIwMTgwNjMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 二分图匹配

- 给定一个二分图G，在G的一个子图M中，M的边集{E}中的<u>任意**两**条边</u>都不依附于同一个顶点【**任意两条边没有公共顶点**】，则称M是一个匹配。 
- 图中加粗的边是<u>数量为2的匹配</u>
  ![img](https://img-blog.csdn.net/20170414204013825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQzIwMTgwNjMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 最大匹配：找到最大的M集合。【匹配数最大】
- 完全匹配：**每个顶点**都和图中某条边相关联【每个顶点都是M中的某边的端点】，则称此匹配为**完全匹配**

#### 二分图最大匹配——【匈牙利算法(不带权值)+KM算法(带权)】

- 最大匹配就是给出一个最优方案，使得**结成的组数最多**

- 匈牙利算法【<u>两个端点都是未盖点的交错路叫做（可）增广路</u>。】

  - 增广路:设M为二分图G的某个匹配集合。若有一个路径P【不一定是单条边】是图G中一个连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。【可能不存在】

    - 增广路径是一条“交错轨”。也就是说P路径的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配【最终连接到】,并且起点和终点还没有被选择过，这样交错进行。
    - 第一条边的起点是X集合的未饱和点/未被M边集合覆盖的点
    - 最后一条边的终点是Y集合的未饱和点/未被M边集合覆盖的点
    - P一定**有奇数条边**，起点为X集合，如果是偶数条边则P路径会回到X集合，但是如果是奇数条边，P路径才会回到Y集合【的某个未覆盖点】

  - 增广路的作用：**将增广路所有的边进行”反色”**【未匹配的边变成已匹配的边/已匹配的边变成未匹配的边】,**则可以得到使得匹配数增加一对**。即M趋近了最大匹配。【M集合有更多的边】

  - 匈牙利算法：

    - 在一个二分图G中，已知两个顶点集X,Y。如果X或Y中存在未饱和点/未覆盖点，说明还没有得到G的最大匹配
    - 则从X集合中选择一个未饱和点，寻找到Y集合中某个未饱和点的增广路径/交错轨【如果说当前没有一条匹配边。那么任意一个x到y的边都是增广路。】
    - 如果存在，则反色，匹配数+1。
    - 可以证明,<u>当不能再找到增广轨时,就得到了一个最大匹配.这也就是匈牙利算法的思路</u>.

  - 举例：图G，当前匹配数为3【条边】

    ![img](https://www.byvoid.com/upload/wp/2008/04/02.jpg)

  - 从未覆盖点X2开始找到一条交错轨/增广路，到Y集合中的未覆盖点Y2

    ![img](https://www.byvoid.com/upload/wp/2008/04/08.jpg)

  - 进行反色，匹配依然合法，并且匹配数增加=4【条边】。<u>原来的饱和点，现在还是饱和点，只是现在新增了几个饱和点</u>

    ![img](https://www.byvoid.com/upload/wp/2008/04/09.jpg)

  - 综上所述：

    - 首先拿到一个图先判断它是不是二分图，BFS标号+检查【所有标号为奇数的点归为X，标号为偶数的点归为Y】
    - 是二分图，则可以形成两个点集X,Y
    - 计算二分图最大匹配——匈牙利算法

  - 时间复杂度：

    - 找一次增广路径的时间为：
      1. 邻接矩阵： O(n^2)
      2. 邻接表：O(n+m)
    - 总时间：
      1. 邻接矩阵：O(n^3)
      2. 邻接表：O(nm)

  - 算法实现：

    ```c++
    //伪代码
    bool dfs(int u)//寻找从u出发的增广路径
    {
        for each v∈u的邻接点
            if(v未访问){
                标记v已访问;
                if(v未匹配||dfs(cy[v])){
                    cx[u]=v;//X集合中u点已饱和
                    cy[v]=u; 
                    return true;//有从u出发的增广路径
                }
            }
        return false;//无法找到从u出发的增广路径
    }
    //代码
    bool dfs(int u){//u当前节点
        for(int v=1;v<=m;v++)
            if(t[u][v]&&!vis[v]){//t[u][v]表示u到v有一条边，并且v没有访问过
                vis[v]=1;//标记为已访问
                //如果v就是没匹配的。则说明已经找到增广路。否则出现交错轨
                if(cy[v]==-1||dfs(cy[v])){//注意这里是dfs(cy[v])而非dfs(v)
                    //cy[v]表示y集合v点到x集合中的点。也就是相当于走了一条匹配边，回到x集合
                    cx[u]=v;//X集合中u点已饱和，此后不应该选择他作为起点了
                    cy[v]=u;//标记为饱和点【以及当前的匹配边】
                    return 1;//有从u出发的增广路径
                }
            }
        return 0;//一定要写return0，否则默认返回return true;
    }
    void maxmatch()//匈牙利算法主函数
    {
        int ans=0;
        memset(cx,0xff,sizeof cx);//初始化为-1
        memset(cy,0xff,sizeof cy);
        for(int i=0;i<=nx;i++) 
            if(cx[i]==-1)//如果i未匹配
            { 
                memset(visit,false,sizeof(visit)) ; 
                ans += dfs(i); //找到一条增广路就++
            }
        return ans ;
    } 
    ```

  - 参考链接：

    - https://blog.csdn.net/c20180630/article/details/70175814
    - https://www.byvoid.com/zhs/blog/hungary

- KM算法

  - 适用范围：<u>**带权**二分图的最优匹配</u>【对于带权二分图，其边有大于0的权重，<u>找到一组匹配，使其**权重最大**</u>，即为带权二分图的最佳匹配。 】,注意**必须是完全偶图/二分图的最优匹配才可以用**。【**完全偶图**就是X中每一个点与Y中每一个点都有连边。】

    - 不了解KM算法的人如何解决这个问题？我们只需要用匈牙利算法找到所有的最大匹配，比较每个最大匹配的权重，再选出最大权重的最优匹配即可。但是节点越多，此种算法的实行难度也就越来越大，必须另辟蹊径：KM算法。
    - *KM* 算法仅仅只适用于找二分图最佳完美匹配，<u>如果无完美匹配，那么算法很可能陷入死循环（如果不存在的边为 -INF 的话就不会，但正确性就无法保证了）</u>，对于这种情况要小心处理。

  - 算法相关概念：

    - 二分图完美匹配：如果一个二分图的<u>所有点都是匹配点</u>（匹配边中某一条边的端点），则称这个匹配是<u>完美匹配</u>。【X集合和Y集合中的节点都饱和】

    - 二分图最大完美匹配：假定有一个二分图 G，每条边有一个权值（可为负数），<u>权值和最大的完美匹配是二分图最大完美匹配</u>。

  - 算法思想：*KM* 算法是通过给每个顶点一个标号（叫做顶标）来<u>把求最大权完美匹配的问题转化为求完美匹配的问题的</u>。

    - 当前的顶标的导出子图并不一定存在完美匹配。这时，可以用某种方法对顶标进行调整。调整的方法是：根据最后一次不成功的寻找交错路的DFS，取所有i被访问到而j没被访问到的边(i,j)的lx[i]+ly[j]-w[i][j]的最小值d。将交错树中的所有左端点的顶标减小d，右端点的顶标增加d。经过这样的调整以后：原本在导出子图里面的边，两边的顶标都变了，不等式的等号仍然成立，仍然在导出子图里面；原本不在导出子图里面的边，它的左端点的顶标减小了，右端点的顶标没有变，而且由于d的定义，不等式仍然成立，所以他就可能进入了导出子图里。
    - 初始时随便指定一个可行顶标，比如说lx[i]=max{i出边的max}，ly[i]=0。然后对每个顶点进行类似Hungary算法的find过程，如果某次find没有成功，则按照这次find访问到的点对可行顶标进行上述调整。这样就可以逐步找到完美匹配了。
    - https://blog.sengxian.com/algorithms/km【包含证明】
      - 可行顶标就是对于所有顶点的函数值 l*l*，使得对于任意弧 e*(*x*→*y)，都满足lx*+*ly≥We, *KM* 算法的顶标自始至终满足这一条件。
      - 接着是<u>相等子图，相等子图包含原图中所有的点，但只包含满足 l_{x} + l_{y} =We的所有弧 e*(*x*→*y)</u>，根据定义，这些弧一定是当前最大的弧（不等式已经取到等号），那么<u>如果相等子图有完美匹配，那这个完美匹配一定是最大完美匹配。因为相等子图的权值和为所有点的顶标之和</u>【因为每个弧长都是 l_{x} + l_{y} =We，端点顶标和=边权】，而随便一个匹配中的边因为受到 lx*+*ly≥We的限制，不可能比所有点的顶标之和大，**所以才体现了权值最大的最优匹配**。
    - http://longrm.com/2018/05/05/2018-05-05-KM/
    - https://www.cnblogs.com/logosG/p/logos.html【举例】

  - 时间复杂度：O（n^3），n表示节点数

  - 算法实现：

    1、初始化可行性顶标lx[], ly[]。

    2、用类似Hungry算法的思想求完全匹配。找到则继续找

    3、找不到则调整lx[], ly[]的值，然后回到1。

    - 根据最后一次不成功的寻找交错路的DFS，取**所有i被访问到而j没被访问到的边(i,j)**的`lx[i]+ly[j]-w[i][j]`的最小值d。将交错树中的所有左端点的顶标减小d，右端点的顶标增加d

    4、如果二分图已经是完全匹配的则退出，ans = ∑(lx[i] + ly[i]);

    ```c++
    
    const int maxn = 500 + 3, INF = 0x3f3f3f3f;
    int n, W[maxn][maxn];
    int mat[maxn];
    int Lx[maxn], Ly[maxn], slack[maxn];
    bool S[maxn], T[maxn];
    
    inline void tension(int &a, const int b) {
        if(b < a) a = b;//获取a和b中的最小值，存储到a中
    }
    
    inline bool match(int u) {
        S[u] = true;
        //由于KM算法只能适用于完全二分图，因此X中每个节点和Y中每个节点都有边
        //故不要判断是否有边存在。直接遍历y中节点即可
        for(int v = 0; v < n; ++v) {
            if(T[v]) continue;//已经访问过Y集合中的这个点了，不能冲突了。
            int t = Lx[u] + Ly[v] - W[u][v];//只能找Lx[u] + Ly[v] = W[u][v]的边，最终才能得到最佳匹配【总权值最大】
            //t=0，上述等式满足
            if(!t) {
                T[v] = true;//记录交替轨，表示已访问
                if(mat[v] == -1 || match(mat[v])) {
                    mat[v] = u;//相当于做了反色
                    return true;//进入这个if相当于找到了增广路
                }
            }else tension(slack[v], t);//计算Y中没访问的节点的边(i,j)的lx[i]+ly[j]-w[i][j]
        }
        return false;//只找到交替轨
    }
    
    inline void update() {
        int d = INF;
        //取Y中没被访问的节点的边(i,j)的lx[i]+ly[j]-w[i][j]的最小值d
        for(int i = 0; i < n; ++i)
            if(!T[i]) tension(d, slack[i]);
        for(int i = 0; i < n; ++i) {
            if(S[i]) Lx[i] -= d;
            if(T[i]) Ly[i] += d;
        }
    }
    
    inline void KM() { //lx，ly表示顶标的值
        //初始化
        for(int i = 0; i < n; ++i) {
            Lx[i] = Ly[i] = 0; mat[i] = -1;//mat标记匹配点
            for(int j = 0; j < n; ++j) Lx[i] = max(Lx[i], W[i][j]);
        }
        //KM算法
        for(int i = 0; i < n; ++i) {//要求是完美匹配，肯定是所有节点都会饱和，因此循环n次。每次都应该找到一个增广路，增加一条匹配边。
            fill(slack, slack + n, INF);
            while(true) {
                //S和T集合分别记录X和Y集合中节点处于当前交替轨的情况。S[i]=true，表示X集合中的i节点在当前交替轨中，此后要对其-d
                for(int j = 0; j < n; ++j) S[j] = T[j] = false;
                if(match(i)) break;//找到增广路，继续对下一个，增加了一条匹配边，肯定总权值上升
                else update();//没找到增广路，只找到交替轨，修改顶标，继续找路
            }
        }
    }
    ```

#### 二分图最小点覆盖

最小点覆盖：假如选了一个点就相当于覆盖了以它为端点的所有边，你需要选择最少的点来覆盖图的所有的边。

最小点覆盖=最大匹配数

最小边覆盖=全部顶点-最大匹配数

