---
title: pwnable.kr WriteUp部分————[简单题]
date: 2018-10-25 08:17:00
tags:
- CTF
categories:
- CTF
---

## 一、random ##
### 1.题目： ###

![random题](/assets/img/random_title.jpg)

1 pt可以看出，这题不难呀！

### 2.反汇编源码： ###

    int __cdecl main(int argc, const char **argv, const char **envp)
    {
      int v4; // [rsp+8h] [rbp-8h]
      int v5; // [rsp+Ch] [rbp-4h]
    
      v5 = rand();
      v4 = 0;
      __isoc99_scanf(&unk_400760, &v4);
      if ( (v5 ^ v4) == 0xDEADBEEF )
      {
    puts("Good!");
    system("/bin/cat flag");
      }
      else
      {
    puts("Wrong, maybe you should try 2^32 cases.");
      }
      return 0;
    }



**没有srand得到的种子！！！所以这个rand是假的。得到的“随机数”是固定的。**

### 3.rand函数的实现 ###

linux下的rand是用类似下面的代码实现的：

    static unsigned long next = 1;
    
    /* RAND_MAX assumed to be 32767 */
    int myrand(void) {
    	next = next * 1103515245 + 12345;
    	return((unsigned)(next/65536) % 32768);
    }
    
    void mysrand(unsigned seed) {
    	next = seed;
    }
myrand、mysrand分别对应rand和srand，但实际的rand实现会复杂一些。

如果你没有**调用srand设置随机数种子，seed的默认值会是0，而seed为0时所决定的序列是固定的【只要seed固定，产生的随机数都一样】**，而第一次调用rand()就是返回这个固定序列里的第1个元素，那它的值也是固定的，自然你的程序每次输出都一样了。

所以正确的写法应该是程序**初始化时用srand设置不同的随机数种子（只需要设置一次），例如srand(time(NULL))，但要注意，time(NULL)的值是隔1秒才改变一次的【只要你不是在同一秒内执行两次，每次输出结果都是不一样】，必要情况下可以考虑使用精度更高的时间函数**，如gettimeofday。

### 4.攻击脚本及思路 ###

根据反汇编源码可知，只要(v5 ^ v4) == 0xDEADBEEF成立我们就可以执行system("/bin/cat flag");

而v5=rand(),gdb调试看一下rand的返回值为0x6b8b4567

![gdb调试得到固定值v5](/assets/img/v5_value.jpg)


    __isoc99_scanf(&unk_400760, &v4);

![unk_400760的值](/assets/img/v4_value.jpg)

可知scanf("%d",&v4)，此处输入v4的值，要使(v5 ^ v4) == 0xDEADBEEF成立，则

>v4=v5^0xDEADBEEF=0x6b8b4567^0xDEADBEEF=0xB526FB88

**poc:**

    #!/usr/bin/python
    from pwn import *
    re = ssh(host="pwnable.kr",password="guest",user="random",port=2222).process("./random")
    
    
    payload =  0xB526FB88  #v4
    
    re.sendline(str(payload)) #%d输入，转化成字符串形式整数形式
    print re.recv()


![flag](random_break.jpg)




