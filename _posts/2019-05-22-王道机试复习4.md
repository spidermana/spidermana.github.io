---
title: 王道机试复习4
date: 2019-05-22
---

## dp

确定几个规模较小的问题答案。然后考虑如何由这几个规模较小的答案推得后面的答案【递推规则】。

**有时候尝试计算几个规模较小的问题，看看能不能找到规律从而得到递推规则算式。**

或通过分析题意，判断大规模问题如何由小规模问题组成

#### 错排公式

同时给 n 个网友每人写了一封信，把所有的信都装错了信封！注意了，是全部装错哟！现在的问题是：计算一下，一共有多少种可能的错误方式呢

- 规模较小时的错装方式数量：如 n 为 1 时， 数量为 0；n 为 2 时数量为 1。
- 在任意一种错装方案中，假设 n 号信封里装的是 k 号信封的信，而 n 号信封里的信则装在 m 号信封里。我们按照 k 和 m 的等值与否将总的错装方式分为两类。 
  - 若 k 不等于 m，交换 n 号信封和 m 号信封的信后，n 号信封里装的恰好是对应的信，而 m 号信封中错装 k 号信封里的信，即除 n 号信封外其余 n-1 个信封全部错装，其错装方式等于 F[n - 1]，又由于 m 的 n-1 个可能取值，这类错装方 式总数为（n - 1）* F[n - 1]。<u>也可以理解为，在 n-1 个信封错装的 F[n - 1]种方式 的基础上，将 n 号信封所装的信与 n - 1 个信封中任意一个信封（共有 n-1 中选择）所装的信做交换后，得到所有信封全部错装的方式数。</u>
  - 另一种情况，若 k 等于 m，交换 n 号信封和 m 号信封的信后，n 号信封和 m 号信封里装的恰好是对应的信，这样除它们之外剩余的 n-2 个信封全部错装，其 错装方式为 F[n - 2]，又由于 m 的 n-1 个取值，这类错装方式总数为（n - 1）* F[n - 2]。<u>也可以理解为，在 n - 2 个信封全部错装的基础上，交换最后两个信封中的 信(n 号信封和 1 到 n-1 号信封中任意一个，共有 n-1 种选择)，使所有的信封全部 错装的方式数。</u>
-  综上所述，F[n] = (n - 1) * F[n - 1] + (n - 1) * F[n - 2]。

##### 练习题

- 合唱队形(九度教程第 97 题)（提示：正反两次运用 LIS）； 

#### DP状态设置

##### 1.搬寝室

n 件物品中选择搬 2\*k 件，每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(每次搬两件东西,左手一件右手一件).求最低的疲劳度

设 dp\[i]\[j]为在**前 j 件物品中选择 i 对**物品时最小的疲劳度：

- 根据物品 j 和物品 j-1 是否被配对选择，该状态有两个来源：
  - 若物 品 j 和物品 j-1 未被配对，则物品 j 一定没被选择，所以 dp\[i]\[j]等价于 dp\[i]\[j - 1]； 
  - 若物品 j 和物品 j-1 配对，则 dp[i\]\[j]为 dp[i - 1]\[j - 2\]再加上这两件物品配对后产 生的疲劳度，即前 j-2 件物品配成的 i-1 对再加上最后两件配成的一对物品，共 得到 i 对物品。 
- 初始时，dp\[0]\[i](1<=i<=n)为 0，即不选择任何一对物品时，疲劳度为 0。 

##### 2.Greedy Tino

有一堆柑橘，重量为 0 到 2000，总重量不大于 2000。要求我们 从中取出两堆放在扁担的两头且两头的重量相等，问符合条件的每堆重量最大为多少。没有符合条件的分堆方式则输出-1。 

设状态 dp\[i]\[j]表示**前 i 个柑橘被选择后**（每个柑橘可能放到第一堆或者第二堆）后，**第一堆比第二堆重 j** 时（<u>当 j 为负时表示第二堆比第一堆重</u>）， **两堆的最大总重量和**：【前i个橘子，重量差j时的最大重量和】

- 初始时
  - dp\[0]\[0]为 0，即不往两堆中加任何柑橘时，两堆最大总重量为 0；
  - dp\[0]\[j]（j 不等于 0）为负无穷，即该状态都不存在。 
- 状态转移：每一个新加入的柑橘被加入到第一堆或者第二堆或者不加到任何一堆
- 状态 dp\[n]\[0] / 2 即是所求

#### 背包

###### 0-1背包

牢记 0-1 背包的特点：每一件物品至多只能选择一件，即在背包中该物品数量只有 0 和 1 两种情况。 

一维的要倒序更新。

0-1背包变化版：

0-1 背包**存在一个简单的<u>变化</u>**，即要求所选择的物品必须**恰好装满背包**。

- 设计新的状态 dp\[i]\[j]为前 i 件物品恰好体积总和为 j 时的最大价值，其状态转移与前文中所讲的 0-1 背包完全一致。
- 初始状态发生变化：
  - dp\[0\][0]为 0，而其它 dp\[0]\[j]（前 0 件物品体积总量为 j）值均变为**负无穷**【标识不存在的状态】
- 经过状态转移后，得出 dp\[n]\[s]即为答案。
- 综上所述，<u>该变化与原始 0-1 背包的差别仅体现在初始值方面</u>，其它各步骤均保持不变。 

###### 完全背包

扩展 0-1 背包问题，使**每种物品的数量无限增加**，便得到**完全背包问题**

当前可选数量为无限的物品等价为 V/w 件体积为 w、价值为 v 的不同物品【有限个物品，1件w体积v价值的物品*V/W】。 **对所有的物品均做此拆分，最后对拆分后的所有物品做 0-1 背包即可得到答案。** 但是，这样的<u>拆分将使物品数量大大增加</u>。

很多背包问题的解决均可以推到 0-1 背包上来。 

每个物品可以被无限次选 择，那么状态 dp\[i]\[j]恰好可以由可能已经放入物品 i 的状态 dp\[i]\[j - list[i].w]转移 而来，固在这里将状态的**遍历顺序改为顺序**，使在更新状态 dp[j]时，dp[j - list[i].w] 时可能因为放入物品 i 而发生改变，从而达到目的。 

总结完全背包问题,其特点为每个物品可选的数量为无穷,其解法与 0-1 背包整体保持一致，与其不同的仅为状态更新时的遍历顺序。时间复杂度和空间复杂度均和 0-1 背包保持一致

###### 多重背包问题

多重背包问题，其<u>介于 0-1 背包和完全背包之间</u>：有容积为 V 的背包，给定一些物品，每种物品包含体积 w、价值 v、和**数量 k，**求用该背包能装下的最大价值总量。 

简单的想法：可以将多重背包问题直接转化到 0-1 背包上去，即每种物品均被视为 k 种不同物品，对所有的物品求 0-1 背包。但是这样复杂度会变高。

这里使用**二进制优化**！

<u>将原数量为 k 的物品拆分为若干组，每**组**物品看成**一件**物品</u>。

每组物品包含的原物品个数分别为：为：1、2、4…、2^(c-1)、k-2^c+1，其中 c 为使 k-2^c+1 大于 0 的最大整数。这种类似于二进制的拆分，不仅将物品数量大大降低，同时通**过对这些若干 个原物品组合得到新物品的不同组合，可以得到 0 到 k 之间的任意件物品的价值重量和**，所以<u>对所有这些新物品做 0-1 背包，即可得到多重背包的解</u>。

复杂度也由O（s\*∑ki）变为O（s\*∑log(ki)）

【具体回顾dp王道一章节和dp的markdown笔记】

## 其他技巧

#### string处理方法

`头文件#include<string>`

###### 1.char与string转换

**string转char[]：**一位位a[i]赋值，但是末尾要加a[s.length()-1]='\0'

**string转char\*：**char\* p = (char\*)str.data();或者str.c_str()

**char */char[] 转string：**类似于char *p = "hello"；s=p；

string用c风格输出：

```c
string c = "cout"; 
printf("%s\b",c.c_str()); 
```

###### 2.函数

str.erase(pos,n)函数：

- 起始位置`pos`处开始删除, 要删除字符的长度为`n`, 调用后str**自动赋值为修改后**的string对象引用
- n缺省则从pos起一直删除到结尾。
- 还可以使用迭代器，例如str.erase(str.begin()+10,str.end());删除迭代器指定的范围

int pos = str.find（b,startPos，len）函数：

- 在string中下标startPos位置开始查找b字符串【b也可以是字符】
- 若能够找到b字符串则返回其<u>第一次出现的下标</u>；
- 否则，返回一个常数string::npos
- 如果有len，则只在str中找b的前len个字符。否则匹配b全体

str.insert(2,b，len); 函数：

- 对str对象的**index为2的字符前**插入字符串b
- 调用后，str**自动修改为插入后的值**
- 如果有len，则只插入b的前len个字符。否则插入b全体

str.insert(index,count,ch);

- 在index位置插入count个字符ch

str=str.replace (pos, len, str2);

- 将str从起始位置pos开始长度为len的字符替换为str2
- **不会修改str**
- 要通过赋值实现修改

str=str.replace (str.begin(),str.begin()+5，str2);

- 使用迭代器规定替换范围。
- 将起始到第五个字符串前替换为str2

str2=str.substr(pos,len)

- 返回，从pos开始长度为len的子字符串
- 不会修改str

#### char字符

注意是否要加\0

修改大小写：

- 头文件`ctype.h`
- a[i] = tolower(a[i]); 
- a[i] = toupper(a[i]); 

char* strcpy(char* dest, char* src); 【完全复制】

- 把从src地址开始且**含有 ‘\0’结束符的字符串**复制到以dest开始的地址空间 
- dest结尾会带有\0
- src 和 dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串

char* strcat(char* dest, char* src); 

- 把**src所指字符串添加到dest结尾处**(覆盖dest结尾处的 ‘\0’)并**添加 ‘\0’** <u>返回指向dest的指针</u> 

char* strchr(char* s, char c); 

- 查找字符串s中首次出现字符c的位置。
  - 类似地strstr用于查找字符串strchr(str,b)
- 返回**首次出现c的位置的指针**，如果s中**不存在c则返回NULL** 
- int t=strchr(src,ch)-src;可以得到ch在src的index

strupr（小写转大写）、strlwr（大写转小写）

- char* strlwr(char* s); 
- char* strupr(char* s); 
-  \#include <string.h> 

```c++
char s[]="Let's % SWT together!";
strupr(s);
printf("%s",s);
//输出>>LET'S % SWT TOGETHER!
```

#### gets和scanf的特点

gets的输入特点

- 当程序运行至gets语句后，它将依次**读入**遗留**在输入缓冲中的数据直到出现换行符**，并将<u>除换行符外的所有已读字符保存在字符数组中</u>，同时**从输入缓冲中去除该换行符**。 

scanf ("%s",str)函数

- 读取输入缓冲的字符直到出现空格、 换行字符，它将读到的字符保存至字符数组str中，但**并不删除缓冲中紧接的空格 与换行**

因此两者连用，中间加getchar()

```c++
scanf ("%d%d",&a,&b); 
getchar(); 
gets(str); 
```

#### 练习题

- 单词替换(九度教程第 106 题);
- 字符串去特定字符(九度教程第 107 题); 

## 最后的提醒 

机试中的注意事项。 

1.提前了解正式机试将会使用的评判系统、编译环境和可以使用的开发工 具，尽早做适应练习，特别是 **64 位整数的定义和使用（long long 或__int64）。** 

2.在正式考试前往往有试机、练习时间，检查开发工具各功能是否正常，如 编译、调试等。 

3.在**编写每一题时**都要特别**注意其时间复杂度**。 
4.注意程序**是否符合题目要求的输出格式**。 

5.在机试过程中**注意“跟风”，即先挑选通过人数的较多的题作答**，而别死磕一道题。 

6.**不要在程序中混用 printf 和 cout**，由于它们的输出机理不同，混用将非常容易造成错误。 