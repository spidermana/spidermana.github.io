---
title: 王道机试复习2
date: 2019-05-16 9:20:00
---

## 数据结构

本章介绍机试题中涉及数据结构的部分，主要包括堆栈的应用、求哈夫曼树 和二叉树的相关问题。

### 一、栈的应用

栈常常来做匹配，如括号匹配。还进行用于表达式求值

常见函数：

- #include \<stack\>
- stack\<int\> S; 
- S.push(i); 
- int x = S.top(); 
- S.pop(); 
- bool em=S.empty()

#### 直接一步输出char[ ]，则添加空字符

```c++
char ans[110]; //保存输出字符串
ans[i] = 0; //为了使输出形成字符串，在其最后一个字符后添加一个空字符   
puts(ans); //输出答案字符串   
```

#### 表达式求值

简单回顾： 

1. **设立两个栈**，<u>一个用来保存运算符，另一个用来保存数字</u>。
2. 在表达式首尾添加标记运算符【表示表达式刚刚开始或结束】，该人为运算符运算优先级最低。 
3. 从左至右依次遍历字符串。
4. 若遍历到表达式中的数字，则直接压入数字栈。
5. 若遍历到运算符，则将其与运算符栈栈顶元素进行比较，**若运算符栈栈顶运算符优先级小于该遍历到的运算符或者此时运算符栈为空**， <u>则将该运算符压入堆栈</u>。遍历字符串中下一个元素。 
6. **若运算符栈栈顶运算符优先级大于该遍历到的运算符**，<u>则弹出该栈顶运算符，再从数字栈中依次弹出两个栈顶数字，完成弹出的运算符对应的运算得到结果后，再将该结果压入数字栈</u>，**重复比较**此时栈顶运算符与当前遍历到的运算符优先级， 视其优先级大小重复步骤 3 或步骤 4。 
7. 若运算符栈中仅存有两个运算符且栈顶元素为我们人为添加的标记运算符，那么表达式运算结束，此时数字堆栈中唯一的数字即为表达式的值

```c++
#include <stack> 
#include <stdio.h> 
using namespace std; 
char str[220]; //保存表达式字符串
int mat[][5] = { //优先级矩阵,若mat[i][j] == 1，则表示i号运算符优先级大于j号运算符，运算符编码规则为+为1号，-为2号，*为3号，/为4号,我们人为添加在表达式首尾的标记运算符为0号 
 1,0,0,0,0, //对角线要给0，因为是同级是从左到右运算，栈顶先算，再算当前运算符
 1,0,0,0,0, //0,0要给1，这样才会在while中停止循环运算。
 1,0,0,0,0, //+与- 和 /与*，也要给0，从左到右运算
 1,1,1,0,0, 
 1,1,1,0,0, }; 
stack<int> op; //运算符栈,保存运算符编号 
stack<double> in; //数字栈,运算结果可能存在浮点数,所以保存元素为double 
void getOp(bool &reto,int &retn,int &i) { //获得表达式中下一个元素函数,若函 数运行结束时,引用变量reto为true,则表示该元素为一个运算符,其编号保存在引用变量retn中； 否则，表示该元素为一个数字，其值保存在引用变量retn中.引用变量i表示遍历到的字符串下标 
 if (i == 0 && op.empty() == true) { //若此时遍历字符串第一个字符,且运算符栈 为空,我们人为添加编号为0的标记字符   
     reto = true; //为运算符   
     retn = 0; //编号为0   
     return; //返回，这里没有i++，因为这是人为自增的运算符，后期还要在i==0，继续判断，因此要有op.empty==true
 } 
 if (str[i] == 0) { //若此时遍历字符为空字符,则表示字符串已经被遍历完   
     reto = true; //返回为运算符   
     retn = 0; //编号为0的标记字符   
     return; //返回 
 } 
 if (str[i] >= '0' && str[i] <= '9') { //若当前字符为数字   
     reto = false; //返回为数字 
 } 
 else { //否则   
     reto = true; //返回为运算符   
     if (str[i] == '+') { //加号返回1 
   		retn = 1; 
     }else if (str[i] == '-') { //减号返回2 
   		retn = 2; 
  	 } 
     else if (str[i] == '*') { //乘号返回3 
   		retn = 3; 
  	 }else if (str[i] == '/') { //除号返回4 
   		retn = 4; 
  	 }   
     i += 2;//i递增,跳过该运算字符和该运算字符后的空格   return; //返回 
 } 
 retn = 0; //返回结果为数字 
 for (;str[i] != ' ' && str[i] != 0;i ++) { //若字符串未被遍历完,且下一个字 符不是空格,则依次遍历其后数字,计算当前连续数字字符表示的数值   
     retn *= 10;   
     retn += str[i] - '0'; 
 } //计算该数字的数字值 
 if (str[i] == ' ') //若其后字符为空格,则表示字符串未被遍历完   
     i ++; //i递增.跳过该空格 
 return;//返回 
} 
int main () { 
 while(gets(str)) { //输入字符串,当其位于文件尾时,gets返回0   
     if (str[0] == '0' && str[1] == 0) break; //若输入只有一个0,则退出   
     bool retop;int retnum; //定义函数所需的引用变量   
     int idx = 0; //定义遍历到的字符串下标,初始值为0   
     while(!op.empty()) op.pop();   
     while(!in.empty()) in.pop(); //清空数字栈,和运算符栈   
     while(true) { //循环遍历表达式字符串 
   		getOp(retop,retnum,idx); //获取表达式中下一个元素 
   	    if (retop == false) { //若该元素为数字 
    		in.push((double)retnum); //将其压入数字栈中 
  		} 
        else { //否则 
            double tmp; 
            if (op.empty() == true || mat[retnum][op.top()] == 1) { 
                op.push(retnum); 
            } //若运算符堆栈为空或者当前遍历到的运算符优先级大于栈顶运算符,将该运算符压入运算符堆栈 
            else { //否则 
                while(mat[retnum][op.top()] == 0) { 
                    //只要当前运算符优先级小于栈顶运算符,则重复循环 
                  int ret = op.top(); //保存栈顶运算符 
                  op.pop(); //弹出 
                  //注意顺序是a op b，b先出来
                  double b = in.top(); 
                  in.pop(); 
                  double a = in.top(); 
                  in.pop(); //从数字堆栈栈顶弹出两个数字,依次保存在遍历a.b中 
                  if (ret == 1) tmp = a + b; 
                  else if (ret == 2) tmp = a - b; 
                  else if (ret == 3) tmp = a * b; 
                  else tmp = a / b; //按照运算符类型完成运算 
                  in.push(tmp); //将结果压回数字堆栈 
                } 
             op.push(retnum); //将当前运算符压入运算符堆栈 
             } 
        } 
         //有可能还没有放入结束符，例如1+2-5，可能有<[起始][+]>这时候size=2，必须是<[起始][结束]>
   		if (op.size() == 2 && op.top() == 0) 
            break; //若运算符堆栈只有两个元素,且其栈顶元素为标记运算符,则表示表达式求值结束 
  	}   
    printf("%.2f\n",in.top()); //输出数字栈中唯一的数字,即为答案 
 } 
 return 0; 
} 
```

#### gets函数回车结束，\n->\0【可空格】

gets从标准输入设备读字符串函数，其可以无限读取，不会判断上限，以回车结束读取。

从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer所指向的字符数组中。换行符不作为读取串的内容，**读取的换行符被转换为‘\0’空字符，并由此来结束字符串。**

也就是说，以下读入后，str后结束字符\0

> char str[220]; 
>
> gets(str);

 while(gets(str)) //**输入字符串,当其位于文件尾时,gets返回0**

头文件：#include<stdio.h>

#### getline函数读取一行字符直到\n【默认】，\n->\0【可空格】

```c++
//添加#include <string>头文件
while(getline(cin,str)){
	cout<<str<<endl;
}
//结尾会加入\0结束符。
//or
string s;
getline(cin,s,'#');
```

以下情况发生会导致生成的此字符串结束。

1）到文件结束

2）遇到函数的定界符

3）输入达到最大限度。

返回值

- 成功：返回读取的字节数。

- 失败：返回-1

##### 注意：gets和getline两者都会在读取的字符串后面自动加上'\0'

当输入的字符数小于count时遇到字符delim【默认为换行符】，getline函数将读取这个字符但是不存进array当中去，而是将其丢弃。gets也同样。

也就是说gets和getline之后，不需要getchar来消除换行符，可以直接cin

#### 练习题

- 表达式求值
- 堆栈的应用

### 二、哈夫曼树

给定 n 个结点和它们的权值，以它们为叶子结点构造一棵<u>**带权路径和最小**的二叉树， 该**二叉树**即为哈夫曼树</u>，同时也被称为<u>最优树。</u>

- 从根结点到达该节点的路径长度再乘以该结点权值被称为<u>该结点的带权路径长度</u>。
- 树所有的叶子结点的带权路径长度和为<u>该树的带权路径长度和</u>。
- 给定结点的哈夫曼树可能不唯一【高度和左右子树都会不同】。但是最小带权路和唯一。
  - 高度不同在于k个（k>2）相同节点值时，选择哪两个拼接。比如高度为7、1、2的三个节点值，拼接出来的高度可能是8或者9

回顾一下我们所熟知的哈夫曼树求法。 

1. 将所有结点放入集合 K。 
2. 若集合 K 中剩余结点大于 2 个，则<u>取出其中权值最小的两个结点，构造他们同时为某个新节点的左右儿子，该新节点</u>是他们共同的双亲结点，设定它的权值为其两个儿子结点的权值和。并将该父亲结点<u>放入集合 K。</u>重复步骤 2 或 3。 
3. 若集合 K 中<u>仅剩余一个结点</u>，该结点即为构造出的哈夫曼树数的<u>根结点</u>。
4.  所有构造得到的中间结点(即哈夫曼树上非叶子结点)的权值和即为该哈夫曼树 的带权路径和。 

使用优先队列求哈夫曼树为O（nlogn）

模板

```c++
#include <queue> 
#include <stdio.h> 
using namespace std; 
//建立一个小顶堆 
priority_queue<int , vector<int> , greater<int> > Q; 
int main () { 
 int n; 
 while (scanf ("%d",&n) != EOF) {   
      while(Q.empty() == false) Q.pop(); //清空堆中元素 
      for (int i = 1;i <= n;i ++) { //输入n个叶子结点权值 
           int x; 
           scanf ("%d",&x); 
           Q.push(x); //将权值放入堆中 
  	  }   
     int ans = 0; //保存答案   
     while(Q.size() > 1) { //当堆中元素大于1个 
       int a = Q.top(); 
       Q.pop(); 
       int b = Q.top(); 
       Q.pop(); //取出堆中两个最小元素,他们为同一个结点的左右儿子,且该双亲结点 的权值为它们的和 
       ans += a + b; //该父亲结点必为非叶子结点,固累加其权值 
       Q.push(a + b); //将该双亲结点的权值放回堆中 
      }   
     printf("%d\n",ans); //输出答案 
 } 
 return 0; 
} 
```

#### 堆

使用堆数据结构【标准模板：优先队列，`priority_queue<int> Q; `】，以 O（logn）的复杂度取得 n 个元素中的最小元素。

请特别注意这样**建立的堆其默认为大顶堆**，即我们从堆顶取得的元素为整个堆中最大的元素。

而在求哈夫曼树中，需要取得堆中最小的元素，于是我们使用如下语句定义一个**小顶堆**：` priority_queue<int , vector<int> , greater<int> > Q;`

注意是：greater\<int\> >;【没有最后的括号，和sort中的第三个参数不同】

堆相关操作：Q.push(x); 、int a = Q.top(); 、 Q.pop();

#### 练习题

- <u>哈夫曼编码问题</u>
- <u>多个数的两两合并问题</u>【例如任意石子合并问题】
- 搬水果

### 三、二叉树

二叉树的遍历方式：前序遍历【根左右】、中序遍历【左中右】、后序遍历【左右根】。**前、中、后体现了根的位置**

```c++
//以中序遍历为例，给出其遍历方法。 
void inOrder (Node *Tree) { 
 if (Tree -> lchild != NULL) //递归遍历左子树   
     inOrder(Tree -> lchild); 
 /* 对当前结点Tree作遍历操作*/ 
 if (Tree -> rchild != NULL) //递归遍历右子树   
     inOrder(Tree -> rchild); 
 return; 
} 
```

#### 根据前序+中序遍历恢复二叉树

**给定前序遍历与中序遍历能够唯一确定后序遍历**

- 用递归的方式去做。
- 根据前序遍历得到中序遍历的左右子树的ind，分隔了左右子树。确定左子树or右子树的前序和中序范围，递归

#### C++对数

头文件:`#include<cmath>`

提供两种log函数:

- log()：以e为底数
- log10()：以10为底数

如果<u>要计算以m为底数,n的对数</u>，即logm(n)，可以使用换底公式即：

double a=log(n)/log(m);

<u>注：库函数exp(n) 为e^n次方；</u>

#### 练习题

- 树查找
  - 总层数`toth = ceil((log(n+1)/log(2)-1));`，n表示树节点个数
- 二叉树
- 二叉树遍历

### 四、二叉排序树

二叉排序树<u>【又称为二叉搜索树】</u>是一棵特殊的二叉树，它是一棵二叉树但同时满足如下条件：

对于树上任意一个结点，其上的数值必大于等于其左子树上任意结点数值，必小于等于其右子树上任意结点的数值。 

#### 二叉排序树的建树过程

即不断插入数字 x： 

- 1.若当前树为空，则 x 为其根结点。 
- 2.若当前结点大于 x，则 x 插入其左子树；
- 若当前结点小于 x，则 x 插入其右子树；
- 若当前结点<u>等于 x</u>，则<u>根据具体情况选择插入左右子树或者直接忽略</u>。

由于**各个数字插入的顺序不同**，所得到的**二叉排序树的形态也很可能不同**。

但是，对于相同数据集合，不论何种插入顺序，对二叉排序树进行中序遍历，其遍历结果必然是一个递增序列，且都想相同。

```c++
Node* Insert(Node* T,int x){ //传入整棵树的根节点
	if(T==NULL){
		return create(x);//返回根节点
	}
	if(T->num>x){
		T->lchild = Insert(T->lchild,x);
	}
	else if(T->num<x){
		T->rchild = Insert(T->rchild,x);
	}
	return T;//返回根节点
}
//Node *T = NULL;
//for (int i = 0;i < n;i ++) 
//T = Insert(T,x); 
```

#### 判断两棵二叉树是否相同。

由于一种遍历顺序并不能唯一的确定一棵二叉树【形态、节点值都一致】，所以两棵不同的树的某一种遍历顺序是可能相同的。如数字相同，插入顺序不同而建立的两棵二叉排序树，它们的中序遍历一定是一样的。

**包括中序遍历在内**的**两种遍历**结果可以唯一得确定 一棵二叉树。

若两种遍历的结果都相同，那么就可以判定两棵树是完全相同的。 

#### 练习题

- 二叉排序树：建树+打印三种遍历方式
- 二叉搜索树：判断两序列是否为同一二叉搜索树序列 

#### 删除操作

要删除二叉排序树上的某一个结点，按如下步骤进行：

-  利用某种遍历找到该结点。 
- 若该结点为叶子结点，则直接删除它，即将父节点指向其的**指针**改为 NULL。释放该节点空间。 
- 若该结点仅仅不存在右子树，则直接将其左子树的根结点代替其位置后，删除该结点。即将其父节点左**指针**指向其的左子树树根。
- 若该节点存在右子树，则找到右子树上最左下的结点（即中序遍历中该子树上第一个被遍历到的结点），将被删除结点的**数值改为**右子树上最右下结点的数值后，**删除最左下结点。** 
  - 仅存在右子树
  - 存在左右子树
  - 都进行该种操作

删除二叉树要保证中序遍历依然保持递增的顺序

## 数学问题

#### %运算

###### 1.余数修正

%运算符的两个操作数a，b 必须为**整型变量**，例如 int、short 等，而不能为浮点数。且 b 变量必须为非零值，否则会产生runtime error运行时错误

其运算<u>在行为上好像</u>是按如下步骤进行的：

- 首先计算出 a 的**绝对值**被 b 的绝对值除**所得的余数**，
-  再使**该余数的符号与 a 保持一致**。
  - 即若 a 为正数，则该表达式结果必为非负数（可 能为 0）；
  - 若 a 为负数，则表达式结果必为非正数（可能为 0）。
- 而**表达式结果与 b 的符号没有直接关系**，即 <u>a % -b 与 a % b 的结果相同</u>。 

求模运算符求得的**余数存在着负数的可能**。而这与数论中关于余数的定义是不相符的。数论指出，<u>余数的取值范围为从 0 到除数减 1</u>。【a%b，余数的绝对值在[0,b-1]】

**%运算符**的运算特性**仅保证余数的绝对值在如上所述的范围内**，而不保证不会出现负数

解决：**只需在该负的余数上再加上除数再对除数求一次余即可**

统一的对取得的余数加上除数后再对该和求模：

- r=a%b；
- r‘ = (r+b)%b;
- 最终余数为r’【不论a为负还是正】

这样做，不仅能对可能出现的负余数做适当的修正，同时对出现的零和正余数也不会改变他们的值。

如果！！！用到%运算符，而<u>题目只说整数，一定要格外注意，余数修正</u>。如果输入都为正整数，则直接使用%即可。

###### 2.分配律公式

（a*b）%c  = （（a%c） * （b%c））**%c**

（a+b）%c  = （（a%c） + （b%c））**%c**

#### 数位拆解

###### 方法一

```c++
while(a != 0) { //数位拆解,只要当a依然大于零就不断重复拆解过程 
   buf1[size1 ++] = a % 10; //取得当前个位上的数字,将其保存 
   a /= 10; //将所有数位上的数字移动到高一位上 
} 
```

**注意：**以上方法，**如果a==0，要进行特判**，否则buf1为空，连0都没有

###### 方法二

直接使用字符串输入，用index取得各个位。即`a[i] - '0'`，而且还很方便求数的位数【s.length() or strlen(s)】

#### 进制转化

从m进制转换到n进制转化为两个进制转换问题：

1. 从 m 进制转换到十进制。
   - 按权重m^k求和【k表示第k位】
2. 再从十进制转换到 n 进制。
   - 对十进制x，while(x){ %n得到低位; x=x/n }

 注意：`ans[size ++] = (x < 10) ? x + '0' : x - 10 + 'A';`

\>=10的字符，要转成A-F，并且要注意要求的输入字符和输出字符是大写A-F还是小写a-f，还是混杂

#### 范围判断

出现两个int整型数的加法或乘法，要注意结果可能为long long int，小心溢出 

如果用scanf和printf来输出long long，则使用转义字符%lld。

而对于部分平台使用\__int64，**\_\_int64对应%I64d**

#### 最大公因数GCD

若 a、b 全为零则它们的最大公约数不存在；

若 a、b 其中之一为零，则它们的最大公约数为 a、b 中非零的那个；

若 a、b 都不为零，则使newa = b；newb = a % b 然后重复该过程。 

【a和b的GCD等于b和a mod b的GCD】

```c++
int gcd(int a,int b) { 
 if (b == 0) 
     return a; //若b为零则最大公约数为a 
 else 
     return gcd(b,a % b); //否则,则改为求b与a%b的最大公约数 
}
```

#### 最小公倍数LCM

a、b 两数的<u>最小公倍数为两数的乘积除以它们的最大公约数</u>

lcm【Least Common Multiple】=`a*b/gcd(a,b)`

#### 素数筛法

###### 如何判断一个数是否是素数

一个**大于1**的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。

```c++
#include <math.h> 
bool judge(int x) { //判断一个数是否为素数 
 if (x <= 1) return false; //若其小于等于1,既不是合数也不是素数【最小的合数是4】
 if（x % 2 == 0） return false;//过滤掉偶数
 int bound = (int)sqrt(x) + 1; //计算枚举上界,为防止double值带来的精度损失, 所以采用根号值取整后再加1,即宁愿多枚举一个数也不能少枚举一个数 
 for (int i = 3;i <= bound;i=i+2) {
     if (x % i == 0) return false; //依次枚举这些数能否整除x,若能则必不为素数 
 }
 return true; //若均不能则为素数 
} 
```

只需测试到不比 sqrt（n）（对 n 开根号）大的整数即可，若到这个整数为止，所有正整数数均不能整 除 n，则可以断定，n 为素数。

从3开始遍历，每次累加2。不需要判断4,8,16……，在于前面过滤了整除2的情况，能被4,8……整除，一定能被2整除，能被2整除的肯定不是素数。

###### 如何求一个范围内的所有素数

厄拉托塞斯筛法（Eratoshenes筛法）是一种寻找素数的方法，又称平凡除法。

<u>应用定理：</u>“设n是正整数，如果对所有的素数p≤√n,都有p不能整除n,则n一定是素数.”得到的一个寻找素数的确定性方法。

下面给出<u>具体描述：</u> 对任意给定的正整数N，要求出所有不超过N的素数。列出N个整数，从中**删除不大于√N的所有素数P1,P2,P3,……,Pk的倍数**（除素数P1,P2,P3,……,Pk外）。具体的是依次删除，                 
P1的倍数：2·P1,3·P1,4·P1,……,[N/P1]·P1；             
P2的倍数：2·P2,3·P2,4·P2,……,[N/P2]·P1；             
P3的倍数：2·P3,3·P3,4·P3,……,[N/P3]·P1；                     …………             
Pk的倍数：2·Pk,3·Pk,4·Pk,……,[N/Pk]·P1. 

<u>余下的整数</u>（**不包括1**）就<u>是所有求的不超过N的素数</u>（[x]表示小于或等于x的最大整数）。    

通过上面的的解释，我们知道爱拉托塞斯筛法是指从2到N删去√N内所有素数的2倍、3倍、4倍、……、[N/P1]倍，剩下的就是N内的素数

```c++
void init() { //素数筛法
     for (int i = 1;i <= 10000;i ++) {   
        mark[i] = false; 
     } //初始化，所有数字均没被标记

     primeSize = 0; //得到的素数个数为0 
     for(int i = 2;i <= 10000;i ++) { //依次遍历2到10000所有数字  
        if (mark[i] == true) continue; //若该数字已经被标记,则跳过   			
        prime[primeSize ++] = i; //否则,又新得到一个新素数   
        for (int j=i*i;j <= 10000;j += i) {//并将该数的所有倍数均标记成非素数
            mark[j] = true; 
        }
 	  } 
} 
```

筛法中我们使用了一个小技巧。当我们判定 i 为素数，要 标记其所有倍数为非素数时，我们**并没有从 2 * i 开始标记，而是直接从 i * i 开 始标记**。<u>其原因是：i * k （k < i）必已经在求得 k 的某个素因数（必小于 i）时被标记过了，即 i*k 同时也是 k 的素因数的倍数</u>。所以这里，我们**可以 直接从 i 的平方开始标记起。**

#### 质因数分解

将一个数x分解成其质因数的乘积。

若 N 为质数，N 是 N 的质因数。

且注意，1 不是 N 的质因数；

利用上节的素数筛法预先筛选出所有可能在题面所给定的数据范围内成为素因数的素数。并在程序输入待处理数字 n 时，依次遍历所有小于 n 的素数，判断其是否为 n 的因数。 若确定某素数为 n 的因数，则通过试除确定其对应的幂指数。

- 在试除的时候，n==1时就要break终止
- 如果试除完所有小于n的素数，n不等于1，那么说明n本身是一个质因数

进行质因数分解后，我们可以得到n分解所有的整数因数的个数为(e1+1)(e2+1)(e3+1)……

###### 看“整除问题”（P97）的分析

给定 n，a 求最大的 k，使 n！可以被 a^k 整除但不能被 a^(k+1)整除

**题解**：

由于n！和 a 的 k 次可能数值非常巨大，而不能被 int（甚至long long）保存，也就不能直接用求余数==0操作判断它们是否存在整除关系。 

转而思考，对a和b=n!进行素因数分解。若a存在素因数px则 b 也必存在该素因数，且该素因数在 b 中对应的幂指数必不小于在 a 中的幂指数。则能认为a可以整除b【b/a】

故：

我们只需依次测试 a 中每一个素因数，确定 b 中该素因数对应的幂指数是 a 中幂指数的几倍（利用整数除法），这样<u>所有倍数中最小的那个</u>即为我们要求的 k

对a是可以进行这样的操作。

但是对b=n!，由于n!是巨大的，不能进行素因数分解。

**再次分析：**n！中包含了 1 到n 区间内所有整数的乘积，这些乘积中每一个 p 的倍数（包括其本身）都将对 n！ 贡献至少一个p因子【1\*p、2\*p、3\*p、……、[n/p]\*p】，且我们知道在1到n中p的倍数共有 n/p(整数除法)个， 则 p 的因子数至少为 n/p 个，即有 n/p 个整数至少贡献了一个 p 因子。

那么有多少个整数将贡献至少两个 p 因子呢，有了以上的分析读者应该知道所有 p\*p 的倍数将为 n！贡献至少 2 个 p 因子，且这样的整数有 n/(p\*p)个；同理 p\*p\*p 的倍数将贡献至少3个，这样的数有n/( p\*p\*p )个

#### 快速幂

```c++
#define LL long long int
using namespace std;
LL MyPow(LL b,LL expo,LL p){
	LL res = 1;
	while(expo){
		if(expo&0x01){
			res = (res*b)%modp;
		}
		b = (b*b)modp;
		expo=expo>>1;
	}
	return res;
}
```

矩阵快速幂类似于普通的快速幂，只是初始化时res初始化为单位矩阵【主对角线为1】

```c++
vector<vector<int>> quickMatrixPower(vector<vector<int>> A,int b){
    int rows = A.size();
    int cols = A[0].size();
    vector<vector<int>> ans;
    if(rows!=cols)
    {
        printf("Only the square matrices can be imaginary!");
        return ans;
    }
    //初始化矩阵ans为单位矩阵
    ans.resize(rows);
    for(int i=0;i<cols;i++)
        ans[i].resize(cols);
    for(int i=0;i<cols;i++){
        for(int j=0;j<cols;j++){
            if(i==j)
                ans[i][j]=1;
            else
                ans[i][j]=0;
        }
    }

    while(b){//利用二分求幂的方法计算矩阵的幂次方
        if(b&1){
            ans = matrixMultiple(A,ans);
        }
        A=matrixMultiple(A,A);
        b>>=1;
    }
    return ans;
}
```

#### 大整数模板

```c++
struct bigInt 高精度整数结构体 eger {  
 int digit[1000]; //按四位数一个单位保存数值 
 int size; //下一个我们未使用的数组单元
}
```

注意：

- 如果以4个位为一个单元的话，输出的时候注意非最高单元需要前导0，最高单位不需要前导0。【100100=10 0100，存储是ans[1]=10,ans[0]=100，因此ans[0]需要前导0】
- 如果以一个位为一个单元，那么输出的时候直接输出就行了。【或者用string/char类型的话，也可以】

由于其高精度运算需要计算每一位的和，所以该运算复杂度变为 O （size），其中 size 为两个整数中较多的位数，即运算本身可能带来巨大的耗时。 

```c++
#include<iostream>
#define NMAX 101
using namespace std;
struct bigInteger{
	int dig[NMAX];
	int size;
	void init(){
		for(int i=0;i<NMAX;i++){
			dig[i]=0;
		}
		size=0;
	}
	void set(int x){
		init();
		do{
			dig[size++]=x%10000;
			x=x/10000;
		}while(x!=0);
	}
	bigInteger operator +(const bigInteger& A)const{
		bigInteger res;
		res.init();
		int carry=0;
		int nows = max(size,A.size);
		for(int i=0;i<nows;i++){
			res.dig[i]=(A.dig[i]+dig[i]+carry)%10000;
			carry=(A.dig[i]+dig[i]+carry)/10000;
			res.size++;
		}
		if(carry!=0)
			res.dig[res.size++]=carry;
		return res;
	} 
	bigInteger operator *(int x)const{
		bigInteger res;
		res.init();
		int carry=0;
		for(int i=0;i<size;i++){
			res.dig[i]=(dig[i]*x+carry)%10000;
			carry=(dig[i]*x+carry)/10000;
			res.size++;
		} 
		if(carry!=0)
			res.dig[res.size++]=carry;
		return res;
	}
	bigInteger operator /(int x)const{
		bigInteger res;
		res.init();
		int remainder=0;
		for(int i=size-1;i>=0;i--){
			res.dig[i]=(dig[i]+remainder*10000)/x;
			remainder = (dig[i]+remainder*10000)%x;
		}
		res.size=0;
		for(int i=size-1;i>=0;i--){
			if(res.dig[i]!=0){
				res.size=i;
				break;
			}
		}
		res.size++;//数0，也要占用一个单元 
		return res;
	}
	int operator %(int x)const{
		int r=0;
		for(int i=size-1;i>=0;i--){
			r = (r*10000+dig[i])%x;
		}
		return r;
	} 
}; 
char ans[10005];
int main(){
	int m,n;
	string origin;
	while(scanf("%d %d",&m,&n)!=EOF){
		cin>>origin;
		int len=origin.length();
		bigInteger sum;
		bigInteger weight;
		//sum.init();
		sum.set(0);
		//weight.init();
		weight.set(1);
		for(int i=len-1;i>=0;i--){
			int temp;
			if(origin[i]>='0'&&origin[i]<='9'){
				temp=origin[i]-'0';
			} 
			else{
				temp=origin[i]-'A'+10; 
			}
			sum = sum+weight*temp;//weight*temp可行，但是temp*weight不可行。第二个数必须对应opertator的参数 
			weight=weight*m;
		}
		//sum就是十进制值
		//以下要转换成n进制
		int anssize=0;
		int r;
		do{
			char now;
			r = sum%n;
			sum = sum/n;
			if(r<10)
				now = r+'0';
			else
				now = r-10+'A';
			ans[anssize++]=now;
		}while(sum.dig[0]!=0||sum.size!=1);
		for(int i=anssize-1;i>=0;i--){
			printf("%c",ans[i]);
		} 
		cout<<endl;
	}
	
	return 0;
} 
```

#### 练习题

- 浮点数加法
- 大整数排序（高精度整数比较大小）
- 10 进制 vs2 进制