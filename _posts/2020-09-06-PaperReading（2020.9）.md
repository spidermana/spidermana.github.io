---
layout: post
title: PaperReading(2020.9)
date: 2020-09-06 09:58:00
author:     "许大仙"
catalog: true
tags:
    - Paper
---

## Scarecrow: Deactivating Evasive Malware via Its Own Evasive Logic

> FROM DSN 2020

### 1. Summary

- Background：很多恶意软件会在进行恶意行为之前，使用一些逃避策略（embedded evasive logic）来检测执行环境是否是sandbox等恶意软件动态分析环境（ dynamic malware analysis environments）。如果是，那么就不执行/隐藏这些恶意行为（从而使得这些基于恶意行为的动态分析框架无效了），甚至执行一些针对框架的破坏。

- Insight：采用逃避策略来规避动态恶意代码分析其实是一把双刃剑。在避免被分析的同时，限制了恶意软件激活的执行环境范围（意味着malware激活后的活动范围是有限的，造成的破坏也是有限的，而且往往直接退出或只执行良性行为）。

  - 博弈与对立：Evasive techniques have a limited applicable scope and malware authors typically enhance the evasive logic by adding more new checks while keeping existing checks to be backward compatible【恶意代码越加强环境检测能力，这个工具越有效】
  - Ad.： By satisfying a small subset of conditions, we successfully deactivated a large number of evasive malware samples. 

- Solution：利用这种对立的窘境，开发了SCARECROW——将终端用户的执行环境伪装成为动态分析环境（camouﬂaging end-user execution environments into analysis-like environment），相应地malware的执行环境范围和造成的破环程度都会有所下降。
  - inline Hook and DLL named scarecrow.dll injection（by [EasyHook](https://easyhook.github.io/)）
    - API：Software resources 、Hardware resources 、Network resources 
      1. Files and Folders
      2. Processes
      3.  Libraries
      4. GUI windows
      5. Registries
      6.  Function Hooks
      7. Exception processing（有些调试器或动态分析环境会利用exception handler来进行分析，从而出现异常处理的时间差异等副作用）
         - SCARECROW introduces deceptive timing discrepancies in default exception processing with minimal to no impact on benign applications. 
      8. Extended：support “aging”-related deceptive resources.
    
  - Deployment Framework 
  
    - The framework consists of SCARECROW controller (scarecrow.exe) and SCARECROW library (scarecrow.dll). 
    - SCARECROW controller starts executing the target program and injects scarecrow.dll into the target process. 
    - The DLL **installs the API hooks and exchanges runtime information** between the target process and the controller. 
    - Speciﬁcally, scarecrow.dll communicates with scarecrow.exe through interprocess communication (IPC) channels when a deceptive execution environment is ﬁngerprinted by evasive malware. SCARECROW controller dynamically **updates the hooks and conﬁgurations through IPC**. 
  
    ![稻草人](/img/paper/scarecrow1.png)
    
  - we **systematically explore the resources** exploited by evasive malware, such as software, hardware, and network resources, covering virtual machine environments, debugging environments, security products, and sandbox-speciﬁc components.
  
- Experiment： 
  - successfully deactivate 89.56% of evasive malware samples and the variants of ransomware (e.g., WannaCry and Locky) 

  - 同时，对良性的普通软件的运行几乎没有影响

  - SCARECROW可以使得end-user execution environments with SCARECROW和malware analysis environments with SCARECROW不易区分。

  -  Data Sources：
    - Joe Security (MJS): Joe Security released its detailed analysis reports of 18 evasive malware samples 
    - MalGene (MMG): We obtained 1,054 evasive malware samples from the authors of MalGene[25].
    - CNET Software (BCNET):  the top 20 most popular Windows programs from CNET.
    
    ![稻草人](/img/paper/scarecrow2.png)
    
    ![稻草人](/img/paper/scarecrow3.png)

  - 使用了两种 state-of-the-art analysis environment ﬁngerprinting techniques: Paﬁsh [2] (also known as Paranoid Fish) and wear-and-tear artifacts-based evasion，证明了这些罗列的逃避技术执行能检测出SCARECROW的存在【误认为在虚拟环境中】

    ![稻草人](/img/paper/scarecrow4.png)

    -  Extended with deceptive wear-and-tear resources：SCARECROW was able to steer the values of those top 5 artifacts plus the artifacts from the largest registry category, which would largely affect the analysis environment ﬁngerprinting decisions.【消减人为操作以被判断为虚拟静态的环境——eg：sandbox】

    ![稻草人](/img/paper/scarecrow5.png)

  - Logic proof：

    - Essentially its evasive logic was a logical disjunction D of multiple propositions pi, i.e., D = p1∨p2∨...∨pi.
    - Negate the logical disjunction D, i.e., ¬D = ¬(p1 ∨p2 ∨...∨pi)=¬p1 ∧¬p2 ∧...∧¬pi, which indicates that we **only need one pi to be True to deactivate evasive malware in end-user environments**
    -  one of the major advantages of SCARECROW is that **<u>we do not need to handle all evasive logic</u>**. 

  - SCARECROW deactivated two well-known ransomware: WannaCry and Locky

    - only manipulate the resolution of non-existent domains【a DNS sinkhole to resolve nonexistent domains into controlled IP addresses】
    - has no impact on the behavior of benign software, which does not rely on connecting to non-existent domains

- Critical thinking：
  - 造成伪装一定要消耗额外的计算机资源（伪造一个名为VMwareUser.exe的进程）【已解决】
    - 不直接伪造资源，而通过hook API，来修改返回值达到欺骗的目的
    - 同时stop those samples with self-spawning（不断新建进程以逃避debugger） loop behavior
  - 只对应用层进行deception，没有在硬件/指令层面进行deception
    - eg：RDTSC指令【timing channels to detect the analysis environment】
    - Some of the missed features were related to CPU timing information (e.g., rdtsc_diff_vmexit and rdtsc_diff),
      which was not handled by the current implementation of SCARECROW. 
    - However, as we observed before, such timing attacks are not reliable methods for evasive malware to detect analysis environments. Some missed features were not supported due to the unsupported system versions. For example, IsNativeVhdBoot was only supported in Windows 8 while Windows 7 was used for our evaluation.
      -  However, cpuid_hv_bit and cpu_known_vm_vendors are not reliable evidence since they can be easily manipulated. Both VMware and VirtualBox allow modifying the CPUID instruction results to generate customized outputs for the CPUID instruction to the guest
  -  执行一些针对框架的破坏如何解决？
  -  跨平台？移植到IoT设备【研究IoT malware的evasive tech，可能较少，而且部署analysis-like环境难度大】？移植到Android？
  -  是否有动态判断机制？达到什么样的阈值，可以确定现在的software一定是malware，从而减少dll注入更多的进程，或者将恶意代码上传到virustotal或通知杀软。
  
- Discussion：

  - SCARECROW is not a silver bullet that can address all future evasive malware via deceptive resource ﬁngerprinting.
  - plan to extend SCARECROW with kernel/hypervisor-based hooking.
    -  some research such as Malgene can also help to discover new evasive logic.
  - Detection of SCARECROW 
    -  Idea：the best way to detect SCARECROW is to check conﬂicting resources
    -  Approach：One possible solution is to prepare multiple proﬁles for different sandbox environments in SCARECROW. If one property of any individual proﬁle is triggered, we can disable all other proﬁles immediately to avoid from being detected.

### 2. 扩展参考：

#####  analysis environment ﬁngerprinting techniques

- https://github.com/a0rtega/pafish
  - Pafish is a demonstration tool that employs several techniques to detect sandboxes and analysis environments in the same way as malware families do. And you can read the code of all anti-analysis checks. 
- [Spotless Sandboxes](https://www.ieee-security.org/TC/SP2017/papers/429.pdf)

##### Anti-VM指令

- CPUID指令获取CPU信息，来判断环境是否是虚拟的：https://consen.github.io/2016/09/11/Anti-VM-via-CPUID/
  - `CPUID`指令用来获取CPU信息，将功能号作为参数传入`EAX`寄存器，CPUID将信息返回到`EAX、EBX、ECX、EDX`寄存器。下面是两个检测虚拟环境的功能号：
    - EAX = 1，获取CPU功能信息，如果ECX第31位为1， 则表明有hypervisor存在，即环境是虚拟的。
    - EAX = 0x40000000, 获取hypervisor信息，返回12字节长度字符串
- RDTSC指令从时间角度判断环境是否是虚拟的：https://consen.github.io/2016/09/12/Anti-VM-via-RDTSC/
  - The Time Stamp Counter (TSC) is a 64-bit register present on all x86 processors since the Pentium. It counts the number of cycles since reset. The instruction RDTSC returns the TSC in EDX:EAX. In x86-64 mode, RDTSC also clears the higher 32 bits of RAX and RDX. Its opcode is 0F 31.
-  Both VMware and VirtualBox allow modifying the CPUID instruction results to generate customized outputs for the CPUID instruction to the guest. 

##### 以linux为例的hook scope

![稻草人](/img/paper/scarecrow6.png)

### :star:词汇积累

- unforeseen malicious activities
  - **unforeseen**：not expected to happen or known about beforehand. 未预见的.
- a double-edged sword（双刃剑）
-  constrains the spectrum of execution environments 
  -  **spectrum**：a range of a particular type of thing. 范围.
  - 光谱
- exploit this dilemma（利用这种窘境）
- reverse the challenge（克服/逆转挑战）
  - 使 (决定、政策、趋势) 转向; 逆转、调换 (位置、功能)；背面、反面；朝相反方向;
  - the  reverse side、in reverse
- camouflage（(军事) 伪装、(某些动物的) 保护色; 伪装手段、掩饰）
  - He has never camouflaged his desire to better himself.
- **steer** state-of-the-art analysis techniques 
- a silver bullet：致命一击、两方、高招
  - There is no silver bullet that will solve all your problems. 

## You Are What You Do: Hunting Stealthy Malware via Data Provenance Analysis

>FROM NDSS 2020

### 1.Summary

- Background：逃避/隐蔽策略
  - “stealthy malware” makes use of various techniques to impersonate or abuse benign applications and legitimate system tools to minimize its footprints in the target system.
  - difﬁcult for traditional detection tools, such as malware scanners, to detect it, as the malware normally does not expose its malicious payload in a ﬁle and hides its malicious behaviors among the benign behaviors of the processes.
- Insight：Our **insight** behind the PROVDETECTOR approach is that although a stealthy malwareattemptstoblendintobenignprocesses,itsmaliciousbehaviors inevitably interact with the underlying operating system (OS), which will be exposed to and captured by provenance monitoring.
  - 虽然malware企图让自己融入到良性进程之中，但是如果要实施攻击，它的恶意行为不可能避免地要底层OS交互，这样的话就可以通过**provenance monitoring**来进行捕获。
- Solution： PROVDETECTOR 
  - PROVDETECTOR ﬁrst employs a novel selection algorithm to identify possibly malicious parts in the OS-level provenance data of a process. 
  - It then applies a neural embedding and machine learning pipeline to automatically detect any behavior that deviates signiﬁcantly from normal behaviors

### 2.扩展参考

##### 什么是Data Provenance？

Data provenance describes how data came to be in its present form. It includes data sources and the transformations that have been applied to them. Data provenance has many uses, from forensics and security to aiding the reproducibility of scientific experiments.

### :star:词汇积累

- Provenance 
  - the place that sth originally came from 发源地；起源；出处 、
  - All the furniture is of English provenance.
    所有这些家具都是英国货。
-  perimeter and host security
  - perimeter
    - the outside edge of an area of land （土地的）外缘，边缘
  - 边缘用户和主机的安全

- penetrate the target system and prolong its presence
  - penetrate 
    - to go into or through sth 穿过；进入
    - to succeed in entering or joining an organization, a group, etc. especially when this is difficult to do 渗透，打入（组织、团体等）
- based on this intuition  凭借这种直觉

## Different is Good: Detecting the Use of Uninitialized Variables through Differential Replay

> FROM CCS 2019

该文章解决面向Window内核漏洞挖掘这一难题（关注于UMR类型的漏洞），提出了以差分的方式来追踪内核数据流，从而避免开销比较大的污点分析，在准确度和性能上取得了很好的平衡。文章成功发现34个Windows内核零日漏洞，并获得微软确认。

### 1.Summary

作者提出了一种差分重放的方法（differential replay）用于检测无源码情况下的UMR问题

The main idea of this paper is to **replay two different instances with vanilla and poisoned values of stack and heap memory**, respectively. <u>The difference in program states could indicate the presence of the use of uninitialized variables</u>. To determine **the location where the variable was allocated**, <u>symbolic taint analysis is conducted</u>.

- 通过重放示例，进行执行状态的对比，如果存在不同则说明有对未初始化变量的使用。
- 然后使用符号执行和污点分析，确定该未初始化变量的位置。

Experiments are carried out on **119 kernel information leaks in Windows operating systems**, compared to the state-of-art kernel memory disclosure detector *Bochspwn Reloaded* and a reference system that purely leverages the taint analysis to track uninitialized variables.

(+) **Significance:** The use of uninitialized variables could cause kernel information leaks【物理内存的跨权限分配，可能导致kernel的信息泄露，或者破坏KASLR机制】. However, Modern compilers are limited to a single function and fail to deal with arrays, pointers and loops. Existing commercial tools also suffer from high false positives【现存工具的误报率高】. The technique presented by the authors can analyze binaries without source code, with none false positives【该技术无需源码且无误报】.

(+) **Novelty:** 

- The authors suggest recording and replay a program's execution in multiple instances. If the states in two running instances are different, there may exist uninitialized variables. 
- The symbolic taint analysis is only used to further identify the location where the variable was allocated after uninitialized variables have been detected.

(+) **Soundness:** Experiments are conducted with Windows kernels compared to the state-of-art tool *Bochspwn Reloaded*, **successfully identifying <u>34 new issues</u> and another 85 ones that had been patched**.

### 2.Thinking

**Q: 为什么检测未初始化变量很困难？**

A:

静态分析：

- 现代编译器(gcc, clang, etc.)具备简单的检测功能。但大多局限于一个函数，且对于数组、指针、循环、结构体、union等无能为力。
- 需要源码

动态分析：

- 首先使用未初始化变量这类内存泄漏问题**通常不会导致crash**或很明显的影响。
- 一种naive的思路是：进行全系统的动态污点分析，在分配栈或堆时设置source【污点源】，被赋值时去除污点标记，如果程序使用了一块tainted的内存，则可以确定使用了未初始化变量。
  - 程序的哪个位置分配了内存，就全部标记为污点，如果被赋值就消除污点。那么在程序执行过程中如果访问到了污点内存【有污点=未赋值】，则说明存在UMR。
- 但进行全系统的污点分析会**带来极大的overhead**
- 目前<u>最好的工具Bochspwn Reloaded仅对特定类型指令进行污点传播，从而降低overhead，但导致了大量的漏报</u>。
- 其他内存检测工具如MemorySanitizer等，<u>需要基于源码插桩，且仅适用于用户态</u>

**Q: 作者的方案？**

A: 作者的方案是通过差分重放来检测未初始化变量的使用，overhead比上述动态分析方案大幅度降低。当检测到未初始化变量的使用时，再利用符号化污点分析技术，定位未初始化变量的source（变量在哪分配的）。

#### Critical Thinking

- 通过差分重放找未初始化变量的思路很好，这套系统还是需要靠输入触发漏洞，或许可以跟fuzzer相结合。

### 3.Motivating Example

如下图所示，作者用一个内核信息泄漏漏洞（CVE-2018- 8408）作为例子，展示目前工具的局限性，以及作者工具发现该漏洞的过程。

![](\img\paper\Differential_replay4.png)

图中截取了三条关键的汇编指令。

- 第一条汇编指令（01），分配栈上变量，未进行初始化
- 第一条汇编指令（02），将其中4个字节存入ecx寄存器
- 第一条汇编指令（03），将ecx的内容存入eax+4的位置，而此时eax指向的是用户空间

也就是说，这个未初始化的变量，由于Bochspwn不能跟踪寄存器的传播，导致污点无法传播，无法标记进入到用户空间的这个变量其实是未初始化的某个变量【栈帧的增长和消退是不会清空内存的，无行之中就会泄露内核信息】，之后如果在用户空间读取，由于没有污点，就不会认为是未初始化的

Q: 为什么Bochspwn无法发现这个漏洞？

A：**Bochspwn为了避免过高的overhead，仅对特定种类的指令进行污点传播，（其对memory to memory的指令进行污点传播，而不对memory to reg的指令进行污点传播）**，当受污染的数据流入寄存器时，标记将丢失（这确实是此漏洞的情况），所以污点无法进入ecx，从而无法被Bochspwn发现。



**Q: 为什么本文的方法可以发现这个漏洞？**

A: 首先通过确定性差分重放，观察到的两个重放实例的不同内存状态，**一个是正常重播实例，另一个是堆栈内存值为0xaa的重播实例**。如下图所示，执行到*0x83e24501 mov dword ptr [eax + 4], ecx*时，对比地址*0x021afad8*发现差异：

- 设置不同的内存初始化值【poisoned value】进行重放。
- 如果传播的值是一个已经初始化的值，那么很显然多个实例的内存状态是一致的。
- 如果传播的值是一个未初始化的值，由于不同的内存初值，会导致内存状态的不同。

![](\img\paper\Differential_replay3.png)

**接下来利用符号化污点分析技术**，定位未初始化变量的source（变量是在哪里被分配）：

- 利用stack trace记录的信息，**往前N个**栈帧开始dump trace【N如何确定？】
- 再对trace进行符号化污点分析
- 遇到sub esp, eax、函数ExAllocatePoolWithTag等<u>栈、堆分配指令时，新建一个符号并打上taint标记</u>
- 遍历指令，传递污点标记。<u>遇到被赋值操作，则去除对应符号的污点标记。</u>
- 污点分析到*0x83e24501 mov dword ptr [eax + 4], ecx*时，查看ecx对应的符号即可知道其是在哪里被分配的。

###  4.Approach

![](\img\paper\Differential_replay1.png)

**Key technique I: 差分重放：**

（1）使用全系统模拟器记录内核和用户态的运行

（2）确定性重放

（3）对比检测到差异

**Key technique II: 符号化污点分析：**

（4）在检测到差异的指令回退N个栈帧，利用得到的trace，开始符号化污点分析

（5）进行污点传播

（6）到达检测到差异的指令，确定泄漏内存被分配的位置

### 5.running example

![](\img\paper\Differential_replay2.png)

### 6.Evaluation

实验主要解答以下三个研究问题：

- RQ1: Effectiveness: Can TimePlayer detect new vulnerabilities, and perform better than the state-of-the-art tool?
- RQ2: Efficiency: Can TimePlayer quickly detect the vulnerabilities?
- RQ3: Performance overhead: What is the performance overhead?

![](\img\paper\Differential_replay5.png)

![](\img\paper\Differential_replay6.png)

<img src="\img\paper\Differential_replay7.png" style="zoom: 80%;" />

### 7.内核信息的未初始化导致的信息泄露漏洞【用户态可访问】

内核中信息泄露漏洞的产生主要有两方面的原因，一是C语言带来的问题，二是内核设计和编程模式带来的问题。

#### C语言带来的问题

##### 未初始化变量

在C语言中未初始化变量会继承其相应内存区域的旧值。比如下面这样的系统调用每次就会泄露栈上的四个字节。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422105139-8d7a5d4c-64a9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422105139-8d7a5d4c-64a9-1.png)
但是这样单个变量的信息泄露其实并不是很常见，因为编译器通常会警告，也较容易在开发和测试的过程中发现。在下面这样的系统调用中结构体中的Reserved成员没有被用到，但是也会被拷贝回用户态，同样会泄露栈上的四个字节。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422105203-9bcc78da-64a9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422105203-9bcc78da-64a9-1.png)

##### 结构体对齐和填充

结构体中的所有成员和整个结构体都是对齐的。在必要的地方，填充字节被人为地插入到结构体中。虽然不能在源代码中直接访问，但是这些字节仍然继承了相应内存区域的旧值。下面的系统调用中结构体中的每个成员都被正确初始化，但是由于存在填充字节，所以仍然会造成信息泄露。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422105353-dd5fa696-64a9-1.png)

[](https://xzfile.aliyuncs.com/media/upload/picture/20190422105353-dd5fa696-64a9-1.png)

##### 联合体中不同大小的成员

如果联合体由不同大小的成员组成并且只设置了较小的成员，为较大的成员分配的剩余字节就没有初始化。下面的系统调用中联合体是8个字节，但是只设置了较小的成员的值，因此剩下四个字节未初始化，造成信息泄露。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422111944-79dbc13c-64ad-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422111944-79dbc13c-64ad-1.png)
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422112004-857f26e6-64ad-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422112004-857f26e6-64ad-1.png)

##### 总结

在前面的例子中我们可以看到，sizeof操作符的使用和内核信息泄露有直接的关系，因为它导致最终复制的数据比初始化的数据更多。更深层次的原因在于C语言缺少在不同层次之间安全传输数据的功能，如果不采取编译器/操作系统/语言规范这样级别的解决方案，这样的漏洞可能长期存在。[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422105402-e288182e-64a9-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422105402-e288182e-64a9-1.png)

#### 内核设计和编程模式带来的问题

##### 动态分配中的内存重用

前面几个例子都是重用了栈上的值，在windows/linux中也存在动态分配的内存重用机制，同样会导致信息泄露的风险。

##### 固定长度的数组

大的缓冲区很少被全部使用，剩下的空间通常不会被重置，这可能导致特别长的连续的内核内存泄露。下面的系统调用中RtlGetSystemPath函数加载系统路径到一个本地缓冲区，如果调用成功，所有260个字节都传递给调用者而不考虑字符串的实际长度。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422112238-e1a2600a-64ad-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422112238-e1a2600a-64ad-1.png)
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422112245-e54f58a2-64ad-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422112245-e54f58a2-64ad-1.png)

##### 分配缓冲区未全部初始化

大多数系统调用接受指向用户态缓冲区的指针以及缓冲区的大小。在大多数情况下，关于大小的信息应该只用于确定缓冲区是否足够大以接收系统调用的输出数据，但不应该影响复制了多少内存。但是内核中存在试图填充用户态缓冲区的每个字节而不考虑要复制的实际数据量的情况。下面的系统调用目的是提供给用户态3个32位的值，一共12个字节。在检查用户态缓冲区大小足够之后，内核本来可以分配一个12字节的缓冲区然后拷贝到用户态，但是内核根据用户态传入的OutputLength分配缓冲区并全部拷贝到了用户态。用户态只需要12个字节的数据，剩下的字节没有初始化并且泄露给了用户态。
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422112339-05d3db8e-64ae-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422112339-05d3db8e-64ae-1.png)
[![img](https://xzfile.aliyuncs.com/media/upload/picture/20190422112352-0d4302b4-64ae-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190422112352-0d4302b4-64ae-1.png)





