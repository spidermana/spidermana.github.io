---
layout:	 post
title:	 "最长递增子序列nlogn"
subtitle: 	"告别最长递增子序列DP算法【n²】———优化后O(nlogn)"
date: 	2017-07-30 17:20:36
author:     "许大仙"
tags:
	- 算法
---

###  51nod 1134最长递增子序列

#### 一、问题描述

给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）
例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。

**最长递增子序列，即Longest Increasing Subsequence 常常被简记为 LIS。**
常见的n²算法：

- 排序+LCS算法：转换为最长公共子序列[LCS]问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7， 8}，然后找出数组A和A’的最长公共子序列即可。
- DP算法：设长度为N的数组为{a0，a1, a2, ...an-1)，则假定以aj结尾的数组序列的最长递增子序列长度为L(j)，则L(j)={ max(L(i))+1, i<j且a[i]<a[j] }。也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]<a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。

由于较为常见这里就忽略了。详细可见[最长递增子序列算法](http://qiemengdao.iteye.com/blog/1660229)

#### 二、优化后的O（nlogn）算法

假设存在一个序列d[1..9] = {2 1 5 3 6 4 8 9 7}，可以看出来它的LIS长度为5。

**下面一步一步试着找出它。**

定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。
具体的算法思想：建立一个空序列M，把d序列中的元素从下标1到9逐一有序地插入新序列M。判断新增这个元素后，长度为i【例子中为：1到9】时，有序序列M中的最小末尾元素【假设为K】，更新相应的B[i]=K。

**注意 :**每次都某个长度下，找最小末尾元素的好处是，更容易在末尾加入新元素【满足增长序列条件下，可添加元素大小的下界范围大】，使得序列更长。
此外，我们用一个变量Len来记录现在最长算到多少了。

##### 1.算法举例



- 首先，把d[1]=2有序地放到M里，此时M={2}。现在M的长度为1，则只需要更新i=1，即B[1] = 2，就是说当只有一个数字2的时候，长度为1的最长增长子序列LIS的最小末尾是2。这时Len=1。



- 然后，把d[2]=1有序地放到M里，此时M={1,2}。令B[1] = 1，就是说长度为1的LIS的最小末尾是1【1<2,所以{1}优于{2}】。这时Len=1【注意M是有序的序列，不是真实的d序列，不能认为M变为长度2，就有len=2.由于d[2]=1在M序列中是向前插入的，所以实际上d序列在只考察前两个元素时，不会有{1,2}序列，因此len保持1】



- 接着，d[3] = 5，d[3]>B[1]【向后插入】，更新len=2，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5。这时候B[1..2] = 1, 5，Len＝2【做到这里其实可以发现，M={1,2,5}就是个傀儡，没什么用】



- 再来，d[4] = 3，它正好加在1,5之间【M={1,2,3,5}】，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，所以B[1]不需要更新。这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2



- 继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，Len = 3 【只要是在当前B序列中向后插入的，说明满足最长递增序列，因此可以len++，而如果在M序列中需要向前插入则不一定】。




- 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3。



- 第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了



- 第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。



- 最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。

**于是我们知道了LIS的长度为5。**

##### 2.总结

**!!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。**有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。

**然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)~~~~~于是算法的时间复杂度就降低到了O(NlogN)～！**

算法思路总结：通过上面的例子，应该能够明白，如果加入的新元素d[i]，插入的位置在B序列的非末尾，假设为j位置，那么说明要更新B[j]【原来j位置的元素就不要了，替换成新插入的，因为原来j位置的元素既然在插入后向后移了，说明这个元素比新插入的元素要大，不是最小末尾。那些后移的元素也会从B序列里面丢掉】,如果是插入了B序列的末尾，那么len++，说明序列可以增长了。

##### 3.具体代码

	//在非递减序列 arr[s..e]（闭区间）上二分查找第一个大于等于key的位置，如果都小于key，就返回e+1
	int upper_bound(int arr[], int s, int e, int key)
	{
	    int mid;
	    if (arr[e] <= key)
	        return e + 1;
	    while (s < e)
	    {
	        mid = s + (e - s) / 2;
	        if (arr[mid] <= key)
	            s = mid + 1;
	        else
	            e = mid;
	    }
	    return s;
	}
	
	int LIS(int d[], int n)
	{
	    int i = 0, len = 1, *end = (int *)alloca(sizeof(int) * (n + 1));
	    end[1] = d[0]; //初始化：长度为1的LIS末尾为d[0]
	    for (i = 1; i < n; i++)
	    {
	        int pos = upper_bound(end, 1, len, d[i]); //找到插入位置
	        end[pos] = d[i];
	        if (len < pos) //按需要更新LIS长度
	            len = pos;
	    }
	    return len;
	}

#### 三、求解具体序列元素

如何给出一个LIS而不仅是计算长度。
具体的代码我没有写过，不过大概可以这么实现：更新B[i]的时候，把记下来数字在原来数组中的下标也记下来（被替换的数据保留在一个后备数组中）。等到得出 B[n] 了以后，用贪心算法往前回溯，每次找出B[i-1]对应后备数组中值小于B[i]、下标小于B[i]下标、且在该后备数组中下标最大的那个。


**补充一下，由于上面那段代码用的是upper_bound，所以实际上求的是最长不下降子序列；如果要求递增子序列，应该改用lower_bound。**