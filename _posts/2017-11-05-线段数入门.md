---
title: 初级线段数
data: 2017-11-05 15:15:00
tags:
- 算法
- ACM
catagories：
- 算法
- ACM
---

开始选修线段数吧！

参考链接：[《数据结构》线段树入门（一）](http://www.cnblogs.com/shadowland/p/5870339.html)
[《数据结构》线段树入门（二）](http://www.cnblogs.com/shadowland/p/5870354.html)
# 一、问题描述
首先提出一个问题： 

给你n个数，有两种操作：

1：给第i个数的值增加X

2：询问区间[a,b]的总和是什么？

**输入描述**

输入文件第一行为一个整数n，接下来是n行n个整数，表示格子中原来的整数。接下一个正整数q，再接
下来有q行，表示q个询问，第一个整数表示询问代号，询问代号1表示增加，后面的两个数x和A表示给
位置X上的数值增加A，询问代号2表示区间求和，后面两个整数表示a和b，表示要求[a,b]之间的区间和。

**样例输入**

4

7 6 3 5

2

1 1 4

2 1 2

**样例输出**

17

**数据范围**

1 <= n,q <= 100000

**分析**
看到这个问题，最朴素的想法是用一个数组模拟，求和时 [ a , b ]中逐个累加 ， 最后输出 。
但是，由于数据量比较大，时间复杂度太高，时间上无法承受。
因此
这时我们可以用**线段树( Segment Tree )**，这种特殊的数据结构解决这个问题。

# 二、线段数的定义
## 线段数的理解
线段树可以理解为每个节点就是一个线段（一段区间。线段树就是这样一种数据结构，把一个大区间分为若干个不相交的区间，每次维护都在小区间上处理，并且查询也在这些被分解的区间中，通过区间的信息合并出我们需要的结果，这就是线段树高效的原因。
![一颗典型的线段数](/assets/img/segment_tree.jpg)

## 线段数的ADT表述
一般的线段树上的每一个节点T[a , b]，代表该节点维护了原数列[ a , b ]区间的信息。

对于每一个节点他至少有三个信息：左端点，右端点，我们需要维护的信息（在本题中为某区间内的数据之和）。

由于线段树是一个二叉树，而且是一个平衡二叉树（B树或者B-树），如果当前结点的编号是i，左端点为L ，右端点为 R （区间为[L,R]）， 那么左儿子的编号为 i* 2 ，对应的左端点为 L ，右端点为 （L + R)/2 ; 同理右儿子的 编号为 i*2+1，对应的左端点为（L+R)/2 ，右端点为 R
。

如果当前结点的左端点等于右端点，那么该节点就是叶子节点，直接在该节点赋值即可。显然线段树是递归定义的（具体如下）。

# 三、线段数的物理实现
## 线段数存储
线段树的存储可用链表和数组模拟。（本文采用数组写法，便于理解）
### 1.链表存储
	1 struct node
	2 {
	3     int Left, Right;
	4     node *Leftchild , *Rightchild;
	5 };

### 2.数组存储
	struct Tree
	{
	
	    int l, r;
	    long long sum;
	
	} tr[maxN << 2];

注：数组的空间要开四倍大小，防止访问越界，（理论上大于maxN的最小2x的两倍)

关于位运算的内容参见：[优秀程序员不得不知道的20个位运算技巧](http://blog.csdn.net/zmazon/article/details/8262185)

## 建树
线段树的构建是自顶点而下，即**从根节点开始递归构建**，根据线段树定义，**当左端点等于右端点时（达到递归边界）**，直接赋值即可，
**回溯时也要维护区间**，代码如下：

	void Build_Tree ( int x , int y , int i )
	{

    	tr[i].l = x;
    	tr[i].r = y;
    	if( x == y )
			tr[i].sum = a[x] ; //找到叶子节点，赋值
    	else
    	{
        	ll mid = (tr[i].l tr[i].r ) >> 1 ;
        	Build_Tree ( x , mid , i << 1); //左子树
        	Build_Tree ( mid + 1 , y , i << 1 | 1); //右子树
        	tr[i].sum = tr[i << 1].sum + tr[i << 1 | 1].sum; //回溯维护区间和

    	}
	}

## 维护数（对问题描述中1操作的数组增加进行数的维护更新）
如果目标更新节点在左儿子里，去左儿子中查找；反之，在右儿子中。不断递归，直到找到需要维护的节点，更新它，回溯是一路更新回来。这就是维护的过程，代码如下：
		
		void Update_Tree ( int q , int val , int i ){
    	if(tr[i].l == q && tr[i].r == q) //找到需要修改的叶子节点
    	{
       		tr[i].sum = val ; //更新当前结点
    	}
    	else //当前结点是非叶子结点
    	{
        	long long mid = (tr[i].l tr[i].r ) >> 1 ; //取中间
        	if ( q <= mid ) //目标节点在左儿子中
        	{
            	Update_Tree ( q , val , i << 1 );
        	}
        	else if( q > mid ) //目标节点在右儿子中
        	{
            	Update_Tree ( q , val , i << 1 | 1 );
        	}
        	tr[i].sum = tr[i << 1].sum + tr[i << 1 | 1].sum; //回溯
    	}
	}

## 查询树
题目中让我们查询区间求和，不难想到如果当前结点的区间完全被目标区间包含，直接返回当前结点的sum值，否则分类讨论（将目标区间断开分别到两棵子树中查找，最后累加合并）。具体过程通过以下代码理解：

	long long Query_Tree ( int q , int w , int i ){
    if ( q <= tr[i].l && w >= tr[i].r ) 
		return tr[i].sum; //当前结点的区间完全被目标区间包含
    else
    {
        long long mid = (tr[i].l tr[i].r) >> 1;
        if( q > mid ) //完全在左儿子
        {
            return Query_Tree ( q , w , i << 1 | 1);
        }
        else if (w <= mid ) //完全在右儿子
        {
            return Query_Tree ( q , w , i << 1);
        }
        else //目标区间在左右都有分布
        {
            return Query_Tree ( q , w , i << 1) + Query_Tree ( q , w , i << 1 | 1 );
        }
    }
	}

## 主程序
	int main ( ){
    int N, M, q, val, l, r;
    scanf("%d", &N);
    for ( int i = 1 ; i <= N ; i++ )scanf("%d", &a[i]);
    Build_Tree ( 1 , N , 1);
    cin >> M ;
    while (M--)
    {
        int op ;
        cin >> op ;
        if ( op == 1 )
        {
            scanf("%d%d", &q, &val);
            Update_Tree ( q , val , 1);
        }
        else
        {
            scanf("%d%d", &l, &r);
            printf("%lld\n", Query_Tree ( l , r, 1 ));
        }
    }
    return 0 ;}

# 四、线段树的特点和时空分析

1. 假设线段树处理的数列长度为N，那么总结点数不超过2*N（满二叉树是最大情况)；
	- 假设线段树处理的队列长度为N，那么叶子节点就有N个（[1,1]、  [2,2]、[3,3]、……[N,N]）
	- 考虑节点数最多的情况（满二叉树）那么叶子节点的上一层节点就有N/2个，再上一层就有N/4个
	- 所以总节点数=N+N/2+N/4+……+1，等比数列求和得2N
2. 线段分解数量级：线段树能把任意一条长度为M的线段分为不超过2Log2（M）条线段，这条性质使线段树的**查询与修改复杂度都在O(Log2(n))**的范围内解决。
3. 由于线段树是一颗二叉树，深度约为Log2(N)左右。

综上，线段树空间消耗O(n),由于它深度性质，使它在解决问题上有较高的效率。
# 五、线段树之延迟标记
## 问题扩展
如果将问题描述中的1操作改成：给区间[a,b]的所有数增加X。
那么就需要将上述介绍的线段树的最基本内容（线段树单点修改，区间查询），改为：区间修改，区间查询。
## 分析
看到这个问题，我们能立刻想到，在主函数中添加一个循环，就像这样：
for ( int p=l ; p<=r ;++p )Update_Tree ( p , val , 1 );
进行r-l+1 次单点修改实现区间修改，但是仔细想想，对单个元素修改时间复杂度为O（Log2(n)), 所以对单个区间修改的复杂度为O（n*Log(n))——甚至比朴素的模拟算法（O（n））还慢！

这里就将使用一种新方法：**延迟标记（Lazy Tag）**。
延迟标记就是在递归过程中，如果当前区间被需要修改的目标区间完全覆盖，那么就要停止递归，并且在上面做一个标记。但是这个信息没有更新到每个元素（即叶子节点），下次查询时可能无法得到足够的信息。我们不能忘了，之前在一个区间上打了一个标记，这个标记不仅仅是这个节点的性质，此性质作用于整个子树中。假设我们另一个查询中包含了当前区间的子孙区间，显然，这个标记也要对之后的查询产生影响。

如果如果当前区间被需要修改的目标区间完全覆盖，打一个标记。如果下一次的查询或更改包含此区间，那么将这个标记分解，并且传递给其左右儿子。

简单的说，延迟标记在我们需要时，才向下传递信息，如果没有用到，则不再进行操作。这个思想使处理的复杂度依然保持在O（log2(n))左右，相比朴素算法大大地降低了复杂度。（标记add=改区间每个数需要增加的值，因此该节点的sum应该增加add*区间长度）

## 核心操作
为了完成这种操作，我们可以在结构体中，增加一个add数组存储区间的延迟变化量。

**标记下传**

    void Push_down ( int i , int m ){//i是当前结点编号，m = (tr[i].r - tr[i].l +1)
    if(tr[i].add)//如果该节点有延迟标记
    {
        tr[i << 1].add += tr[i].add;//延迟标记给左儿子
        tr[i << 1 | 1].add += tr[i].add;//延迟标记给右儿子
        tr[i << 1].sum += tr[i].add * ( m - ( m >> 1 ) );//维护左儿子
        tr[i << 1 | 1].sum += tr[i].add * ( m >> 1) ;//维护右儿子
        tr[i].add = 0 ;//重要！！！，最后一定要清零！！
    }
	}

**具体详见本章参考链接：《数据结构》线段树入门（二）**