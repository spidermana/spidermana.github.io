---
title：王道机试复习3
date：2019-05-18 17:10:00
---

## 图论

#### 回顾

邻接矩阵：

- 要表示的图为稠密图，且频繁地判断某特定的结点对是否相邻【O（1）】时，使用邻接矩阵较为适宜。
- 空间复杂度O（V*V） 

邻接链表：

- 存在大量遍历邻接结点的操作 而较少判断两个特定结点的关系时，我们选用邻接链表较为适宜。
- 空间复杂度为 O（V+E）

#### 路径压缩

在并查集为了避免树高不断增加，影响查找根节点的效率，而采用路径压缩。

```c++
int findRoot(int x) { 
 if (pre[x] == -1) return x;  
 else {      
     pre[x] = findRoot(pre[x]); //将当前结点的双亲结点设置为查找返回的根结点编号 
     return pre[x]; 
 } 
}
```
#### 并查集模板

对于处理集合性操作的时候，使用并查集很有效。

使用并查集的同时也可以在表示集合的树的根结点保存其它额外信息，并且在集合合并的过程中维护该值，以便于求解某些集合问题。 

```c++
#include<iostream>
#include<algorithm>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<math.h>
using namespace std;
int f[1111];   //father 数组
int Find(int x){    
    if(x != f[x])        
        f[x] = Find(f[x]);    
    return f[x];}
void Union(int x, int y){    
    int fx = Find(x);    
    int fy = Find(y);    
    if(fx != fy)        
        f[fx] = fy;}
int main(){    
    //……   
    for(i=0; i<1111; i++)            
        f[i]=i;        
    for(i=0; i<m; i++)        
    {            
        scanf("%d%d",&a,&b);            
        Union(a,b);//a->b        
    }        
	//……
    return 0;
}
```

##### 1.畅通工程

省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。对于已有一些路，问最少还需要建设多少条道路？

###### 解析

该问题可以被抽象成**在一个图上查找连通分量的个数**

这个问题可以使用并查集完成：

- 初始时，每个结点都是孤立的连通分量，当读入已经建成的边后，我们将边的两个顶点所在集合合并，表示这两个集合中的所有结点已经连通。
- 对所有的边重复该操作
- 最后计算所有的结点被保存在几个集合中，即存在多少棵树->得知共有多少个连通分量
- x个连通分量，再建立x-1条边的可以完全连通

###### 求连通分量的方法

- 并查集：几个根节点=几个连通分量【无向图】
- tarjan

##### 2.More is better

为了计算每个集合的元素个数，我们不妨在表示每个集合的树的根结点记录该集合所包含的元素个数，在合并时累加被合并两个集合包含的元素个数。

```c++
roota = findRoot(a); 
rootb = findRoot(b); 
if (roota != rootb) { 
   Tree[roota] = rootb; 
   sum[rootb] += sum[roota];//合并两集时,将成为子树的树的根结点上保存的该集 合元素个数的数字累加到合并后新树的树根 
}
```

#### 最小生成树

**无向**连通图中，如果存在一个**连通**子图包含原图中**所有的结点和部分边**，且这个子图**不存在回路**，那么我们称这个子图为原图的一棵<u>生成树</u>。

在**带权**图中，所有的生成树中**边权的和最小**的那棵（或几棵）被称为<u>最小生成树</u>。 

如在通信基站之间修建通信光缆使所有的基站间可以直接或间接通信，最少需要多少长的光缆。

###### Kruskal

步骤：

1. 初始时所有结点属于孤立的集合。
2. 按照边权递增顺序遍历所有的边，若遍历到的边两个顶点分属不同的集合，则确定该边为最小生成树上的一条边，并将这两个顶点分属的集合合并。 
3. **遍历完所有边后**，原图上所有结点属于同一个集合则被选取的边和原图中所有结点构成最小生成树；
4. <u>否则原图不连通</u>，最小生成树不存在。

###### 可判断是否原图连通

用途：

- 可以判断整个图是否连通。
- 对于连通所有点+边权和最小的问题。【无向带权】

用Kruskal算法求解最小生成树的过程中涉及到大量的集合操作，可以用并查集来实现这些操作。

如果题中有说，可能有不存在最小生成树的情况。那么要对所有结点是否属于同一个集合进行判断，如以下代码的judge。

```c++
#include <iostream>
#include <queue>
using namespace std;
#define max 200

int MST; //  最小生成树
int Nodenum;
int father[max];
struct edge {
  int from;
  int to;
  int cost;
  friend bool operator < (const edge& a, const edge& b) {
    return a.cost > b.cost; //注意优先队列中的排序是反的
  }
};
// to find the minimal distance of edge.
priority_queue<edge> SQ;

int find(int x) {
  return x == father[x] ? x : find(father[x]);
}
int Kruskal() {
  MST = 0;
  for (int i = 1; i <= Nodenum; i++) {
    father[i] = i;
  }
  int num = 0;
  while (!SQ.empty() && num != Nodenum - 1) {
    edge temp = SQ.top();
    SQ.pop();
      //union
    int father_x = find(temp.from);
    int father_y = find(temp.to);
    if (father_x != father_y) {
      father[father_y] = find(father[father_x]);
      MST += temp.cost;
      num++;
    }
  }
  /**
   *  Let every index has their final father.
   */
  for (int i = 1; i <= Nodenum; i++) {
    father[i] = find(father[i]);
  }
  return MST;
}
bool judge() {
  int flag = father[1];
  for (int i = 2; i != Nodenum + 1; i++) {
    if (flag != find(father[i])) {
      return false;
    }
  }
  return true;
}
int main() {
  int edgeNum; //  边总数
  cin >> Nodenum;
  cin >> edgeNum;
  while (!SQ.empty()) {
    SQ.pop();
  }
  while (edgeNum--) {
    int from; int to; int cost;
    cin >> from >> to >> cost;
    edge a;
    a.from = from;
    a.to = to;
    a.cost = cost;
    SQ.push(a);
  }
  int MST = Kruskal();
  if (judge()) {
    cout << MST << endl;
  } else {
    cout << "Don't exist!" << endl;
  }
  return 0;
}
```

Prim算法和Kruskal算法的比较

- 稠密图：边数很多，边数接近于完全图
- Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣
- 因此边多的图用Prim【毕竟是加点法，考虑的点少】
- 边少的图，相对节点多，用Kruskal【毕竟是加边法，考虑的边少，速度快】

注意！！！！：优先队列中使用<和普通的重载<是相反的

#### 最短路径

###### Floyd

求非负权的无向图的，多个结点对之间的最短路径【多源最短路径】

- 用邻接矩阵保存原图
- 初始时：邻接矩阵中 edge[i][j]的值即表示从结点 i 到 结点 j，中间不经过任何结点时距离的最小值
  - **若它们之间有多条边，取最小权值保存至邻接矩阵；**
  - 也可能为无穷，即不可达
- 依次允许中间经过的结点为：结点 1、结点 2、……直到结点N
- 当添加完这些结点后，得到从结点i到结点j允许经过所有结点的最短路径长度

```c++
for (int k = 1;k <= n;k ++) { //途径节点最外层
   for (int i = 1;i <= n;i ++) { //起点 
    for (int j = 1;j <= n;j ++) { //终点
         if (ans[i][k] == 无穷 || ans[k][j] == 无穷) continue; 
         if( ans[i][j]= = 无穷 || ans[i][k]+  ans[k][j]<  ans[i][j]) 
          	ans[i][j] = ans[i][k] + ans[k][j]; 
    } 
   } 
}
```

注意!!!!!三层循环的顺序要正确

###### Dijkstra

Dijkstra 算法只能求得某特定结点到其它所有结点的最短路径长度，即单源最短路路径问题

算法步骤【假设起点为s的单源最短路径】：

1. 声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T。【两个集合一个dis，一个T】
2. 初始过程：
  - **起点 s 的路径权重被赋为 0 （dis[s] = 0）**。
  - **对于顶点 s 存在能直接到达的点m，设dis[m]为w（s, m）**
  - **s不能直接到达的顶点的路径长度设为无穷大**。
3. 初始时，集合T只有顶点s。 
4. **选择dis数组的最小值**，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 
5. 看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 
6. 重复上述4和5步骤，直到T中包含了图的所有顶点。

时间复杂度：

- O(E+VlgV)(用堆优化后)
- O(V²)(未优化)

```c++
//堆优化，堆找出最值的时间为O(logn)
#include <iostream>  
#include <cstdio>  
#include <queue>  
#include <vector>  
using namespace std;  
const int Ni = 10000;  
const int INF = 1<<27;  
struct node{  
    int x,d;  
    node(){}  
    node(int a,int b){x=a;d=b;}  
    bool operator < (const node & a) const  
    {  
        if(d==a.d) return x<a.x;  
        else return d > a.d;//d>a.d则交换，因此是小的先出堆  
    }  
};  
//邻接表
vector<node> eg[Ni]; //eg[i]存储起点为i的所有边，eg[i][j].x为起点为i的第j条边的终点为x，权值为d
int dis[Ni],n;  
void Dijkstra(int s)  
{  
    int i;  
    for(i=0;i<=n;i++) dis[i]=INF;  
    dis[s]=0;  
    //用优先队列优化  
    priority_queue<node> q; //取出最小值
    q.push(node(s,dis[s])); //初始放入起点节点
    while(!q.empty())  
    {  
        node x=q.top();q.pop(); //得到队列最小值
        for(i=0;i<eg[x.x].size();i++)  //由此更新出边的所有节点
        {  
            node y=eg[x.x][i];  
            if(dis[y.x]>x.d+y.d)  
            {  
                dis[y.x]=x.d+y.d; 
                q.push(node(y.x,dis[y.x])); //如果松弛了，那么这个更小路径就可以去更新其他点
            }  
            //如果没有松弛，那不需要等待出堆更新其他节点，反正没有变化，没有可能通过它中转更小
        }  
    }  
}  
```

```c++
#include <stdio.h> 
#include <vector> 
using namespace std; 
struct E{ //邻接链表中的链表元素结构体 
 int next; //代表直接相邻的结点 
 int c; //代表该边的权值(长度) 
};  
vector<E> edge[101]; //邻接链表 
bool mark[101];//标记,当mark[j]为true时表示结点j的最短路径长度已经得到,该结点已经加入集合K 
int Dis[101]; //距离向量,当mark[i]为true时,表示已得的最短路径长度;否则,表示所有从结点1出发，经过已知的最短路径达到集合K中的某结点，再经过一条边到达结点i的路径中最短的距离 
int main () { 
 int n, m; 
 while (scanf ("%d%d",&n,&m) != EOF) {   
     if (n == 0 && m == 0) break;   
     for (int i = 1;i <= n;i ++) edge[i].clear(); //初试化邻接链表   
     while(m --) { 
       int a , b , c; 
       scanf ("%d%d%d",&a,&b,&c); 
       E tmp; 
       tmp.c = c; 
       tmp.next = b; 
       edge[a].push_back(tmp); 
       tmp.next = a; 
       edge[b].push_back(tmp); //将邻接信息加入邻接链表,由于原图为无向图,固 每条边信息都要添加到其两个顶点的两条单链表中 
     }
     for (int i = 1;i <= n;i ++) { //初始化 
       Dis[i] = -1; //所有距离为-1，即不可达 
       mark[i] = false; //所有结点不属于集合K 
      }    
     Dis[1] = 0; //得到最近的点为结点1,长度为0   
     mark[1] = true; //将结点1加入集合K   
     int newP = 1; //集合K中新加入的点为结点1   
     for (int i = 1;i < n;i ++) { //循环n-1次,按照最短路径递增的顺序确定其他n-1个点的最短路径长度 
       for (int j = 0;j < edge[newP].size();j ++) { //遍历与该新加入集合 K中的结点直接相邻的边 
            int t = edge[newP][j].next; //该边的另一个结点 
            int c = edge[newP][j].c; //该边的长度 
            if (mark[t] == true) continue; //若另一个结点也属于集合K,则跳过 
            if (Dis[t] == - 1 || Dis[t] > Dis[newP] + c) //若该结点尚不可达,或者该结点从新加入的结点经过一条边到达时比以往距离更短 
             Dis[t] =  Dis[newP] + c; //更新其距离信息 
       } 
       int min = 123123123; //最小值初始化为一个大整数,为找最小值做准备 
       for (int j = 1;j <= n;j ++) { //遍历所有结点 
            if (mark[j] == true) continue; //若其属于集合K则跳过 
            if (Dis[j] == -1) continue; //若该结点仍不可达则跳过 
            if (Dis[j] < min) {  //若该结点经由结点1至集合K中的某点在经过一条 边到达时距离小于当前最小值 
             min = Dis[j]; //更新其为最小值 
             newP = j; //新加入的点暂定为该点 
        } 
       } 
       mark[newP] = true;//将新加入的点加入集合K,Dis[newP]虽然数值不变，但意义发生变化，由所有经过集合K中的结点再经过一条边到达时的距离中的最小值变为从结点1到结点newP的最短距离
      }   printf("%d\n",Dis[n]); //输出 
     }
 return 0; 
}
```

注意！！！若由结点U到结点V的最短路径不存在，即他们不连通，那 么**当Dijstra算法完成以后，V结点仍然不属于集合K**。即<u>当完成Dijstra算法后， mark[V]依然为 false 即说明，结点 U 到结点 V 的最短路不存在</u>。

要求解包含负权值边上的最短路问题，需要使用SPFA算法。

#### 练习题

- 这两题都很好，可再做
- 九度OJ1100 最短路径（需要使用高精度整数）；【可以用dijkstra+大整数模板或者用最小生成树】
  - 第k条路径的长度为2^K，则第k条路径的长度会大于前k-1条路径的总和。 
- 九度 OJ1162  I wanna go home（提示：对跨越两个阵营的边只保存单向边即可）；
  - 在一个国家有两个group，记做1和2，N个city，每个city属于1或者2。每两个city间有一定的距离，现在要从city1去city2，问最短的距离是多少，要求至多只有一次穿越时跨过分属不同group的city。city1总是属于group1，city2总属于group2。
  - 既然最多只能走一次跨过两个阵营的边，且必须从city1【属于group1】出发到city2【属于group2】，那么对于跨过两个阵营的边，必须走一次且仅一次，且是group1->group2。
  - 如果两个city属于一个group，就建双向图，否则就建从属于group1的city到属于group2的city的单向图。【另外一个方向就是无穷大】
  - 一次dijkstra就够了
  - 注意无解的情况

#### 拓扑排序

在**有向无环图（DAG 图）**中，对于所有的有向边（U，V）(由U指向V)，在该序列中结点U都排列在结点V之前。

##### 思路：

- 邻接表存图！！！但是不需要边权信息，因此vector\<**int**\> e[N]即可
- 首先，**所有有入度（即以该结点为弧头的弧的个数）的结点均不可能排在第一个**。
- 那么，我们**选择一个入度为0的结点**，作为序列的第一个结点。
- 当该结点被选为序列的第一个顶点后，我们将**该点从图中删去**，同时删去相关边，得到一个新图。
- 在新图上选择一个入度为0的结点，将其作为原图的第二个结点，并在新图中删去该点以及相关边。
- 若**在所有结点尚未被删去时**即出现了<u>找不到入度为0的结点</u>的情况，则说明剩余 的结点形成一个环路，原图不存在拓扑序列。 

###### 可用于判断环！！

涉及到“pairs”、"环路"、次序问题要考虑，本方法

无论何时，当需要判断某个图是否属于有向无环图时，我们都需要立刻联想到拓扑排序。

- 若一个图，存在符合拓扑次序的结点序列，则该图为有向无环图；【若在该图上拓扑排序成功】
- 反之，该图为非有向无环图

##### 实现

熟悉STL——queue\<int\> Q; 

将建立一个保存对象为int的队列Q，其相关操作如下： 

- Q.push(x);将元素x放入对尾； 
- x = Q.front();读取对头元素 
- Q.pop();对头元素弹出； 
- Q.empty();判断队列是否为空

每当出现一个入度为0的结点，我们将其放入队列；若需要找到 一个入度为0的结点，就从对头取出。【使用队列仅仅为了保存入度为0的结点，而与队列先进先出性质无关。因此，也可以使用栈来保存[出入顺序无所谓]，这与拓扑排序本身的原理无关】

```c++
#include <stdio.h>
#include <vector>
#include <queue>
using namespace std;
vector<int> edge[501]; //邻接链表,因为边不存在权值,只需保存与其邻接的结点编号即可,所以vector中的元素为int
int queue<int> Q; //保存入度为0的结点的队列
int main () {
	int inDegree[501]; //统计每个结点的入度
	int n , m;
	while (scanf ("%d%d",&n,&m) != EOF) {
		if (n == 0 && m == 0) break;
		//初始化
		for (int i = 0; i < n; i ++) {
			inDegree[i] = 0; //初始化入度信息,所有结点入度均为0
			edge[i].clear(); //清空邻接链表
		}
		while(m --) {
			int a , b;
			scanf ("%d%d",&a,&b); //读入一条由a指向b的有向边
			inDegree[b] ++; //又出现了一条指向b的边,累加结点b的入度
			edge[a].push_back(b); //将b加入a的邻接链表
		}
		while (Q.empty() == false) Q.pop(); //若队列非空,则一直弹出队头元素,该 操作的目的 为清空队列中所有的元素(可能为上一组测试数据中遗留的数据)
		for (int i = 0; i < n; i ++) { //统计所有结点的入度
			if (inDegree[i] == 0) Q.push(i); //若结点入度为0,则将其放入队列
		}
		int cnt = 0; //计数器,初始值为0,用于累加已经确定拓扑序列的结点个数
		while (Q.empty() == false) { //当队列中入度为0的结点未被取完时,重复
			int nowP = Q.front(); //读出队头结点编号,本例不需要求出确定的拓扑序列, 固不该结点紧接着放在已经确定的拓扑序列之后 做处理;若要求求出确定的拓扑次序,则将
			Q.pop(); //弹出对头元素
			cnt ++; //被确定的结点个数加一
			for (int i = 0; i < edge[nowP].size(); i ++) { //将该结点以及以其为起点/弧尾的所有边去除
				inDegree[ edge[nowP][i] ] --; //去除某条边后,更新该边所指后继结点入度
				if (inDegree[ edge[nowP][i] ] == 0) { //若该结点入度变为0
                     Q.push(edge[nowP][i]); //将其放入队列当中 
            } 
         } 
      }   
    if (cnt == n) puts("YES"); //若所有结点都能被确定拓扑序列,则原图为有向无环图   
    else puts("NO"); //否则,原图为非有向无环图 
    } 
    return 0; 
}
```

该代码<u>所有结点至多进入队列一次</u>，但在<u>每个结点被取出时我们都要遍历以其为弧尾的边</u>，固**复杂度为O（N+E）**，其中N为结点的个数，E为边的个数。 

#### 练习题

- 确定比赛名次
- 产生冠军



## 搜索

#### 枚举

枚举是最简单也是最直白的搜索方式，它依次尝试搜索空间中所有的解，测试其是否符合条件

使用枚举这种相对较为暴力的算法来进行解题时，我们对其时间复杂度要做特别的关注。

###### 注意避免除法

因为不论是对整型还是对于浮点型，除法都会产生精度损失，很有可能少量测试数据通不过，因此需要尽量将[除法---转化--->乘法]

#### BFS广搜

通过状态的**扩展转移**来遍历查找所有的状态。

可以将广搜的过程看成一棵树【也就是<u>解空间树</u>】，每一层扩展就是同一个高度的子节点组成。

即：将初始状态视为根节点，并将每一个状态扩展得到的新状态视为该状态的儿子结点，那么状态 的转移与生成就呈现出了树的形态，如下图

![](C:\Users\asus\spidermana.github.io\assets\img\wd2.png)

将这棵包含搜索空间中所有状态的树称为解答树，我们采用的搜索方法就是在**对这棵解答树进行<u>层次遍历</u>。**【使用普通队列来完成】

**估算复杂度：**根据层数【最多的走的步数】*每次扩展的状态数【走法】得到大概的复杂度

**剪枝：**

- 考虑到广度优先搜索中，先查找到的状态深度必不大于后查找到的状态深度，所以每个坐标的状态至多被扩展一次。故**使用标记数组bool vis\[\]\[\]来表示，已走，以后走不会更优，故下次走到不再扩展。**
- 最优性剪枝

```c++
bool mark[50][50][50]; //标记数组 
int maze[50][50][50]; //保存立方体信息 
struct N { //状态结构体 
    int x , y , z; 
    int t; 
};
queue<N> Q; //队列,队列中的元素为状态 
int go[][3] = {//走法
 1,0,0, 
 -1,0,0, 
 0,1,0, 
 0,-1,0, 
 0,0,1, 
 0,0,-1 };
int BFS(int a,int b,int c) { //广度优先搜索,返回其最少耗时
	while(Q.empty() == false) { //当队列中仍有元素可以扩展时循环
		N now = Q.front(); //得到队头状态   Q.pop(); //从队列中弹出队头状态
		for (int i = 0; i < 6; i ++) { //依次扩展其六个相邻节点
			int nx = now.x + go[i][0];
			int ny = now.y + go[i][1];
			int nz = now.z + go[i][2]; //计算新坐标
			if (nx < 0 || nx >= a || ny < 0 || ny >= b || nz < 0 || nz >= c) continue; //若新坐标在立方体外,则丢弃该坐标
			if (maze[nx][ny][nz] == 1) continue; //若该位置为墙,则丢弃该坐标
			if (mark[nx][ny][nz] == true) continue; //若包含该坐标的状态已经被 得到过,则丢弃该状态
			N tmp; //新的状态
			tmp.x = nx;
			tmp.y = ny;
			tmp.z = nz; //新状态包含的坐标
			tmp.t = now.t + 1; //新状态的耗时
			Q.push(tmp); //将该状态放入队列
			mark[nx][ny][nz] = true; //标记该坐标
			if (nx == a - 1 && ny == b - 1 && nz == c - 1) return tmp.t; // 若该坐标即为终点,可直接返回其耗时
		}
	}
	return -1; //若所有的状态被查找完后,仍得不到所需坐标,则返回-1
}
```

###### 注意：

- 使用广搜来完成搜索题目，需要**确定状态**
- 提示词：用广搜解决<u>搜索类、空间/地图枚举类</u>问题，一般对于<u>最优、最快达到、最少步数</u>这类问题使用广搜

#### 递归

<u>递归方式</u>和<u>递归出口</u>是递归函数两个重要的要素

仅将当前问题与规模更小的问题联系起来，并利用此关系确定递归关系式。

为了确定递归的出口，必须在问题较小时返回事先计算得到的答案

##### 递归的应用

- 枚举
- 图的遍历

##### 练习题

- 全排列

#### DFS深搜

假如我们改变对解答树的遍历方式，改为优先遍历层次更深的状态，直到遇到一个状态结点，其不再拥有子树，则返回上一层，访问其未被访问过的子树，直至解答树中所有的状态都被遍历完毕。这个过程，类似于**树的前序遍历**

<u>当深度优先搜索搜索到我们需要的状态时，其不再具有某种最优的特性</u>。

所以，在**使用深度优先搜索**时，我们**更多的求解有或者没有的问题**，即对解答树是否有我们需要的答案进行判定，而<u>一般不使用深度优先搜索求解最优解问题</u>

- 是否存在指定条件的解

##### Temple of the bone剪枝分析

主人公每走一步时，其所在位置坐标中，**只有一个坐标分量发生增一或者减一的改变，那么两个坐标分量和的奇偶性将发生变化。**这样， <u>当主人公走过奇数步时，其所在位置坐标和的奇偶性必与原始位置不同；而走过偶数步时，其坐标和的奇偶性与起点保持不变</u>。若起点的坐标和的奇偶性和终点 的坐标和不同，但是需要经过偶数秒使其刚好达到，显然的这是不可能的【起点坐标的奇偶性和终点坐标不同说明，要走奇数步才行。但是给出了偶数秒的时间，那么肯定不能在开门的时刻到达，因此可以直接判断为不可能到达】，于是我们直接判定这种情况下，整棵解答树中都不可能存在我们所需的状态，跳过搜索部分，直接输出 NO。 