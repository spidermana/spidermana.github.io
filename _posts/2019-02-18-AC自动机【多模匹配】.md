---
title:AC自动机
date: 2019-02-18 14:32:00
tags：算法

---



https://www.cnblogs.com/yym2013/p/3880445.html

https://www.cnblogs.com/cmmdc/p/7337611.html

## 算法详解

#### 1.前言

首先简要介绍一下**AC自动机**：Aho-Corasick automation，该算法在1975年产生于贝尔实验室，是**著名的多模匹配算法之一**。【这里的匹配是指：如果说B可以匹配到A，则A是B的子串，B中有连续不间断且完全相等的A串】

<u>一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。</u>

要搞懂AC自动机，**先得有模式树（字典树）Trie和KMP模式匹配算法的基础知识**。

- KMP算法是单模式串的字符匹配算法

  - 学习参考链接：https://www.cnblogs.com/yjiyjige/p/3263858.html
  - 求next数组【单模式串的前后缀KMP匹配思想】——j>k，如果pj等于pk，next[j+1]=k+1，如果如果pj不等于pk，那么如果要前后缀的匹配就调到前面匹配的地方，k=next[k]，继续尝试匹配，重新慢慢计算到next[j+1]。
  - 模式串和目标串的KMP匹配思想

- AC自动机是多模式串的字符匹配算法

  - 学习参考链接：https://www.cnblogs.com/cmmdc/p/7337611.html

  - 对<u>待匹配单词集</u>建立字典树，标记每个单词的结尾，避免重复计数

  - 求fail指针：在AC自动机中，我们也有类似next数组的东西就是fail指针，当发现失配的字符失配的时候，跳转到fail指针指向的位置，然后再次进行匹配操作，AC自动机之所以能实现多模式匹配，就归功于Fail指针的建立。

    - 思想：**当前节点t有fail指针，其fail指针所指向的节点和t所代表的字符是相同的**。因为t匹配成功后，我们需要去匹配t->child，发现失配，那么就从t->fail这个节点开始再次去进行匹配。

    - Fail指针的求法【用BFS来求得】：

      1.对于直接与根节点相连的节点来说，如果这些节点失配，他们的Fail指针直接指向root即可，

      2.对于其他节点来说，假设当前节点为father，其孩子节点记为child。**求child的Fail指针时，首先我们要找到其father的Fail指针所指向的节点,假如是t的话，我们就要看t的孩子中有没有和child节点所表示的字母相同的节点，如果有的话，这个节点就是child的fail指针，如果发现没有，则需要找father->fail->fail这个节点，然后重复上面过程，如果一直找都找不到，则child的Fail指针就要指向root。**

      3.用一个队列来计算fail，这个队列q放着已经找到fail指针的节点，这些节点将会被扩展，即计算其子节点的fail【因为被扩展计算子节点fail的节点必须要已知fail，这样才可以计算出子节点的fail】。一开始这个队列只有root一个节点【设置其fail为null】

  - 利用字典树来匹配文本串，进行相应计数

    - 初始化文本串A下标i=0，从root开始匹配，A[i]和root的子孩子一直不匹配则i++【匹配失败，回到子节点的fail指针——即为root】，否则开始进入字典树
    - 当前字符匹配，表示从当前节点沿着树边有一条路径可以到达目标字符。
      1. 当前字符匹配则并且不是某个匹配串的结尾则i++，继续匹配
      2. 如果当前匹配的字符是一个单词的结尾【设有结尾标记】，我们**可以沿着当前字符的fail指针，一直遍历到根**，<u>如果这些节点末尾有标记</u>（此处标记代表，节点是一个单词末尾的标记），**这些节点全都是可以匹配上的节点**。我们统计完毕后，并将那些节点记录为已匹配【避免重复】。此后只需沿该路径走向下一个节点继续匹配即可，目标字符串指针++【i++】
      3. 当前字符不匹配，则到当前节点失败指针所指向的字符继续匹配，<u>匹配过程随着指针指向root结束。</u>
      4. 重复这2个过程中的任意一个，直到模式串走到结尾为止。

- 我的对AC的理解：

  - 我们现在有一个文本和一堆单词。要确定文本中是否有这些单词，找到文本中有的单词个数
  - 对这一堆单词构造Tire字典树，每个单词结尾对应的节点都做了标记。
  - 计算fail指针，一个节点的fail指针和这个节点的字母一样。
  - 传入文本，用Tire进行匹配。
  - 从文本的第一个字母开始【设置个当前待匹配的字符位置指针i】，从Tire树的根root开始深入，如果有子节点匹配【一次就是root->子节点中有没有和i=0处的文本字符匹配】，则深入一层，i++。
    - 如果一开始都没有匹配的，那就会一直回到root【root子节点的fail都指向root】
    - 如果匹配了很多字母了，就会深入到Tire中。
  - 一定要注意，走到某个节点K以后【这个K节点匹配了i位置的字符】，j=i+1，现在要匹配下一个字符【j位置】了。那么这下一个字符就要和K节点的子节点进行匹配【走到K说明K已匹配完了】。如果没有匹配的，那么就应该走到K节点的fail，而不是其子节点的fail【走到前缀相同，K是匹配前缀的最后一个字符，因此要走到父节点的fail，在这个父节点的fail节点找有没有子节点和j位置字符匹配】
  - 虽然匹配失败会走向fail节点，从而减少重复前缀匹配的时间浪费。但是这时候可能会匹配上另外一个单词【朝着另外一个单词的匹配道路上】，而不是匹配失败之前可能完成匹配的那个单词。
  - 但是一旦走到了一个有结尾标记的节点，就消去标记表示，这个单词匹配成功了。
  - 因此AC自动机就是少了很多相同前缀匹配的浪费。

  ```c++
  #include<iostream>
  using namespace std;
  const int kind=26;//匹配串的所有可能值，26个字母 
  struct node{
  	node *fail;
  	int count;//是否为单词的最后一个节点
  	node *next[kind]; //当前结点的子节点【最多26个】
  	node(){
  		fail=NULL;
  		count=0;//0表示不是单词的结尾，1表示单词的结尾，-1表示该单词已经匹配过，不要重复计算 
  		memset(next,NULL,sizeof(next));//孩子结点初始化 
  	} 
  }*q[500001];//队列，方便bfs时用，计算fail指针 
  char keyword[51];//用于构造Tire的单词  
  char str[1000001];//文本串
  int head,tail;//q[]队列指针 
  
  //构造Tire
  void insert(char *str,node *root){//传入keyword 
  	node *p=root;
  	int i=0,index;
  	while(str[i]){//单次串 
  		index=str[i]-'a';//0表示a，1表示b 
  		if(p->next[index]==NULL)
  			p->next[index]=new node();//调用构造函数 
  		p=p->next[index];//向下深搜 
  		i++;
  	}
  	p->count++;//在单词的最后一个节点count+1，代表一个单词
  	//一个节点若为单词的末尾，则其最多加一次，count最大值为1 
  } 
  //构造fail指针
  //假设当前节点为father，其孩子节点记为child。求child的Fail指针时，首先我们要找到其father的Fail指针所指向的节点。
  //假如是t的话，我们就要看t的孩子中有没有和child节点所表示的字母相同的节点，如果有的话，这个节点就是child的fail指针， 
  //如果发现没有，则需要找father->fail->fail这个节点，然后重复上面过程，如果一直找都找不到，则child的Fail指针就要指向root。
  void build_ac_automation(node *root){//每个节点的fail指针一定会有公共前缀 
  	int i;
  	root->fail=NULL;
  	q[head++]=root;
  	while(head!=tail){//队列不为空 
  		node *temp=q[tail++];//出队，队首元素
  		//队列q。放着已经找到fail指针的节点，这些节点将会被扩展，即计算其子节点的fail 
  		node *p=NULL;
  		for(int i=0;i<26;i++){
  			if(temp->next[i]!=NULL){//该子节点存在，要计算其fail指针 
  				if(temp==root)//如果是root的子节点，那么fail指针一定就是root了 
  					temp->next[i]->fail=root;
  				else{//如果是非root的子节点 
  					p=temp->fail;
  					while(p!=NULL){
  						if(p->next[i]!=NULL){
  							temp->next[i]->fail=p->next[i];//子节点的fail指针 
  							break;
  						}
  						p=p->fail;
  					}
  					if(p==NULL)//都找到root->fail了还没有找，那直接把这个子节点的fail指向root 
  						temp->next[i]->fail=root;
  				}
  				q[head++]=temp->next[i];
  			}
  		} 
  	}	
  }
  int query(node *root){
  	int i=0;
  	int cnt=0;//匹配的单词种类数目
  	int index,len=strlen(str); 
  	node *p=root;
  	while(str[i]){
  		index=str[i]-'a';
  		//由于root->fail=null,因此如果从root其就没有子节点和i位置字符匹配了，那么要保持跳转到root，而不是跳转到root->fail=null 
  		while(p->next[index]==NULL&&p!=root){//跟我的子节点有没有匹配【因为是从root起，root不用考虑匹配，所以总是判断当前节点的子节点有没有匹配的】 
  			p=p->fail;//子节点不匹配，则换相同字符的父节点，】看这个父节点有没有子节点和str[i]匹配。 
  		}
  		p=p->next[index];
  		p=(p==NULL)?root:p;//此时p==NULL，说明是上面的while是因为p=root出来的，那么p保持root。否则此时p已经和str[i]匹配了 
  		node *temp=p;
  		while(temp!=root && temp->count!=-1){//temp！=root说明是当前字符匹配
  			cnt+=temp->count;//如果只是单词中间的匹配，那么这里count=0,cnt不会增加。否则是结尾匹配，cnt+1 
  			temp->count=-1;
  			temp=temp->fail;//跳到fail【相同字符处】，看看还有无子匹配，比如she匹配，跳到he处，也匹配 
  		}
  		i++;//继续匹配下一个字符 
  	} 
  	return cnt; 
  }
  int main(){
  	
  	
  	
  	
  	
  	return 0;
  }
  ```

  

#### 2.KMP算法

求next数组【模式串自身匹配】+模式串对主串的匹配

## 相关例题

[HDU-3695 Computer Virus on Planet Pandora](http://acm.hdu.edu.cn/showproblem.php?pid=3695)

题意：电脑中病毒了， 现在n钟病毒指令， 然后有一个电脑指令， 看一下这个电脑指令中了几个病毒， 如果电脑种了某一个病毒， 那么就有子串是病毒指令， 或者 子串的反串是病毒指令， 现在问电脑指令一共感染了多少病毒。

题解：AC自动机，然后正向匹配一遍， 反向匹配一遍。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#define N 5555555
using namespace std;
struct node
{
    node *fail;
    node *next[26];
    int cnt;
    node ()
    {
        fail=0;
        cnt=0;
        memset(next,0,sizeof(next));
    }
};
node *root=NULL;
void insert(char *str)
{
    int i=0,index;
    node *p=root;
    while(str[i]!='\0')
    {
        index=str[i]-'A';
        if(p->next[index]==NULL)
            p->next[index]=new node;
        p=p->next[index];
        i++;
    }
    p->cnt++;
}
void build()
{
    int i;
    root->fail=NULL;
    queue<node*> q;
    q.push(root);
    while(!q.empty())
    {
        node *tmp=q.front();
        q.pop();
        node *p=NULL;
        for(i=0;i<26;i++)
        {
            if(tmp->next[i])
            {
                if(tmp==root)
                    tmp->next[i]->fail=root;
                else
                {
                    p=tmp->fail;
                    while(p)
                    {
                        if(p->next[i])
                        {
                            tmp->next[i]->fail=p->next[i];
                            break;
                        }
                        p=p->fail;
                    }
                    if(p==NULL)
                        tmp->next[i]->fail=root;
                }
                q.push(tmp->next[i]);
            }
        }
    }
}
int query(char *str)
{
    int i=0,cnt=0,index;
    node *p=root;
    while(str[i]!='\0')
    {
        //cout<<i<<endl;
        index=str[i]-'A';
        while(p->next[index]==NULL&&p!=root)
            p=p->fail;
        p=p->next[index];
        p=(p==NULL)?root:p;
        node *tmp=p;
        while(tmp!=root&&tmp->cnt!=-1)
        {
            cnt+=tmp->cnt;
            tmp->cnt=-1;
            tmp=tmp->fail;
        }
        i++;
    }
    return cnt;
}
char s1[N],s2[N];
void input()
{
    int p=0;
    char c;
    getchar();
    while(c=getchar(),c!='\n')
    {
        if(c!='[')
            s1[p++]=c;
        else
        {
            int x;
            scanf("%d",&x);
            c=getchar();
            while(x--)
                s1[p++]=c;
            getchar();
        }
    }
    for(int q=0;p>0;q++)
        s2[q]=s1[--p];
    //cout<<s1<<" "<<s2<<endl;
}
void del(node *root)
{
    for(int i=0;i<26;i++)
        if(root->next[i])
            del(root->next[i]);
    delete root;
}
int main()
{
//    freopen("in.txt","r",stdin);
//    freopen("out.txt","w",stdout);
    int t,n;
    scanf("%d",&t);
    char str[1005];
    while(t--)
    {
        root=new node;
        memset(s1,'\0',sizeof(s1));
        memset(s2,'\0',sizeof(s2));
        scanf("%d",&n);
        while(n--)
            scanf("%s",str),insert(str);
        build();
        input();
        printf("%d\n",query(s1)+query(s2));
        del(root);
    }
    return 0;
}

```

