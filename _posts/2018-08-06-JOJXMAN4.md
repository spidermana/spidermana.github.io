---
title: JarvisOJ——XMANlevel4题解
date: 2018-08-6 14:10:00
tags:
- CTF
categories:
- CTF
---

day5：XMANlevel4

## DynELF模块介绍及简单使用 ##

### 1.DynELF模块介绍及使用条件 ###
DynELF是用于泄漏[leak]地址信息的模块,通过反复调用泄露漏洞，在被攻击机器的内存中不断搜索地址信息。官网给出的说明是：Given a function which can leak data at an arbitrary address, **any symbol in any loaded library can be resolved[任何程序加载的库内的符号(函数)都可以被leak出地址信息]**.


**在没有目标系统libc文件[会被程序默认加载]的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。**本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。


DynELF是**pwntools中专门用来应对无libc情况的漏洞利用模块**，其基本代码框架如下：

    p = process('./xxx')
    def leak(address):
      #各种预处理
      payload = "xxxxxxxx" + address + "xxxxxxxx" 
      p.send(payload)
      #各种处理
      data = p.recv(4)
      log.debug("%#x => %s" % (address, (data or '').encode('hex')))
      return data
    
    d = DynELF(leak, elf=ELF("./xxx"))  #初始化DynELF模块，感觉leak就是一个为d实体定制的模板化攻击工具，可以引入各种库文件，寻找库中函数地址
    
    systemAddress = d.lookup('system', 'libc')  #在libc文件中搜索system函数的地址
    
需要使用者进行的**工作主要集中在leak函数的具体实现**上，上面的代码只是个模板。其中，*address*就是leak函数要*泄漏信息的所在地址*，而*payload*就是*触发目标程序泄漏address处信息的攻击代码*。

**使用条件：**
不管有没有libc文件，要想获得目标系统的system函数地址，首先都**要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞[存储栈溢出攻击点]**。同时，由于我们是**在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用**。

以下是大致归纳的主要使用条件：

- 1）**目标程序存在可以泄露libc空间信息的漏洞**，如read@got就指向libc地址空间内[存在调用libc库中的函数，比如 read, write,getchar, fopen,fclose,fgets,freopen,fseek,fprintf，这些函数的地址就可以被找到]；
- 2）**目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息**[类似于XMANlevel3中的二次溢出，通过调用第二次vulnerable_function实现第二次溢出，这样不断将漏洞地址放置在%ebp+4就可以反复利用溢出点]。

### 2.DynELF模块实战 ###

当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。

https://blog.csdn.net/u011987514/article/details/68490157

https://blog.csdn.net/guiguzi5512407/article/details/52752909







## ROP攻击 ##

https://blog.csdn.net/smalosnail/article/details/53386353

## XMAN level4题解思路 ##



## 解题步骤 ##



## 补充 ##
1.
    ssize_t read [1]  (int fd, void *buf, size_t count);//写入内存
参数fd所指的文件传送count个字节到buf指针所指的内存中。[参数fd为文件描述符：标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2]

2.
**ROP的全称为Return-oriented programming（返回导向编程）**，这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）

3.
64位机器栈帧间的参数传递：在64位机器上参数的传递，前6个参数[从左向右数前6个]分别保存在rdi,rsi,rdx,rcx,r8和r9寄存器中,但是从第七个参数开始就要从右向左入栈[最后一个参数先入栈，最后入栈第7个参数]

4.通用gadget_libc_csu_init的使用
![64位机器下参数传递情况](/assets/img/machine64.jpg)

参考链接：

- https://blog.csdn.net/zszcr/article/details/79758677

- http://www.cnblogs.com/Ox9A82/p/5487725.html

----------
### 5.Cyclic Pattern ###

Cyclic pattern是pwntools中一个很强大的功能，大概作用是：**使用pwntools生成一个pattern[pattern就是指一个字符串]，可以通过其中的一部分数据去定位到一个字符串中的位置[具体看下面的例子理解]。**

有了这个模块，**在进行栈溢出攻击，使用pattern可以大大的减少计算溢出点的时间**。 

用法：

    cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串，可以标识各个位置
    cyclic_find(0x61616161) # 找到0x61616161数据在pattern中的位置
    cyclic_find('aaaa') # 查找位置也可以使用字符串去定位

比如，我们在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，作为程序的输入。输入后，退栈ret时，pattern的一部分pop到了%eip[ret指令]，%eip的值变为了pattern的一部分，由于SIGSEGV段错误，程序终止，会输出类似于“0x6261616b in ??()”这样的错误，即这样的内存地址在内存中非法，那么我们通过cyclic_find(0x6261616b)得到从pattern的哪一个字节开始[字节偏移量]控制%eip寄存器了，从而得到缓冲区的大小。

    $ cyclic 1000
    $ cyclic -l 0x6261616b
      140  #字节偏移140处溢出到返回地址的位置