---
layout:     post
title:      " 「MIT 6.828」MIT 6.828 Fall 2018 lab2"
subtitle:   "lab2开始了，猴多啊…… "
date:       2019-06-03 14:37:00
author:     "许大仙"
catalog: true
tags:
    - 系统
---

## Lab2—Memory management

### 回顾

在lab1中，完成了实模式【16bits】到保护模式【32bits】的转换，但是在系统真正要接管内存【在cr0开启地址转换】，分配真正页表之前，要有一个简单的页表将kernel code载入到内存中【赋值到cr3】。

即kern/entrypgdir.c，设置了虚拟地址0x00000000-0x00400000以及0xF0000000-0xf0400000都映射到物理地址的[0, 4MB)【引用这些地址范围以外的虚拟地址将会抛出缺页的异常】，只管理了部分虚拟空间。此后entry.S跳转到了虚拟地址空间的高地址部分来继续运行kernel，最后跳转到i386_init()中【此前设置好了内核栈，可执行c代码】，此后在cmd上打印了一系列字符【利用printf等】，而后调用mem_init()。

bootloader读入内核代码之后的分布【实际物理内存分布】：

[![img](http://lzz5235.github.io/assets/pic/235.png)](http://lzz5235.github.io/assets/pic/235.png)

开启分页的机制以后，寻址方式变为【逻辑地址-线性地址-物理地址】：

[![img](http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg)](http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg)

对虚拟内存空间来说，可以划分为代码段、数据段、堆栈段等等部分，对于每个段的访问，都是通过基地址+偏移量来访问的。基地址是通过段寄存器的值在描述符表中的偏移来获得，而偏移量就是我们所说的逻辑地址；并且，线性地址 = 基地址+偏移地址(逻辑地址)；物理地址则是通过线性地址来寻找，通过页表的方式来获取。【分段->分页】

JOS的内核地址变换过程如下：JOS内核开始执行后，执行在0x0010 0000处，此后由于开启分页机制，虚拟内存机制也随之一同开启，此后JOS内核将会在虚拟内存空间中的**KERNBASE**(0xF000 0000)处执行，更重要的是，**此后的JOS代码执行将全部使用虚拟内存地址**。
 由于分页机制需要使用页表，在完整的分页机制建立之前，JOS使用了一个“**人工手写**”的映射关系，将<u>虚拟内存空间中[KERNBASE, KERNBASE+4MB) 、 [0, 4MB)的地址一同映射到物理内存[0, 4MB)处。</u>上述代码中**entry_pgdir**就指向了手写页表的基地址。
在上述过程完成后，内核将跳转至i386_init()->**mem_init()(/kern/pmap.c)**处执行，主要的执行代码在**/kern/pmap.c**文件下，该文件主要完成虚拟地址到物理地址之间的转换，即页表的建立，为此后的系统内存分配提供了保证。

### Introduction

本实验将为OS设计一个内存管理器【memory management code】

Memory management 由两个部分组成：

- 物理内存分配器：为内核分配物理内存，从而内核可分配并且释放内存。
  - 分配器以4KB单位进行分配，即页大小=4KB
  - write the routines to allocate and free pages of memory.
  - how many processes are sharing each allocated page.
- 虚拟内存：将用户软件和内核使用的虚拟地址映射到物理地址
  - The x86 hardware's memory management unit (MMU) performs the mapping when instructions use memory, consulting a set of page tables
  - 当指令访问内存时，虚拟地址-物理地址的映射由MMU完成【具体依据页表来完成】

Lab2将会包含以下源文件：

- inc/memlayout.h
- kern/pmap.c
- kern/pmap.h
- kern/kclock.h
- kern/kclock.c

inc/memlayout.h描述了虚拟地址空间的整体布局，可以通过修改pmap.c以实现具体内容【pmap.c中访问RAM硬件设备以确定有多少物理内存的这一部分代码以实现，不需要知道CMOS硬件工作的具体细节】。

`memlayout.h` 和 `pmap.h` 定义了`PageInfo` 数据结构，可通过此结构来追溯物理页是否已释放。

`kclock.c` 和 `kclock.h` 操作了电池驱动的PC时钟和CMOS RAM硬件【这里的BIOS中存储了PC包含的物理内存数量】，从而`pmap.c`需要读取这个硬件设备，搞清楚到底有多少物理内存。

在实验开始前先熟悉`memlayout.h`、`pmap.h` ，回顾 `mmu.h`文件 中的一些定义。

```python
    4 Gig -------->  +------------------------------+
                     |                              | RW/--
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     :              .               :
                     :              .               :
                     :              .               :
                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                     |                              | RW/--
                     |   Remapped Physical Memory   | RW/--
                     |                              | RW/--
    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
                     | - - - - - - - - - - - - - - -|                   |
                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
                     +------------------------------+                   |
                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
                     | - - - - - - - - - - - - - - -|                 PTSIZE
                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
                     +------------------------------+                   |
                     :              .               :                   |
                     :              .               :                   |
    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
                     |       Memory-mapped I/O      | RW/--  PTSIZE
 ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
    UVPT      ---->  +------------------------------+ 0xef400000
                     |          RO PAGES            | R-/R-  PTSIZE
    UPAGES    ---->  +------------------------------+ 0xef000000
                     |           RO ENVS            | R-/R-  PTSIZE
 UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
                     +------------------------------+ 0xeebff000
                     |       Empty Memory (*)       | --/--  PGSIZE
    USTACKTOP  --->  +------------------------------+ 0xeebfe000
                     |      Normal User Stack       | RW/RW  PGSIZE
                     +------------------------------+ 0xeebfd000
                     |                              |
                     |                              |
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     .                              .
                     .                              .
                     .                              .
                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
                     |     Program Data & Heap      |
    UTEXT -------->  +------------------------------+ 0x00800000
    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
                     |                              |
    UTEMP -------->  +------------------------------+ 0x00400000      --+
                     |       Empty Memory (*)       |                   |
                     | - - - - - - - - - - - - - - -|                   |
                     |  User STAB Data (optional)   |                 PTSIZE
    USTABDATA ---->  +------------------------------+ 0x00200000        |
                     |       Empty Memory (*)       |                   |
    0 ------------>  +------------------------------+                 --+
```

上图所示的是JOS的虚拟内存空间分布，JOS内核空间位于KERNBASE之上。在`/kern/pmap.c`中存在以下几个全局变量需要注意：

- kern_pgdir：内核一级页表指针/基地址
- pages : 页表信息指针/基地址，将物理内存划分成页后，每一个页i对应一个pages[i]
- page_free_list : 物理页表空闲链表



### Physical Page Management

OS必须跟踪物理RAM明确哪些是free、哪些是in use。JOS管理PC的物理内存是以page为单位/粒度的，因而PC可以使用MMU来映射和保护每一个已分配内存。

现在需要实现物理内存分配器，通过`struct PageInfo`对象来追溯哪些页面是free，每一个`struct PageInfo`对象对应一个物理页

注意：在实现物理内存分配器之后，才能实现虚拟内存的部分，因为需要物理内存分配以存储页表。

#### Exercise 1

实验的第一部分需要**完成一个物理页面分配器**，该分配器维护了一个`struct PageInfo`的链表来追踪空闲的物理页面（也就是空闲链表）。具体来说，就是在 `kern/pmap.c`,中 按照以下给定顺序实现function code

```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```

完成后可以启动JOS去观察`check_page_free_list()`以及`check_page_alloc()`函数是否成功以检查编写的分配器的正确性。

```
此任务不会描述您必须添加到JOS的代码的所有详细信息。
寻找你必须修改的JOS源部分的注释;这些注释通常包含规则规范和提示。
您还需要在英特尔手册中查看JOS的相关部分，也可以查看6.004或6.033注释。
```

第一部分的物理页面分配器总体来说难度不大，因为编写的分配器不像CSAPP中的`malloc()`一样，需要处理空闲内存的合并以及拆分【不会各种bins，eg：fast bin等】，而**该分配器只需要以物理页面为固定的粒度管理所有的内存即可。**

<u>但在实际的Linux系统中，内核使用Buddy System快速地管理内存。</u>【将内存分成多粒度管理，多级粒度大小的空闲页链表】

##### 页面初始化page_init部分

对于要实现的函数中，肯定是首先调用page_init和mem_init，但是在mem_init中调用了page_init，因此最先考虑实现的应该是page_init。

<u>页表初始化</u>在函数**page_init()**执行，将已经被占用的物理内存页对应的pages做标记，未被占用的物理内存页则加入空闲页链表。当申请空闲物理页时，在该链表的头部取出一个页信息节点；当释放一个物理页后，将此物理页对应的页信息节点放入链表尾部。

**来看看pmap.c中page_init的部分**

```c++
// 这个函数用于最终物理页，因此用于物理页数组的数据结构struct PageInfo一定会有这个物理页的入口
// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------
// 页面是引用计数的，free page 保存在空闲链表中。
// Initialize page structure and memory free list. 初始化page structure和页面空闲列表
// After this is done, NEVER use boot_alloc again.  ONLY use the page 
// 此后不会在运行 boot_alloc,而仅仅会使用物理页分配器来分配和回收物理页面
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
    // 下面的code例子，是将所有物理页面标记为free，但是显然不是，因为我们已经放置了BIOS，IO设备ROM，VGA Display，kernel等，因此这里要明确哪些内存free，哪些内存in use
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	for (i = 0; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
```

###### UVPT

UVPT: 需要看 https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html











先看看pmap.c中mem_init的部分

```c++
// Set up a two-level page table:   要设置二级页表
// kern_pgdir is its linear (virtual) address of the root 
// kern_pgdir负责完成root级别的虚拟地址映射【映射的方式是线性的】，
// 这个函数仅仅设置了内核空间，用户空间的设置将在之后完成
// This function only sets up the kernel part of the address space
// (ie. addresses >= UTOP).  The user part of the address space
// will be set up later.
// 
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
	panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:


	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
	check_page_alloc();
	check_page();

	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));

	check_page_free_list(0);

	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

	// Some more checks, only possible after kern_pgdir is installed.
	check_page_installed_pgdir();
}
```





























