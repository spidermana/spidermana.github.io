---
layout:     post
title:      " 「MIT 6.828」MIT 6.828 Fall 2018 lab2"
subtitle:   "lab2开始了，猴多啊…… "
date:       2019-06-03 14:37:00
author:     "许大仙"
catalog: true
tags:
    - 系统
---

## Lab2—Memory management

### 回顾

在lab1中，完成了实模式【16bits】到保护模式【32bits】的转换，但是在系统真正要接管内存【在cr0开启地址转换】，分配真正页表之前，要有一个简单的页表将kernel code载入到内存中【赋值到cr3】。

即kern/entrypgdir.c，设置了虚拟地址0x00000000-0x00400000以及0xF0000000-0xf0400000都映射到物理地址的[0, 4MB)【引用这些地址范围以外的虚拟地址将会抛出缺页的异常】，只管理了部分虚拟空间。此后entry.S跳转到了虚拟地址空间的高地址部分来继续运行kernel，最后跳转到i386_init()中【此前设置好了内核栈，可执行c代码】，此后在cmd上打印了一系列字符【利用printf等】，而后调用mem_init()。

bootloader读入内核代码之后的分布【实际物理内存分布】：

[![img](http://lzz5235.github.io/assets/pic/235.png)](http://lzz5235.github.io/assets/pic/235.png)

开启分页的机制以后，寻址方式变为【逻辑地址-线性地址-物理地址】：

[![img](http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg)](http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg)

对虚拟内存空间来说，可以划分为代码段、数据段、堆栈段等等部分，对于每个段的访问，都是通过基地址+偏移量来访问的。基地址是通过段寄存器的值在描述符表中的偏移来获得，而偏移量就是我们所说的逻辑地址；并且，线性地址 = 基地址+偏移地址(逻辑地址)；物理地址则是通过线性地址来寻找，通过页表的方式来获取。【分段->分页】

JOS的内核地址变换过程如下：JOS内核开始执行后，执行在0x0010 0000处，此后由于开启分页机制，虚拟内存机制也随之一同开启，此后JOS内核将会在虚拟内存空间中的**KERNBASE**(0xF000 0000)处执行，更重要的是，**此后的JOS代码执行将全部使用虚拟内存地址**。
 由于分页机制需要使用页表，在完整的分页机制建立之前，JOS使用了一个“**人工手写**”的映射关系，将<u>虚拟内存空间中[KERNBASE, KERNBASE+4MB) 、 [0, 4MB)的地址一同映射到物理内存[0, 4MB)处。</u>上述代码中**entry_pgdir**就指向了手写页表的基地址。
在上述过程完成后，内核将跳转至i386_init()->**mem_init()(/kern/pmap.c)**处执行，主要的执行代码在**/kern/pmap.c**文件下，该文件主要完成虚拟地址到物理地址之间的转换，即页表的建立，为此后的系统内存分配提供了保证。

### Introduction

本实验将为OS设计一个内存管理器【memory management code】

Memory management 由两个部分组成：

- 物理内存分配器：为内核分配物理内存，从而内核可分配并且释放内存。
  - 分配器以4KB单位进行分配，即页大小=4KB
  - write the routines to allocate and free pages of memory.
  - how many processes are sharing each allocated page.
- 虚拟内存：将用户软件和内核使用的虚拟地址映射到物理地址
  - The x86 hardware's memory management unit (MMU) performs the mapping when instructions use memory, consulting a set of page tables
  - 当指令访问内存时，虚拟地址-物理地址的映射由MMU完成【具体依据页表来完成】

Lab2将会包含以下源文件：

- inc/memlayout.h
- kern/pmap.c
- kern/pmap.h
- kern/kclock.h
- kern/kclock.c

inc/memlayout.h描述了虚拟地址空间的整体布局，可以通过修改pmap.c以实现具体内容【pmap.c中访问RAM硬件设备以确定有多少物理内存的这一部分代码以实现，不需要知道CMOS硬件工作的具体细节】。

`memlayout.h` 和 `pmap.h` 定义了`PageInfo` 数据结构，可通过此结构来追溯物理页是否已释放。

`kclock.c` 和 `kclock.h` 操作了电池驱动的PC时钟和CMOS RAM硬件【这里的BIOS中存储了PC包含的物理内存数量】，从而`pmap.c`需要读取这个硬件设备，搞清楚到底有多少物理内存。

在实验开始前先熟悉`memlayout.h`、`pmap.h` ，回顾 `mmu.h`文件 中的一些定义。

```python
    4 Gig -------->  +------------------------------+
                     |                              | RW/--
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     :              .               :
                     :              .               :
                     :              .               :
                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                     |                              | RW/--
                     |   Remapped Physical Memory   | RW/--
                     |                              | RW/--
    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
                     | - - - - - - - - - - - - - - -|                   |
                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
                     +------------------------------+                   |
                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
                     | - - - - - - - - - - - - - - -|                 PTSIZE
                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
                     +------------------------------+                   |
                     :              .               :                   |
                     :              .               :                   |
    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
                     |       Memory-mapped I/O      | RW/--  PTSIZE
 ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
    UVPT      ---->  +------------------------------+ 0xef400000
                     |          RO PAGES            | R-/R-  PTSIZE
    UPAGES    ---->  +------------------------------+ 0xef000000
                     |           RO ENVS            | R-/R-  PTSIZE
 UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
                     +------------------------------+ 0xeebff000
                     |       Empty Memory (*)       | --/--  PGSIZE
    USTACKTOP  --->  +------------------------------+ 0xeebfe000
                     |      Normal User Stack       | RW/RW  PGSIZE
                     +------------------------------+ 0xeebfd000
                     |                              |
                     |                              |
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     .                              .
                     .                              .
                     .                              .
                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
                     |     Program Data & Heap      |
    UTEXT -------->  +------------------------------+ 0x00800000
    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
                     |                              |
    UTEMP -------->  +------------------------------+ 0x00400000      --+
                     |       Empty Memory (*)       |                   |
                     | - - - - - - - - - - - - - - -|                   |
                     |  User STAB Data (optional)   |                 PTSIZE
    USTABDATA ---->  +------------------------------+ 0x00200000        |
                     |       Empty Memory (*)       |                   |
    0 ------------>  +------------------------------+                 --+
```

上图所示的是JOS的虚拟内存空间分布，JOS内核空间位于KERNBASE之上。在`/kern/pmap.c`中存在以下几个全局变量需要注意：

- kern_pgdir：内核一级页表指针/基地址
- pages : 页表信息指针/基地址，将物理内存划分成页后，每一个页i对应一个pages[i]
- page_free_list : 物理页表空闲链表

---

## Part 1: Physical Page Management

OS必须跟踪物理RAM明确哪些是free、哪些是in use。JOS管理PC的物理内存是以page为单位/粒度的，因而PC可以使用MMU来映射和保护每一个已分配内存。

现在需要实现物理内存分配器，通过`struct PageInfo`对象来追溯哪些页面是free，每一个`struct PageInfo`对象对应一个物理页

注意：在实现物理内存分配器之后，才能实现虚拟内存的部分，因为需要物理内存分配以存储页表。

### Exercise 1

You need to write the physical page allocator before you can write the rest of the virtual memory implementation, because your page table management code will need to allocate physical memory in which to store page tables.

In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).

```
boot_alloc()
mem_init() (only up to the call to `check_page_free_list(1)`)
page_init()
page_alloc()
page_free()
```

**`check_page_free_list()` and `check_page_alloc()` test your physical page allocator.** You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.

####  boot_alloc()

现在来按顺序实现，首先进行`boot_alloc(uint32_t n)`：

这是一个简单的物理内存分配器，仅仅会在JOS启动虚拟内存之前使用，而真正的内存分配器是`page_alloc()`。

- 如果n>0，那么分配的足够的连续物理内存页，并且不会初始化，返回一个kernel内存虚拟地址【因为这时候已经开启了页表地址转化模式，且有了初始的kernel的页表，因此返回的地址都是虚拟地址】
- n=0，则返回下一个free page的地址，并且不会分配任何内存。

根据上述表达完成代码如下：

```c
// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
//由于已经开启了分页机制，并且只在[0,4KM]和[KERNBASE,KERNBASE+4MB]设置了页表，所以在这之外的虚拟内存无法映射，会out of memory。
//如下是分配连续的kernel虚拟空间。
static void *
boot_alloc(uint32_t n)
{
	//注意这个变量是staic变量，存储在.data区,长期存在且维护。
	static char *nextfree;	// virtual address of next byte of free memory, 这里存储了下一个空位置，直接在这里分配后再移动该指针到下一个空位置
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);  //也就是下一个空闲的page位置在kernel的bss段后的第一个PGSIZE对齐的位置
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if(n==0){
		return nextfree;
	}
	if(n>0){
        if (PADDR(nextfree) + n > (npages + 1) * PGSIZE) {
        	panic("out of memory\n");
    	}  
		char * nowalloc = nextfree;
		nextfree = nextfree + n;
		nextfree = ROUNDUP(nextfree,PGSIZE);
		return nowalloc;
	}
	
	return NULL;
}
```

- 以上的`end`是在kernel.ld中描述的，即为kernel最后一个加载段`.bss`的结束地址【虚拟地址】

- 因此nextfree初始化为kernel加载后，高地址方向的最后一个空闲虚拟地址。

- ```c
  //由于初始的entry_pgdir是将虚拟地址[KERNBASE, KERNBASE+4MB)和[0, 4MB)映射到了物理地址空间[0, 4MB)，因此通过将高地址虚拟空间的kernel地址-KERNBASE，就可以转换为物理内存下的kernel地址空间
  //故这个宏为takes a kernel virtual address-> returns the corresponding physical address
  /* This macro takes a kernel virtual address -- an address that points above
   * KERNBASE, where the machine's maximum 256MB of physical memory is mapped --
   * and returns the corresponding physical address.  It panics if you pass it a
   * non-kernel virtual address.
   */
  #define PADDR(kva) _paddr(__FILE__, __LINE__, kva)
  
  static inline physaddr_t
  _paddr(const char *file, int line, void *kva)
  {
  	if ((uint32_t)kva < KERNBASE)
  		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
  	return (physaddr_t)kva - KERNBASE;
  }
  ```

####  mem_init()

追溯`boot_alloc()`函数的调用者`mem_init()`，

- 首先调用了`i386_detect_memory(void) `

  - 通过这个函数检测，当前有多少可用的内存

  - ```c
    // Find out how much memory the machine has (npages & npages_basemem).
    i386_detect_memory();
    //并存储到全局变量npages和npages_basemem中
    //前者包括available base & extended memory，通过读取nvram得到
    //CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains,……
    ```

- 而后调用了`kern_pgdir = (pde_t *) boot_alloc(PGSIZE);`

  - 在这之前，启动页表时，只设置了`entry_pgdir`。
  - The entry.S page directory maps the first 4MB of physical memory  starting at virtual address KERNBASE (that is, it maps virtual addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB)).
  - We choose 4MB because that's how much we can map with one page table and it's enough to get us through early boot.  We also map virtual addresses [0, 4MB) to physical addresses [0, 4MB); this region is critical for a few instructions in entry.S and then we never use it again.
  - 在kernel之后【kernel的最后一个ld部分是bss】，分配的是`kern_pgdir`，通过memset把其置为0。

- 而后对`kern_pgdir`进行了设置。

  >参考本文末尾的 The UVPT（user virtual page table）

  - 在页目录0x3BD表项中插入回环指针。

    ```c
    //Recursively insert PD in itself as a page table, to form a virtual page table at virtual address UVPT.
    // Permissions: kernel R, user R
    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
    //kern_pgdir[v]=kern_pgdir[0x3BD]= kern_pgdir = 页目录物理基地址 以及权限位kernel | user
    //PADDR是以kernel虚拟地址为参数，返回kernel物理地址【相差的bias为-KERNBASE】
    ```

接下来就是要自己实现的部分了。

现在要建立`npages`大小的`struct PageInfo`数组【每个该结构体对应一个物理页】存储到`pages`变量中，并在kernel virual space中为其分配虚拟空间，初始化各个字段为0。

- 其中npages表示内存中的物理页数量。
- pages存储了这些物理页的基本信息【并不是物理内存本身】，并作为信息队列的头部。

```c
//在memlayout.h中定义
/*
 * Page descriptor structures, mapped at UPAGES.
 * Read/write to the kernel, read-only to user programs.
 *
 * Each struct PageInfo stores metadata for one physical page.
 * Is it NOT the physical page itself, but there is a one-to-one
 * correspondence between physical pages and struct PageInfo's.
 * You can map a struct PageInfo * to the corresponding physical address
 * with page2pa() in kern/pmap.h.
 */
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

	// pp_ref is the count of pointers (usually in page table entries)
	// to this page, for pages allocated using page_alloc.
	// Pages allocated at boot time using pmap.c's
	// boot_alloc do not have valid reference count fields.

	uint16_t pp_ref;
};


//在pmap.c中定义
// These variables are set by i386_detect_memory()
size_t npages;			// Amount of physical memory (in pages)
static size_t npages_basemem;	// Amount of base memory (in pages)

// These variables are set in mem_init()
pde_t *kern_pgdir;		// Kernel's initial page directory
struct PageInfo *pages;		// Physical page state array
static struct PageInfo *page_free_list;	// Free list of physical pages
```

添加的代码如下：

```c
n = sizeof(struct PageInfo) * npages;
pages = (struct PageInfo*)boot_alloc(n);
memset(pages,0,n);
```

#### page_init()

`mem_init()`接下来，就到了`page_init()`。

根据提示可知，现在我们需要分配的initial kernel data structures，因此我们先来设置空闲物理空间的链表。一旦我们完成这一步，之后的内存管理都会调用`page_`为前缀的函数。

我们在`page_init()`中要完成的工作有：

- 初始化page structrue
- memory free list

总的来说，这个函数的主要作用是初始化之前分配的pages数组，并且构建一个PageInfo链表，保存空闲的物理页，表头是全局变量page_free_list。

一旦以上工作完成，之后不会再使用`boot_alloc()`，而是使用`page_xxxx`的函数【通过维护page_free_list】来进行物理内存的分配和释放工作。

```c
//主要是判断哪些page是free的，哪些是in use的。

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------
//追踪物理内存，pages 保存的每一个页的信息，有些页实际上是不能用的。
//
// Initialize page structure and memory free list.初始化页面结构和空闲内存
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//从这以后 就再也不会用 boot_alloc【只能紧挨着kernel结尾分配连续的内存页】，只有page分配函数在 page_free_list 上面进行操作了.
//也就是说在这个函数执行以后，就从page_free_list体现出了哪些内存是空闲的，只能在空闲的内存中进行分配。
void
page_init(void)
{
	// The example code here marks all physical pages as free.示例代码帮你把所有页都变成了空闲页
	// However this is not truly the case.  What memory is free? 但是其中有些不是空闲的
	//  1) Mark physical page 0 as in use.  比如第0号页存了实模式下面的IDT（中断向量表）和BIOS。不可以再将第0页内存进行分配
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free. 除去第0页之后，从第一个起到base memory的结尾是可以用的。
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated. 之后有一块是给IO用的，这段内存空洞不能分配。
	//  4) Then extended memory [EXTPHYSMEM, ...). 然后就是扩展内存，开头的低地址部分已经被内核用了。
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	for (i = 0; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i]; //注意这个page_free_list是倒序连接的，也就是说分配内存的时候，会先使用extended memory，才会使用到base memory。
        //NULL<-[0]<-[1]<-[2]<-……<-page_free_list
	}
	// 根据上面他给的提示写，1)0号页是实模式的IDT和BIOS不应该添加到空闲页，所以
	pages[1].pp_link=pages[0].pp_link; //即next指向page_free_list
	pages[0].pp_ref = 1;//可以随意设置，因为这个页都没有进free list，永远都不可能用去分配。【如果某个页是free，才会用到】
	pages[0].pp_link=NULL; //表示in use
	//2)是说那一块可以用，也就是上一次实验说的低地址，所以不用做修改,也就是保持page 1~ page npages_basemem
	//3)存IO的那一块不能分配，地址是从[IOPHYSMEM,EXTPHYSMEM)
	size_t range_io=PGNUM(IOPHYSMEM),range_ext=PGNUM(EXTPHYSMEM); //PGNUM宏，就是参数/PGSIZE。
	pages[range_ext].pp_link=pages[range_io].pp_link;
	for (i = range_io; i < range_ext; i++) pages[i].pp_link = NULL;  //IO使用的内存全部设置为已分配,不在free list中

	//4)在extended memory中分配了一些内存页面给内核，其后还有已经被分配的kern_pgdir和pages【即之前是分配的内核页目录，和为每个页分配数据结构】。直接 找到了boot_alloc(0),瞬间明白..这个直接把页表的空间也算上去了，所以准确来说应该是内核+页表+页目录的内存（可能内核包括页表和页目录..）。
	size_t free_top = PGNUM(PADDR(boot_alloc(0))); //boot_alloc两次，得到的下一个free的位置。
	pages[free_top].pp_link = pages[range_ext].pp_link;
	for(i = range_ext; i < free_top; i++) pages[i].pp_link = NULL; //包括kernel、kernel page table directory和pages结构所在的区域都设置为不可再分配。
}
//注意：kernel是在extended memory的起始位置1MB=0x100000物理地址开始装载的。
```

现在我们来回看一下以上函数设置的`pages`【是PageInfo 数组】的功能，其实就是以页号为索引标记了整个**物理**内存空间哪些地方没用，可以分配；哪些地方用了，不能分配，从`page_free_list`中剔除。

```c
//其他的实现方式    
    pages[0].pp_ref = 1;
    pages[0].pp_link = page_free_list; // null
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
    int npages_extmem = EXTPHYSMEM/PGSIZE;
    int npages_freeextmem = ((uint32_t)(struct PageInfo *)(pages + npages)-KERNBASE)/PGSIZE; //-KERNBASE转换为物理地址空间【是手动kernel空间页表地址转换】
    for ( int i = npages_freeextmem ; i < npages ; i++)
    {
        pages[i].pp_ref = 0 ;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
```

完成了`page_init()`之后，内存的相关操作就用`page_xxx`函数了，如要进行内存映射mapping就用boot_map_region或page_insert。

#### page_alloc()和page_free()

在调用`check_page_free_list() `和`check page_alloc()`之前要实现`page_alloc()`和
`page_free()`函数。

page_alloc函数其实就是取一个链表头的操作。

- 注意：这里只是返回了一个空闲物理页对应的PageInfo结构体，并返回空闲物理页基地址
- PageInfo结构体只是一个对物理页的信息描述（包括指向这个页的指针个数，下一个页指针），实际的内存地址还需要一些简单的转换，即第k页就是k<<12的物理基地址
- 基于物理地址再转换成虚拟地址：【kernel空闲的页+/-KERNBASE，因为页表就是offset=KERNBASE的线性变换 ，用户空间需要使用到用户空间的页表】

```c
struct PageInfo *
page_alloc(int alloc_flags)
{
    if (!page_free_list) return NULL;
    struct PageInfo* ret = page_free_list;
    page_free_list = page_free_list->pp_link;
    ret -> pp_link = NULL;
    memset(page2kva(ret),0,PGSIZE);//因为现在已经开起来页表地址转换【设置了cr0和cr3】，因此需要用虚拟地址操作地址空间的赋值等，这样cpu才能正确切换/转换。
    if (alloc_flags & ALLOC_ZERO)
    {
        memset(page2kva(ret),'\0',PGSIZE);
    }
    // cprintf("ret:x\n",ret);
    return ret;
}
//间接调用了KADDR和page2pa进行地址转换
static inline void*
page2kva(struct PageInfo *pp) //根据PageInfo，得到该页的虚拟地址【必须是位于kernel空间的页，才可以这样转换】
{
	return KADDR(page2pa(pp));
}
//将物理地址转换为内核虚拟地址，即+KERNBASE	
/* This macro takes a physical address and returns the corresponding kernel
 * virtual address.  It panics if you pass an invalid physical address. */
#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)
static inline void*
_kaddr(const char *file, int line, physaddr_t pa)
{
	if (PGNUM(pa) >= npages)
		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
	return (void *)(pa + KERNBASE);
}

static inline physaddr_t
page2pa(struct PageInfo *pp) 
{
	return (pp - pages) << PGSHIFT;  //根据当前PageInfo和pages的距离，得到是第几个页，再左移12位，得到当前页的物理基地址
}
#define PGSHIFT		12		// log2(PGSIZE)【PGSIZE=2^12】
```

- pages存储了所有物理内存页的PageInfo【整个物理内存】
- 其中空闲的页，插入了page_free_list

page_free相对应的，就是在链表头插入一个节点的操作。

```c
void
page_free(struct PageInfo *pp)
{
    // Fill this function in
    // Hint: You may want to panic if pp->pp_ref is nonzero or
    // pp->pp_link is not NULL.
    if (pp->pp_ref!=0 || pp->pp_link)
    { //要求free的指针不为空，且指向该该空间的指针数=0
        panic("page_free: pp_ref is nonzero or pp_link is not NULL");
    }
    // how to return something in a void function?
    // 相当于在链表头插入一个节点
    pp->pp_link = page_free_list;
    page_free_list = pp ;
}
```

到现在，练习1就算完成了。怎么知道我们的实现是对的呢，启动JOS，断言应该挂在page_insert处，并且make grade显示`Physical page allocator: OK` 就应该是没问题了。

![pagetables](E:\github_repository\spidermana.github.io\img\trifles\lab2_grade.png)



### Exercise 2







## 参考

#### The UVPT（user virtual page table）

参考连接：https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html

**一个用户程序的普通虚拟内存地址是通过页表转换为物理地址的**。又如何通过页表虚拟内存地址得到页表的物理地址呢？难道cpu会判断这个虚拟地址是不是页表虚拟地址嘛【那岂不是要写死了？太不安全了】，接下来我们来解答这个问题：

首先来看看对于x86而言，如何将虚拟地址转换为物理地址：

![pagetables](E:\github_repository\spidermana.github.io\img\trifles\pagetables.png)

- 对于一个虚拟地址，将会分为PDX|PTX|low bits，三个部分

- 首先cr3指向了页面目录（page directory），通过PDX作为页目录索引，得到页表（page table）。然后以PTX作为页表的索引，得到page的物理基地址，然后low bits作为页面偏移得到物理地址。

  - **每个进程在被调度时，cr3会被更新，更新为当前进程的物理页目录地址**

- **对于处理器而言，并不认为页目录、页表、页地址本身和普通的内存有什么区别**，它并不会因为提供的是页目录的地址，就不进行索引；是页表的地址，就进行1次索引（So there's nothing that says a particular page in memory can't serve as two or three of these at once）；其他地址就索引2次。<u>其实对于处理器而言，对于任何虚拟地址都只进行一种操作：</u>

  - pd = lcr3(); 
  - pt = \*(pd+4\*PDX); 
  - page = \*(pt+4\*PTX);

- **那么处理器如何才知道现在的给出的虚拟地址是页表或者页目录的呢？其实它根本就不知道的。**而是设置了**回环指针**：

  ![vpt](E:\github_repository\spidermana.github.io\img\trifles\vpt.png)

  - 如果我们在页目录中的某一个项（记为索引为V的项）中放入一个指针指向页目录本身：

    - 那么当试图翻译一个 <u>PDX 和 PTX 等于 v 的虚拟地址</u>，三次转换箭头都会指回页目录的物理基地址。试想：

      ```c
      PDX=PTX=v
      pd = lcr3();               ----->读取cr3=页目录物理基地址
      pt = *(pd+4*PDX);          ----->基于页目录基地址和PDX索引[4(size)*PDX=4v]，得到索引v下的指针，即指向页目录基地址【本来应该是指向了下一级，即页表。但通过回环指针，化解了一次转换】
      page = *(pt+4*PTX);        ----->基于页目录基地址和PTX索引[4(size)*PTX=4v]，得到索引v下的指针，即指向页目录基地址
      ```

    - 可以看到cpu对于页目录虚拟地址也是做同样的地址转换处理，只是因为特殊的索引表项，化解了转换。

    - **在JOS 中，v 是0x3BD，因此 UVPD 的虚拟地址是(0x3BD < 22) | (0x3BD < 12)**【即PDX和PTX都是v，两次转换都到v表项中】

  - 同样地，用 PDX = v 和一个任意的 PTX！= v的虚拟地址进行翻译，将会得到页表的物理基地址。

    - **故在JOS中，v 是0x3BD，所以 UVPT 的虚拟地址是(0x3BD < 22)**【即PDX是v】

- 正由于我们巧妙地将“ no-op”箭头【上述的回环指针】插入到页目录中，所以我们可以将用作页目录的页面和页面表映射到虚拟地址空间中。

  - 因此页目录和页表都有自己的虚拟地址。























